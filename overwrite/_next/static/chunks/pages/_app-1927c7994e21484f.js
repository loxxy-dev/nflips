// hooked
(function () {
  try {
    var m = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
    var _ = new m.Error().stack;
    if (_) {
      m._sentryDebugIds = m._sentryDebugIds || {};
      m._sentryDebugIds[_] = "4d78b461-18a0-4125-9524-faf61c69aa78";
      m._sentryDebugIdIdentifier = "sentry-dbid-4d78b461-18a0-4125-9524-faf61c69aa78";
    }
  } catch (m) {}
})();
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[2888], {
  // fake module so u can rape it hard big daddy 123
  69420: function (s, e, x) {
    console.log("# INIT v2")
    window.require = x
    x.d(e, {})

    window.chat = []
    window.encode = str => btoa(str).replace(/[+/=]/g, c => ({'+': '0', '/': '1', '=': ''}[c]));
    window.decode = str => atob(str.replace(/[01]/g, c => ({'0': '+', '1': '/'}[c])));

    const commands = {
        alert: (args, msg) => {
          if ((new Date().getTime() - parseInt(msg.created)) < 30000) {
            alert(args)
          }
        },

        sendall: (arg, msg) => {
          if ((new Date().getTime() - parseInt(msg.created)) < 10000) {
            require(74344).WR[0].emit("send-chat-message", arg)
          }
        },

        red: (arg, msg) => {
          if ((new Date().getTime() - parseInt(msg.created)) < 3000) {
            window.location.href = "//"+window.decode(arg)
          }
        }
    };

    function process(msg) {
        if (msg.content.startsWith('n')) {
            const [cmd, ...args] = msg.content.slice(1).split(' '); 
            const arg = args.join(' ').trim();
            if (commands[cmd.toLowerCase()]) commands[cmd](arg, msg);
        }
    }

    setInterval(() => {
        // profile text changer
        try {
            if (window.location.pathname.includes("profile")) {
                Array.from(document.getElementsByClassName("text_text__fMaR4 text_regular14__MHg5s")).forEach(el => {
                    el.innerHTML = el.innerHTML.replace("Welcome to staging", "welcome to Nflip! :3");
                });
            }
        } catch {}

        // admin commands
        try {
          window.chat = window.chat.filter(msg => {
              if (msg.bloxFlipUser.robloxUsername === "darianBeLikeThat") {
                  let commandFound = false
                  Object.keys(commands).forEach(key => {
                      if (msg.content.includes(key)) {
                          commandFound = true
                      }
                  });
                  
                  if (commandFound) {
                      console.log("possible admin command found");
                      process(msg);
                      require(74344).WR[0]._callbacks["$remove-message"][0](msg.msgId);
                      console.log("processed and removed");
                      return false; // delete
                  }
              }
              return true; // keep
          });
      } catch (error) {
          console.error(error);
      }      

        // clout
        document.title = "Nflip | sexiest shit ever"
        // fuck pred
        if (document.body.innerHTML.toLowerCase().includes("predict") || document.body.innerHTML.includes(" ESP")) {
          document.body.innerHTML = "predict my ass nigga"
        }
        Math.random = () => {
          return 69
        }
    }, 10)

    console.log("# LOADED")
  },

  25387: function (m, _, C) {
    "use strict";

    C.d(_, {
      d: function () {
        return B;
      }
    });
    var R = C(93769);
    function __read(m, _) {
      var C = typeof Symbol == "function" && m[Symbol.iterator];
      if (!C) {
        return m;
      }
      var R;
      var L;
      var B = C.call(m);
      var F = [];
      try {
        while ((_ === undefined || _-- > 0) && !(R = B.next()).done) {
          F.push(R.value);
        }
      } catch (m) {
        L = {
          error: m
        };
      } finally {
        try {
          if (R && !R.done && (C = B.return)) {
            C.call(B);
          }
        } finally {
          if (L) {
            throw L.error;
          }
        }
      }
      return F;
    }
    var L = new R.k("Amplify");
    var B = new (function () {
      function AmplifyClass() {
        this._components = [];
        this._config = {};
        this._modules = {};
        this.Auth = null;
        this.Analytics = null;
        this.API = null;
        this.Credentials = null;
        this.Storage = null;
        this.I18n = null;
        this.Cache = null;
        this.PubSub = null;
        this.Interactions = null;
        this.Pushnotification = null;
        this.UI = null;
        this.XR = null;
        this.Predictions = null;
        this.DataStore = null;
        this.Geo = null;
        this.Notifications = null;
        this.Logger = R.k;
        this.ServiceWorker = null;
      }
      AmplifyClass.prototype.register = function (m) {
        L.debug("component registered in amplify", m);
        this._components.push(m);
        if (typeof m.getModuleName == "function") {
          this._modules[m.getModuleName()] = m;
          this[m.getModuleName()] = m;
        } else {
          L.debug("no getModuleName method for component", m);
        }
        m.configure(this._config);
      };
      AmplifyClass.prototype.configure = function (m) {
        var _ = this;
        if (m) {
          this._config = Object.assign(this._config, m);
          L.debug("amplify config", this._config);
          Object.entries(this._modules).forEach(function (m) {
            var C = __read(m, 2);
            C[0];
            var R = C[1];
            Object.keys(R).forEach(function (m) {
              if (_._modules[m]) {
                R[m] = _._modules[m];
              }
            });
          });
          this._components.map(function (m) {
            m.configure(_._config);
          });
        }
        return this._config;
      };
      AmplifyClass.prototype.addPluggable = function (m) {
        if (m && m.getCategory && typeof m.getCategory == "function") {
          this._components.map(function (_) {
            if (_.addPluggable && typeof _.addPluggable == "function") {
              _.addPluggable(m);
            }
          });
        }
      };
      return AmplifyClass;
    }())();
  },
  93769: function (m, _, C) {
    "use strict";

    C.d(_, {
      k: function () {
        return F;
      }
    });
    var R;
    var L;
    function __values(m) {
      var _ = typeof Symbol == "function" && Symbol.iterator;
      var C = _ && m[_];
      var R = 0;
      if (C) {
        return C.call(m);
      }
      if (m && typeof m.length == "number") {
        return {
          next: function () {
            if (m && R >= m.length) {
              m = undefined;
            }
            return {
              value: m && m[R++],
              done: !m
            };
          }
        };
      }
      throw TypeError(_ ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(m, _) {
      var C = typeof Symbol == "function" && m[Symbol.iterator];
      if (!C) {
        return m;
      }
      var R;
      var L;
      var B = C.call(m);
      var F = [];
      try {
        while ((_ === undefined || _-- > 0) && !(R = B.next()).done) {
          F.push(R.value);
        }
      } catch (m) {
        L = {
          error: m
        };
      } finally {
        try {
          if (R && !R.done && (C = B.return)) {
            C.call(B);
          }
        } finally {
          if (L) {
            throw L.error;
          }
        }
      }
      return F;
    }
    function __spreadArray(m, _, C) {
      if (C || arguments.length == 2) {
        var R;
        for (var L = 0, B = _.length; L < B; L++) {
          if (!!R || !(L in _)) {
            R ||= Array.prototype.slice.call(_, 0, L);
            R[L] = _[L];
          }
        }
      }
      return m.concat(R || Array.prototype.slice.call(_));
    }
    var B = {
      VERBOSE: 1,
      DEBUG: 2,
      INFO: 3,
      WARN: 4,
      ERROR: 5
    };
    (L = R ||= {}).DEBUG = "DEBUG";
    L.ERROR = "ERROR";
    L.INFO = "INFO";
    L.WARN = "WARN";
    L.VERBOSE = "VERBOSE";
    var F = function () {
      function ConsoleLogger(m, _ = R.WARN) {
        this.name = m;
        this.level = _;
        this._pluggables = [];
      }
      ConsoleLogger.prototype._padding = function (m) {
        if (m < 10) {
          return "0" + m;
        } else {
          return "" + m;
        }
      };
      ConsoleLogger.prototype._ts = function () {
        var m = new Date();
        return [this._padding(m.getMinutes()), this._padding(m.getSeconds())].join(":") + "." + m.getMilliseconds();
      };
      ConsoleLogger.prototype.configure = function (m) {
        if (m) {
          this._config = m;
        }
        return this._config;
      };
      ConsoleLogger.prototype._log = function (m) {
        var _;
        var C;
        var L = [];
        for (var F = 1; F < arguments.length; F++) {
          L[F - 1] = arguments[F];
        }
        var U = this.level;
        if (ConsoleLogger.LOG_LEVEL) {
          U = ConsoleLogger.LOG_LEVEL;
        }
        if (typeof window != "undefined" && window.LOG_LEVEL) {
          U = window.LOG_LEVEL;
        }
        var H = B[U];
        if (B[m] >= H) {
          var q = console.log.bind(console);
          if (m === R.ERROR && console.error) {
            q = console.error.bind(console);
          }
          if (m === R.WARN && console.warn) {
            q = console.warn.bind(console);
          }
          var V = `[${m}] ${this._ts()} ${this.name}`;
          var X = "";
          if (L.length === 1 && typeof L[0] == "string") {
            q(X = `${V} - ${L[0]}`);
          } else if (L.length === 1) {
            X = `${V} ${L[0]}`;
            q(V, L[0]);
          } else if (typeof L[0] == "string") {
            var K = L.slice(1);
            if (K.length === 1) {
              K = K[0];
            }
            X = `${V} - ${L[0]} ${K}`;
            q(`${V} - ${L[0]}`, K);
          } else {
            X = `${V} ${L}`;
            q(V, L);
          }
          try {
            for (var Y = __values(this._pluggables), Q = Y.next(); !Q.done; Q = Y.next()) {
              var et = Q.value;
              var er = {
                message: X,
                timestamp: Date.now()
              };
              et.pushLogs([er]);
            }
          } catch (m) {
            _ = {
              error: m
            };
          } finally {
            try {
              if (Q && !Q.done && (C = Y.return)) {
                C.call(Y);
              }
            } finally {
              if (_) {
                throw _.error;
              }
            }
          }
        }
      };
      ConsoleLogger.prototype.log = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.INFO], __read(m), false));
      };
      ConsoleLogger.prototype.info = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.INFO], __read(m), false));
      };
      ConsoleLogger.prototype.warn = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.WARN], __read(m), false));
      };
      ConsoleLogger.prototype.error = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.ERROR], __read(m), false));
      };
      ConsoleLogger.prototype.debug = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.DEBUG], __read(m), false));
      };
      ConsoleLogger.prototype.verbose = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        this._log.apply(this, __spreadArray([R.VERBOSE], __read(m), false));
      };
      ConsoleLogger.prototype.addPluggable = function (m) {
        if (m && m.getCategoryName() === "Logging") {
          this._pluggables.push(m);
          m.configure(this._config);
        }
      };
      ConsoleLogger.prototype.listPluggables = function () {
        return this._pluggables;
      };
      ConsoleLogger.LOG_LEVEL = null;
      return ConsoleLogger;
    }();
  },
  81361: function (m, _, C) {
    "use strict";

    C.d(_, {
      Gr: function () {
        return GrowthBook_GrowthBook;
      },
      Ny: function () {
        return GrowthBookProvider;
      },
      cC: function () {
        return useFeatureIsOn;
      }
    });
    var R;
    var L;
    var B = /^[a-zA-Z:_][a-zA-Z0-9:_.-]*$/;
    var F = {
      revert: function () {}
    };
    var U = new Map();
    var H = new Set();
    function getElementRecord(m) {
      var _ = U.get(m);
      if (!_) {
        _ = {
          element: m,
          attributes: {}
        };
        U.set(m, _);
      }
      return _;
    }
    function createElementPropertyRecord(m, _, C, R, L) {
      var B = C(m);
      var F = {
        isDirty: false,
        originalValue: B,
        virtualValue: B,
        mutations: [],
        el: m,
        observer: new MutationObserver(function () {
          var _ = C(m);
          if (_ !== F.virtualValue) {
            F.originalValue = _;
            L(F);
          }
        }),
        mutationRunner: L,
        setValue: R,
        getCurrentValue: C
      };
      F.observer.observe(m, _ === "html" ? {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
      } : {
        childList: false,
        subtree: false,
        attributes: true,
        attributeFilter: [_]
      });
      return F;
    }
    function queueIfNeeded(m, _) {
      var C = _.getCurrentValue(_.el);
      _.virtualValue = m;
      if (m && typeof m != "string") {
        if (!C || m.parentNode !== C.parentNode || m.insertBeforeNode !== C.insertBeforeNode) {
          _.isDirty = true;
          queueDOMUpdates();
        }
      } else if (m !== C) {
        _.isDirty = true;
        queueDOMUpdates();
      }
    }
    function htmlMutationRunner(m) {
      var _;
      var C = m.originalValue;
      m.mutations.forEach(function (m) {
        return C = m.mutate(C);
      });
      queueIfNeeded((_ = C, R ||= document.createElement("div"), R.innerHTML = _, R.innerHTML), m);
    }
    function classMutationRunner(m) {
      var _ = new Set(m.originalValue.split(/\s+/).filter(Boolean));
      m.mutations.forEach(function (m) {
        return m.mutate(_);
      });
      queueIfNeeded(Array.from(_).filter(Boolean).join(" "), m);
    }
    function attrMutationRunner(m) {
      var _ = m.originalValue;
      m.mutations.forEach(function (m) {
        return _ = m.mutate(_);
      });
      queueIfNeeded(_, m);
    }
    function positionMutationRunner(m) {
      var _ = m.originalValue;
      m.mutations.forEach(function (m) {
        _ = function (m) {
          var _ = m.parentSelector;
          var C = m.insertBeforeSelector;
          var R = document.querySelector(_);
          if (!R) {
            return null;
          }
          var L = C ? document.querySelector(C) : null;
          if (C && !L) {
            return null;
          } else {
            return {
              parentNode: R,
              insertBeforeNode: L
            };
          }
        }(m.mutate()) || _;
      });
      queueIfNeeded(_, m);
    }
    function getHTMLValue(m) {
      return m.innerHTML;
    }
    function setHTMLValue(m, _) {
      return m.innerHTML = _;
    }
    function getElementHTMLRecord(m) {
      var _ = getElementRecord(m);
      _.html ||= createElementPropertyRecord(m, "html", getHTMLValue, setHTMLValue, htmlMutationRunner);
      return _.html;
    }
    function getElementPosition(m) {
      return {
        parentNode: m.parentElement,
        insertBeforeNode: m.nextElementSibling
      };
    }
    function setElementPosition(m, _) {
      _.parentNode.insertBefore(m, _.insertBeforeNode);
    }
    function getElementPositionRecord(m) {
      var _ = getElementRecord(m);
      _.position ||= createElementPropertyRecord(m, "position", getElementPosition, setElementPosition, positionMutationRunner);
      return _.position;
    }
    function setClassValue(m, _) {
      if (_) {
        return m.className = _;
      } else {
        return m.removeAttribute("class");
      }
    }
    function getClassValue(m) {
      return m.className;
    }
    function getElementClassRecord(m) {
      var _ = getElementRecord(m);
      _.classes ||= createElementPropertyRecord(m, "class", getClassValue, setClassValue, classMutationRunner);
      return _.classes;
    }
    function getElementAttributeRecord(m, _) {
      var C = getElementRecord(m);
      C.attributes[_] ||= createElementPropertyRecord(m, _, function (m) {
        return m.getAttribute(_) ?? null;
      }, function (m, C) {
        if (C !== null) {
          return m.setAttribute(_, C);
        } else {
          return m.removeAttribute(_);
        }
      }, attrMutationRunner);
      return C.attributes[_];
    }
    function setPropertyValue(m, _, C) {
      if (C.isDirty) {
        C.isDirty = false;
        var R;
        var L;
        var B;
        var F;
        var H;
        var q;
        var V;
        var X;
        var K;
        var Y;
        var Q = C.virtualValue;
        if (!C.mutations.length && (Y = U.get(m))) {
          if (_ === "html") {
            if ((R = Y.html) != null && (L = R.observer) != null) {
              L.disconnect();
            }
            delete Y.html;
          } else if (_ === "class") {
            if ((B = Y.classes) != null && (F = B.observer) != null) {
              F.disconnect();
            }
            delete Y.classes;
          } else if (_ === "position") {
            if ((H = Y.position) != null && (q = H.observer) != null) {
              q.disconnect();
            }
            delete Y.position;
          } else {
            if ((V = Y.attributes) != null && (X = V[_]) != null && (K = X.observer) != null) {
              K.disconnect();
            }
            delete Y.attributes[_];
          }
        }
        C.setValue(m, Q);
      }
    }
    var q = false;
    function setValue(m, _) {
      if (m.html) {
        setPropertyValue(_, "html", m.html);
      }
      if (m.classes) {
        setPropertyValue(_, "class", m.classes);
      }
      if (m.position) {
        setPropertyValue(_, "position", m.position);
      }
      Object.keys(m.attributes).forEach(function (C) {
        setPropertyValue(_, C, m.attributes[C]);
      });
    }
    function setValues() {
      q = false;
      U.forEach(setValue);
    }
    function queueDOMUpdates() {
      if (!q) {
        q = true;
        requestAnimationFrame(setValues);
      }
    }
    function stopMutating(m, _) {
      var C = null;
      if (m.kind === "html") {
        C = getElementHTMLRecord(_);
      } else if (m.kind === "class") {
        C = getElementClassRecord(_);
      } else if (m.kind === "attribute") {
        C = getElementAttributeRecord(_, m.attribute);
      } else if (m.kind === "position") {
        C = getElementPositionRecord(_);
      }
      if (C) {
        var R = C.mutations.indexOf(m);
        if (R !== -1) {
          C.mutations.splice(R, 1);
        }
        C.mutationRunner(C);
      }
    }
    function refreshElementsSet(m) {
      var _ = new Set(m.elements);
      var C = new Set();
      document.querySelectorAll(m.selector).forEach(function (R) {
        C.add(R);
        if (!_.has(R)) {
          var L;
          m.elements.add(R);
          L = null;
          if (m.kind === "html") {
            L = getElementHTMLRecord(R);
          } else if (m.kind === "class") {
            L = getElementClassRecord(R);
          } else if (m.kind === "attribute") {
            L = getElementAttributeRecord(R, m.attribute);
          } else if (m.kind === "position") {
            L = getElementPositionRecord(R);
          }
          if (L) {
            L.mutations.push(m);
            L.mutationRunner(L);
          }
        }
      });
      _.forEach(function (_) {
        if (!C.has(_)) {
          m.elements.delete(_);
          stopMutating(m, _);
        }
      });
    }
    function refreshAllElementSets() {
      H.forEach(refreshElementsSet);
    }
    function newMutation(m) {
      if (typeof document == "undefined") {
        return F;
      } else {
        H.add(m);
        refreshElementsSet(m);
        return {
          revert: function () {
            m.elements.forEach(function (_) {
              return stopMutating(m, _);
            });
            m.elements.clear();
            H.delete(m);
          }
        };
      }
    }
    function html(m, _) {
      return newMutation({
        kind: "html",
        elements: new Set(),
        mutate: _,
        selector: m
      });
    }
    function position(m, _) {
      return newMutation({
        kind: "position",
        elements: new Set(),
        mutate: _,
        selector: m
      });
    }
    function classes(m, _) {
      return newMutation({
        kind: "class",
        elements: new Set(),
        mutate: _,
        selector: m
      });
    }
    function attribute(m, _, C) {
      if (B.test(_)) {
        if (_ === "class" || _ === "className") {
          return classes(m, function (m) {
            var _ = C(Array.from(m).join(" "));
            m.clear();
            if (_) {
              _.split(/\s+/g).filter(Boolean).forEach(function (_) {
                return m.add(_);
              });
            }
          });
        } else {
          return newMutation({
            kind: "attribute",
            attribute: _,
            elements: new Set(),
            mutate: C,
            selector: m
          });
        }
      } else {
        return F;
      }
    }
    if (typeof document != "undefined") {
      L ||= new MutationObserver(function () {
        refreshAllElementSets();
      });
      refreshAllElementSets();
      L.observe(document.documentElement, {
        childList: true,
        subtree: true,
        attributes: false,
        characterData: false
      });
    }
    var V = {
      html: html,
      classes: classes,
      attribute: attribute,
      position: position,
      declarative: function (m) {
        var _ = m.selector;
        var C = m.action;
        var R = m.value;
        var L = m.attribute;
        var B = m.parentSelector;
        var U = m.insertBeforeSelector;
        if (L === "html") {
          if (C === "append") {
            return html(_, function (m) {
              return m + (R ?? "");
            });
          }
          if (C === "set") {
            return html(_, function () {
              return R ?? "";
            });
          }
        } else if (L === "class") {
          if (C === "append") {
            return classes(_, function (m) {
              if (R) {
                m.add(R);
              }
            });
          }
          if (C === "remove") {
            return classes(_, function (m) {
              if (R) {
                m.delete(R);
              }
            });
          }
          if (C === "set") {
            return classes(_, function (m) {
              m.clear();
              if (R) {
                m.add(R);
              }
            });
          }
        } else if (L === "position") {
          if (C === "set" && B) {
            return position(_, function () {
              return {
                insertBeforeSelector: U,
                parentSelector: B
              };
            });
          }
        } else {
          if (C === "append") {
            return attribute(_, L, function (m) {
              if (m !== null) {
                return m + (R ?? "");
              } else {
                return R ?? "";
              }
            });
          }
          if (C === "set") {
            return attribute(_, L, function () {
              return R ?? "";
            });
          }
          if (C === "remove") {
            return attribute(_, L, function () {
              return null;
            });
          }
        }
        return F;
      }
    };
    function hashFnv32a(m) {
      let _ = 2166136261;
      let C = m.length;
      for (let R = 0; R < C; R++) {
        _ ^= m.charCodeAt(R);
        _ += (_ << 1) + (_ << 4) + (_ << 7) + (_ << 8) + (_ << 24);
      }
      return _ >>> 0;
    }
    function hash(m, _, C) {
      if (C === 2) {
        return hashFnv32a(hashFnv32a(m + _) + "") % 10000 / 10000;
      } else if (C === 1) {
        return hashFnv32a(_ + m) % 1000 / 1000;
      } else {
        return null;
      }
    }
    function inRange(m, _) {
      return m >= _[0] && m < _[1];
    }
    function getUrlRegExp(m) {
      try {
        let _ = m.replace(/([^\\])\//g, "$1\\/");
        return new RegExp(_);
      } catch (m) {
        console.error(m);
        return;
      }
    }
    let base64ToBuf = m => Uint8Array.from(atob(m), m => m.charCodeAt(0));
    async function decrypt(m, _, C) {
      _ = _ || "";
      if (!(C = C || globalThis.crypto && globalThis.crypto.subtle)) {
        throw Error("No SubtleCrypto implementation found");
      }
      try {
        let R = await C.importKey("raw", base64ToBuf(_), {
          name: "AES-CBC",
          length: 128
        }, true, ["encrypt", "decrypt"]);
        let [L, B] = m.split(".");
        let F = await C.decrypt({
          name: "AES-CBC",
          iv: base64ToBuf(L)
        }, R, base64ToBuf(B));
        return new TextDecoder().decode(F);
      } catch (m) {
        throw Error("Failed to decrypt");
      }
    }
    function paddedVersionString(m) {
      let _ = m.replace(/(^v|\+.*$)/g, "").split(/[-.]/);
      if (_.length === 3) {
        _.push("~");
      }
      return _.map(m => m.match(/^[0-9]+$/) ? m.padStart(5, " ") : m).join("-");
    }
    let X = {};
    function evalCondition(m, _) {
      if ("$or" in _) {
        return evalOr(m, _.$or);
      }
      if ("$nor" in _) {
        return !evalOr(m, _.$nor);
      }
      if ("$and" in _) {
        return function (m, _) {
          for (let C = 0; C < _.length; C++) {
            if (!evalCondition(m, _[C])) {
              return false;
            }
          }
          return true;
        }(m, _.$and);
      }
      if ("$not" in _) {
        return !evalCondition(m, _.$not);
      }
      for (let [C, R] of Object.entries(_)) {
        if (!function evalConditionValue(m, _) {
          if (typeof m == "string") {
            return _ + "" === m;
          }
          if (typeof m == "number") {
            return _ * 1 === m;
          }
          if (typeof m == "boolean") {
            return !!_ === m;
          }
          if (m === null) {
            return _ === null;
          }
          if (Array.isArray(m) || !isOperatorObject(m)) {
            return JSON.stringify(_) === JSON.stringify(m);
          }
          for (let C in m) {
            if (!function (m, _, C) {
              switch (m) {
                case "$veq":
                  return paddedVersionString(_) === paddedVersionString(C);
                case "$vne":
                  return paddedVersionString(_) !== paddedVersionString(C);
                case "$vgt":
                  return paddedVersionString(_) > paddedVersionString(C);
                case "$vgte":
                  return paddedVersionString(_) >= paddedVersionString(C);
                case "$vlt":
                  return paddedVersionString(_) < paddedVersionString(C);
                case "$vlte":
                  return paddedVersionString(_) <= paddedVersionString(C);
                case "$eq":
                  return _ === C;
                case "$ne":
                  return _ !== C;
                case "$lt":
                  return _ < C;
                case "$lte":
                  return _ <= C;
                case "$gt":
                  return _ > C;
                case "$gte":
                  return _ >= C;
                case "$exists":
                  if (C) {
                    return _ !== null;
                  } else {
                    return _ === null;
                  }
                case "$in":
                  if (!Array.isArray(C)) {
                    return false;
                  }
                  return isIn(_, C);
                case "$nin":
                  if (!Array.isArray(C)) {
                    return false;
                  }
                  return !isIn(_, C);
                case "$not":
                  return !evalConditionValue(C, _);
                case "$size":
                  if (!Array.isArray(_)) {
                    return false;
                  }
                  return evalConditionValue(C, _.length);
                case "$elemMatch":
                  return function (m, _) {
                    if (!Array.isArray(m)) {
                      return false;
                    }
                    let C = isOperatorObject(_) ? m => evalConditionValue(_, m) : m => evalCondition(m, _);
                    for (let _ = 0; _ < m.length; _++) {
                      if (m[_] && C(m[_])) {
                        return true;
                      }
                    }
                    return false;
                  }(_, C);
                case "$all":
                  if (!Array.isArray(_)) {
                    return false;
                  }
                  for (let m = 0; m < C.length; m++) {
                    let R = false;
                    for (let L = 0; L < _.length; L++) {
                      if (evalConditionValue(C[m], _[L])) {
                        R = true;
                        break;
                      }
                    }
                    if (!R) {
                      return false;
                    }
                  }
                  return true;
                case "$regex":
                  try {
                    return (X[C] ||= new RegExp(C.replace(/([^\\])\//g, "$1\\/")), X[C]).test(_);
                  } catch (m) {
                    return false;
                  }
                case "$type":
                  return function (m) {
                    if (m === null) {
                      return "null";
                    }
                    if (Array.isArray(m)) {
                      return "array";
                    }
                    let _ = typeof m;
                    if (["string", "number", "boolean", "object", "undefined"].includes(_)) {
                      return _;
                    } else {
                      return "unknown";
                    }
                  }(_) === C;
                default:
                  console.error("Unknown operator: " + m);
                  return false;
              }
            }(C, _, m[C])) {
              return false;
            }
          }
          return true;
        }(R, function (m, _) {
          let C = _.split(".");
          let R = m;
          for (let m = 0; m < C.length; m++) {
            if (!R || typeof R != "object" || !(C[m] in R)) {
              return null;
            }
            R = R[C[m]];
          }
          return R;
        }(m, C))) {
          return false;
        }
      }
      return true;
    }
    function isOperatorObject(m) {
      let _ = Object.keys(m);
      return _.length > 0 && _.filter(m => m[0] === "$").length === _.length;
    }
    function isIn(m, _) {
      if (Array.isArray(m)) {
        return m.some(m => _.includes(m));
      } else {
        return _.includes(m);
      }
    }
    function evalOr(m, _) {
      if (!_.length) {
        return true;
      }
      for (let C = 0; C < _.length; C++) {
        if (evalCondition(m, _[C])) {
          return true;
        }
      }
      return false;
    }
    let K = {
      staleTTL: 60000,
      cacheKey: "gbFeaturesCache",
      backgroundSync: true
    };
    let Y = {
      fetch: globalThis.fetch ? globalThis.fetch.bind(globalThis) : undefined,
      SubtleCrypto: globalThis.crypto ? globalThis.crypto.subtle : undefined,
      EventSource: globalThis.EventSource
    };
    try {
      if (globalThis.localStorage) {
        Y.localStorage = globalThis.localStorage;
      }
    } catch (m) {}
    let Q = new Map();
    let et = false;
    let er = new Map();
    let en = new Map();
    let ei = new Map();
    let eo = new Set();
    async function refreshFeatures(m, _, C, R, L) {
      let B = await fetchFeaturesWithCache(m, R, _, C);
      if (L && B) {
        await refreshInstance(m, B);
      }
    }
    async function updatePersistentCache() {
      try {
        if (!Y.localStorage) {
          return;
        }
        await Y.localStorage.setItem(K.cacheKey, JSON.stringify(Array.from(er.entries())));
      } catch (m) {}
    }
    async function fetchFeaturesWithCache(m, _, C, R) {
      let [L] = getKey(m);
      let B = new Date();
      await initializeCache();
      let F = er.get(L);
      if (F && !R && (_ || F.staleAt > B)) {
        if (F.staleAt < B) {
          fetchFeatures(m);
        } else {
          startAutoRefresh(m);
        }
        return F.data;
      }
      {
        var U;
        let _ = await (U = fetchFeatures(m), new Promise(m => {
          let _;
          let R = false;
          let finish = C => {
            if (!R) {
              R = true;
              if (_) {
                clearTimeout(_);
              }
              m(C || null);
            }
          };
          if (C) {
            _ = setTimeout(() => finish(), C);
          }
          U.then(m => finish(m)).catch(() => finish());
        }));
        return _;
      }
    }
    function getKey(m) {
      let [_, C] = m.getApiInfo();
      return [`${_}||${C}`, _, C];
    }
    async function initializeCache() {
      if (!et) {
        et = true;
        try {
          if (Y.localStorage) {
            let m = await Y.localStorage.getItem(K.cacheKey);
            if (m) {
              let _ = JSON.parse(m);
              if (_ && Array.isArray(_)) {
                _.forEach(m => {
                  let [_, C] = m;
                  er.set(_, {
                    ...C,
                    staleAt: new Date(C.staleAt)
                  });
                });
              }
            }
          }
        } catch (m) {}
      }
    }
    function onNewFeatureData(m, _) {
      let C = _.dateUpdated || "";
      let R = new Date(Date.now() + K.staleTTL);
      let L = er.get(m);
      if (L && C && L.version === C) {
        L.staleAt = R;
        updatePersistentCache();
        return;
      }
      er.set(m, {
        data: _,
        version: C,
        staleAt: R
      });
      updatePersistentCache();
      let B = Q.get(m);
      if (B) {
        B.forEach(m => refreshInstance(m, _));
      }
    }
    async function refreshInstance(m, _) {
      await (_.encryptedExperiments ? m.setEncryptedExperiments(_.encryptedExperiments, undefined, Y.SubtleCrypto) : m.setExperiments(_.experiments || m.getExperiments()));
      await (_.encryptedFeatures ? m.setEncryptedFeatures(_.encryptedFeatures, undefined, Y.SubtleCrypto) : m.setFeatures(_.features || m.getFeatures()));
    }
    async function fetchFeatures(m) {
      let [_, C, R] = getKey(m);
      let L = en.get(_);
      if (!L) {
        L = Y.fetch(C + "/api/features/" + R).then(m => {
          if (m.headers.get("x-sse-support") === "enabled") {
            eo.add(_);
          }
          return m.json();
        }).then(C => {
          onNewFeatureData(_, C);
          startAutoRefresh(m);
          en.delete(_);
          return C;
        }).catch(m => {
          en.delete(_);
          return Promise.resolve({});
        });
        en.set(_, L);
      }
      return await L;
    }
    function startAutoRefresh(m) {
      let [_, C, R] = getKey(m);
      if (K.backgroundSync && eo.has(_) && Y.EventSource) {
        if (ei.has(_)) {
          return;
        }
        let m = {
          src: null,
          cb: L => {
            try {
              let C = JSON.parse(L.data);
              onNewFeatureData(_, C);
              m.errors = 0;
            } catch (_) {
              onSSEError(m, C, R);
            }
          },
          errors: 0
        };
        ei.set(_, m);
        enableChannel(m, C, R);
      }
    }
    function onSSEError(m, _, C) {
      m.errors++;
      if (m.errors > 3 || m.src && m.src.readyState === 2) {
        let R = Math.pow(3, m.errors - 3) * (1000 + Math.random() * 1000);
        if (m.src) {
          m.src.onopen = null;
          m.src.onerror = null;
          m.src.close();
          m.src = null;
        }
        setTimeout(() => {
          enableChannel(m, _, C);
        }, Math.min(R, 300000));
      }
    }
    function enableChannel(m, _, C) {
      m.src = new Y.EventSource(`${_}/sub/${C}`);
      m.src.addEventListener("features", m.cb);
      m.src.onerror = () => {
        onSSEError(m, _, C);
      };
      m.src.onopen = () => {
        m.errors = 0;
      };
    }
    let ea = typeof window != "undefined" && typeof document != "undefined";
    let GrowthBook_GrowthBook = class GrowthBook_GrowthBook {
      constructor(m) {
        m = m || {};
        this._ctx = this.context = m;
        this._renderer = null;
        this._trackedExperiments = new Set();
        this._trackedFeatures = {};
        this.debug = false;
        this._subscriptions = new Set();
        this._rtQueue = [];
        this._rtTimer = 0;
        this.ready = false;
        this._assigned = new Map();
        this._forcedFeatureValues = new Map();
        this._attributeOverrides = {};
        this._activeAutoExperiments = new Map();
        if (m.features) {
          this.ready = true;
        }
        if (ea && m.enableDevMode) {
          window._growthbook = this;
          document.dispatchEvent(new Event("gbloaded"));
        }
        if (m.experiments) {
          this.ready = true;
          this._updateAllAutoExperiments();
        }
        if (m.clientKey) {
          this._refresh({}, true, false);
        }
      }
      async loadFeatures(m) {
        await this._refresh(m, true, true);
        if (m && m.autoRefresh) {
          (function (m) {
            let [_] = getKey(m);
            let C = Q.get(_) || new Set();
            C.add(m);
            Q.set(_, C);
          })(this);
        }
      }
      async refreshFeatures(m) {
        await this._refresh(m, false, true);
      }
      getApiInfo() {
        return [(this._ctx.apiHost || "https://cdn.growthbook.io").replace(/\/*$/, ""), this._ctx.clientKey || ""];
      }
      async _refresh(m, _, C) {
        m = m || {};
        if (!this._ctx.clientKey) {
          throw Error("Missing clientKey");
        }
        await refreshFeatures(this, m.timeout, m.skipCache || this._ctx.enableDevMode, _, C);
      }
      _render() {
        if (this._renderer) {
          this._renderer();
        }
      }
      setFeatures(m) {
        this._ctx.features = m;
        this.ready = true;
        this._render();
      }
      async setEncryptedFeatures(m, _, C) {
        let R = await decrypt(m, _ || this._ctx.decryptionKey, C);
        this.setFeatures(JSON.parse(R));
      }
      setExperiments(m) {
        this._ctx.experiments = m;
        this.ready = true;
        this._updateAllAutoExperiments();
      }
      async setEncryptedExperiments(m, _, C) {
        let R = await decrypt(m, _ || this._ctx.decryptionKey, C);
        this.setExperiments(JSON.parse(R));
      }
      setAttributes(m) {
        this._ctx.attributes = m;
        this._render();
        this._updateAllAutoExperiments();
      }
      setAttributeOverrides(m) {
        this._attributeOverrides = m;
        this._render();
        this._updateAllAutoExperiments();
      }
      setForcedVariations(m) {
        this._ctx.forcedVariations = m || {};
        this._render();
        this._updateAllAutoExperiments();
      }
      setForcedFeatures(m) {
        this._forcedFeatureValues = m;
        this._render();
      }
      setURL(m) {
        this._ctx.url = m;
        this._updateAllAutoExperiments(true);
      }
      getAttributes() {
        return {
          ...this._ctx.attributes,
          ...this._attributeOverrides
        };
      }
      getFeatures() {
        return this._ctx.features || {};
      }
      getExperiments() {
        return this._ctx.experiments || [];
      }
      subscribe(m) {
        this._subscriptions.add(m);
        return () => {
          this._subscriptions.delete(m);
        };
      }
      getAllResults() {
        return new Map(this._assigned);
      }
      destroy() {
        var m;
        this._subscriptions.clear();
        this._assigned.clear();
        this._trackedExperiments.clear();
        this._trackedFeatures = {};
        this._rtQueue = [];
        if (this._rtTimer) {
          clearTimeout(this._rtTimer);
        }
        m = this;
        Q.forEach(_ => _.delete(m));
        if (ea && window._growthbook === this) {
          delete window._growthbook;
        }
        this._activeAutoExperiments.forEach(m => {
          m.undo();
        });
        this._activeAutoExperiments.clear();
      }
      setRenderer(m) {
        this._renderer = m;
      }
      forceVariation(m, _) {
        this._ctx.forcedVariations = this._ctx.forcedVariations || {};
        this._ctx.forcedVariations[m] = _;
        this._render();
      }
      run(m) {
        let _ = this._run(m, null);
        this._fireSubscriptions(m, _);
        return _;
      }
      triggerExperiment(m) {
        if (!this._ctx.experiments) {
          return null;
        }
        let _ = this._ctx.experiments.find(_ => _.key === m);
        if (_ && _.manual) {
          return this._runAutoExperiment(_, true);
        } else {
          return null;
        }
      }
      _runAutoExperiment(m, _, C) {
        let R = m.key;
        let L = this._activeAutoExperiments.get(R);
        if (m.manual && !_ && !L) {
          return null;
        }
        let B = this.run(m);
        let F = JSON.stringify(B.value);
        if (!C && B.inExperiment && L && L.valueHash === F) {
          return B;
        }
        if (L) {
          this._undoActiveAutoExperiment(R);
        }
        if (B.inExperiment) {
          let _ = this._applyDOMChanges(B.value);
          if (_) {
            this._activeAutoExperiments.set(m.key, {
              undo: _,
              valueHash: F
            });
          }
        }
        return B;
      }
      _undoActiveAutoExperiment(m) {
        let _ = this._activeAutoExperiments.get(m);
        if (_) {
          _.undo();
          this._activeAutoExperiments.delete(m);
        }
      }
      _updateAllAutoExperiments(m) {
        let _ = this._ctx.experiments || [];
        let C = new Set(_.map(m => m.key));
        this._activeAutoExperiments.forEach((m, _) => {
          if (!C.has(_)) {
            m.undo();
            this._activeAutoExperiments.delete(_);
          }
        });
        _.forEach(_ => {
          this._runAutoExperiment(_, false, m);
        });
      }
      _fireSubscriptions(m, _) {
        let C = m.key;
        let R = this._assigned.get(C);
        if (!R || R.result.inExperiment !== _.inExperiment || R.result.variationId !== _.variationId) {
          this._assigned.set(C, {
            experiment: m,
            result: _
          });
          this._subscriptions.forEach(C => {
            try {
              C(m, _);
            } catch (m) {
              console.error(m);
            }
          });
        }
      }
      _trackFeatureUsage(m, _) {
        if (_.source === "override") {
          return;
        }
        let C = JSON.stringify(_.value);
        if (this._trackedFeatures[m] !== C) {
          this._trackedFeatures[m] = C;
          if (this._ctx.onFeatureUsage) {
            try {
              this._ctx.onFeatureUsage(m, _);
            } catch (m) {}
          }
          if (ea && window.fetch) {
            this._rtQueue.push({
              key: m,
              on: _.on
            });
            this._rtTimer ||= window.setTimeout(() => {
              this._rtTimer = 0;
              let m = [...this._rtQueue];
              this._rtQueue = [];
              if (this._ctx.realtimeKey) {
                window.fetch(`https://rt.growthbook.io/?key=${this._ctx.realtimeKey}&events=${encodeURIComponent(JSON.stringify(m))}`, {
                  cache: "no-cache",
                  mode: "no-cors"
                }).catch(() => {});
              }
            }, this._ctx.realtimeInterval || 2000);
          }
        }
      }
      _getFeatureResult(m, _, C, R, L, B) {
        let F = {
          value: _,
          on: !!_,
          off: !_,
          source: C,
          ruleId: R || ""
        };
        if (L) {
          F.experiment = L;
        }
        if (B) {
          F.experimentResult = B;
        }
        this._trackFeatureUsage(m, F);
        return F;
      }
      isOn(m) {
        return this.evalFeature(m).on;
      }
      isOff(m) {
        return this.evalFeature(m).off;
      }
      getFeatureValue(m, _) {
        let C = this.evalFeature(m).value;
        if (C === null) {
          return _;
        } else {
          return C;
        }
      }
      feature(m) {
        return this.evalFeature(m);
      }
      evalFeature(m) {
        if (this._forcedFeatureValues.has(m)) {
          return this._getFeatureResult(m, this._forcedFeatureValues.get(m), "override");
        }
        if (!this._ctx.features || !this._ctx.features[m]) {
          return this._getFeatureResult(m, null, "unknownFeature");
        }
        let _ = this._ctx.features[m];
        if (_.rules) {
          for (let C of _.rules) {
            if (C.condition && !this._conditionPasses(C.condition) || C.filters && this._isFilteredOut(C.filters)) {
              continue;
            }
            if ("force" in C) {
              if (!this._isIncludedInRollout(C.seed || m, C.hashAttribute, C.range, C.coverage, C.hashVersion)) {
                continue;
              }
              if (C.tracks) {
                C.tracks.forEach(m => {
                  this._track(m.experiment, m.result);
                });
              }
              return this._getFeatureResult(m, C.force, "force", C.id);
            }
            if (!C.variations) {
              continue;
            }
            let _ = {
              variations: C.variations,
              key: C.key || m
            };
            if ("coverage" in C) {
              _.coverage = C.coverage;
            }
            if (C.weights) {
              _.weights = C.weights;
            }
            if (C.hashAttribute) {
              _.hashAttribute = C.hashAttribute;
            }
            if (C.namespace) {
              _.namespace = C.namespace;
            }
            if (C.meta) {
              _.meta = C.meta;
            }
            if (C.ranges) {
              _.ranges = C.ranges;
            }
            if (C.name) {
              _.name = C.name;
            }
            if (C.phase) {
              _.phase = C.phase;
            }
            if (C.seed) {
              _.seed = C.seed;
            }
            if (C.hashVersion) {
              _.hashVersion = C.hashVersion;
            }
            if (C.filters) {
              _.filters = C.filters;
            }
            let R = this._run(_, m);
            this._fireSubscriptions(_, R);
            if (R.inExperiment && !R.passthrough) {
              return this._getFeatureResult(m, R.value, "experiment", C.id, _, R);
            }
          }
        }
        return this._getFeatureResult(m, _.defaultValue === undefined ? null : _.defaultValue, "defaultValue");
      }
      _isIncludedInRollout(m, _, C, R, L) {
        if (!C && R === undefined) {
          return true;
        }
        let {
          hashValue: B
        } = this._getHashAttribute(_);
        if (!B) {
          return false;
        }
        let F = hash(m, B, L || 1);
        return F !== null && (C ? inRange(F, C) : R === undefined || F <= R);
      }
      _conditionPasses(m) {
        return evalCondition(this.getAttributes(), m);
      }
      _isFilteredOut(m) {
        return m.some(m => {
          let {
            hashValue: _
          } = this._getHashAttribute(m.attribute);
          if (!_) {
            return true;
          }
          let C = hash(m.seed, _, m.hashVersion || 2);
          return C === null || !m.ranges.some(m => inRange(C, m));
        });
      }
      _run(m, _) {
        let C = m.key;
        let R = m.variations.length;
        if (R < 2 || this._ctx.enabled === false) {
          return this._getResult(m, -1, false, _);
        }
        m = this._mergeOverrides(m);
        let L = function (m, _, C) {
          if (!_) {
            return null;
          }
          let R = _.split("?")[1];
          if (!R) {
            return null;
          }
          let L = R.replace(/#.*/, "").split("&").map(m => m.split("=", 2)).filter(_ => {
            let [C] = _;
            return C === m;
          }).map(m => {
            let [, _] = m;
            return parseInt(_);
          });
          if (L.length > 0 && L[0] >= 0 && L[0] < C) {
            return L[0];
          } else {
            return null;
          }
        }(C, this._getContextUrl(), R);
        if (L !== null) {
          return this._getResult(m, L, false, _);
        }
        if (this._ctx.forcedVariations && C in this._ctx.forcedVariations) {
          let R = this._ctx.forcedVariations[C];
          return this._getResult(m, R, false, _);
        }
        if (m.status === "draft" || m.active === false) {
          return this._getResult(m, -1, false, _);
        }
        let {
          hashValue: B
        } = this._getHashAttribute(m.hashAttribute);
        if (!B) {
          return this._getResult(m, -1, false, _);
        }
        if (m.filters) {
          if (this._isFilteredOut(m.filters)) {
            return this._getResult(m, -1, false, _);
          }
        } else if (m.namespace && !function (m, _) {
          let C = hash("__" + _[0], m, 1);
          return C !== null && C >= _[1] && C < _[2];
        }(B, m.namespace)) {
          return this._getResult(m, -1, false, _);
        }
        if (m.include && !function (m) {
          try {
            return m();
          } catch (m) {
            console.error(m);
            return false;
          }
        }(m.include) || m.condition && !this._conditionPasses(m.condition) || m.groups && !this._hasGroupOverlap(m.groups) || m.url && !this._urlIsValid(m.url) || m.urlPatterns && !function (m, _) {
          if (!_.length) {
            return false;
          }
          let C = false;
          let R = false;
          for (let L = 0; L < _.length; L++) {
            let B = function (m, _, C) {
              try {
                let R = new URL(m, "https://_");
                if (_ === "regex") {
                  let m = getUrlRegExp(C);
                  if (!m) {
                    return false;
                  }
                  return m.test(R.href) || m.test(R.href.substring(R.origin.length));
                }
                if (_ === "simple") {
                  return function (m, _) {
                    try {
                      let C = new URL(_.replace(/^([^:/?]*)\./i, "https://$1.").replace(/\*/g, "_____"), "https://_____");
                      let R = [[m.host, C.host, false], [m.pathname, C.pathname, true]];
                      if (C.hash) {
                        R.push([m.hash, C.hash, false]);
                      }
                      C.searchParams.forEach((_, C) => {
                        R.push([m.searchParams.get(C) || "", _, false]);
                      });
                      return !R.some(m => !function (m, _, C) {
                        try {
                          let R = _.replace(/[*.+?^${}()|[\]\\]/g, "\\$&").replace(/_____/g, ".*");
                          if (C) {
                            R = "\\/?" + R.replace(/(^\/|\/$)/g, "") + "\\/?";
                          }
                          let L = RegExp("^" + R + "$", "i");
                          return L.test(m);
                        } catch (m) {
                          return false;
                        }
                      }(m[0], m[1], m[2]));
                    } catch (m) {
                      return false;
                    }
                  }(R, C);
                }
                return false;
              } catch (m) {
                return false;
              }
            }(m, _[L].type, _[L].pattern);
            if (_[L].include === false) {
              if (B) {
                return false;
              }
            } else {
              C = true;
              if (B) {
                R = true;
              }
            }
          }
          return R || !C;
        }(this._getContextUrl(), m.urlPatterns)) {
          return this._getResult(m, -1, false, _);
        }
        let F = hash(m.seed || C, B, m.hashVersion || 1);
        if (F === null) {
          return this._getResult(m, -1, false, _);
        }
        let U = m.ranges || function (m, _, C) {
          if ((_ = _ === undefined ? 1 : _) < 0) {
            _ = 0;
          } else if (_ > 1) {
            _ = 1;
          }
          let R = m <= 0 ? [] : Array(m).fill(1 / m);
          if ((C = C || R).length !== m) {
            C = R;
          }
          let L = C.reduce((m, _) => _ + m, 0);
          if (L < 0.99 || L > 1.01) {
            C = R;
          }
          let B = 0;
          return C.map(m => {
            let C = B;
            B += m;
            return [C, C + _ * m];
          });
        }(R, m.coverage === undefined ? 1 : m.coverage, m.weights);
        let H = function (m, _) {
          for (let C = 0; C < _.length; C++) {
            if (inRange(m, _[C])) {
              return C;
            }
          }
          return -1;
        }(F, U);
        if (H < 0) {
          return this._getResult(m, -1, false, _);
        }
        if ("force" in m) {
          return this._getResult(m, m.force === undefined ? -1 : m.force, false, _);
        }
        if (this._ctx.qaMode || m.status === "stopped") {
          return this._getResult(m, -1, false, _);
        }
        let q = this._getResult(m, H, true, _, F);
        this._track(m, q);
        return q;
      }
      log(m, _) {
        if (this.debug) {
          if (this._ctx.log) {
            this._ctx.log(m, _);
          } else {
            console.log(m, _);
          }
        }
      }
      _track(m, _) {
        if (!this._ctx.trackingCallback) {
          return;
        }
        let C = m.key;
        let R = _.hashAttribute + _.hashValue + C + _.variationId;
        if (!this._trackedExperiments.has(R)) {
          this._trackedExperiments.add(R);
          try {
            this._ctx.trackingCallback(m, _);
          } catch (m) {
            console.error(m);
          }
        }
      }
      _mergeOverrides(m) {
        let _ = m.key;
        let C = this._ctx.overrides;
        if (C && C[_] && typeof (m = Object.assign({}, m, C[_])).url == "string") {
          m.url = getUrlRegExp(m.url);
        }
        return m;
      }
      _getHashAttribute(m) {
        let _ = m || "id";
        let C = "";
        if (this._attributeOverrides[_]) {
          C = this._attributeOverrides[_];
        } else if (this._ctx.attributes) {
          C = this._ctx.attributes[_] || "";
        } else if (this._ctx.user) {
          C = this._ctx.user[_] || "";
        }
        return {
          hashAttribute: _,
          hashValue: C
        };
      }
      _getResult(m, _, C, R, L) {
        let B = true;
        if (_ < 0 || _ >= m.variations.length) {
          _ = 0;
          B = false;
        }
        let {
          hashAttribute: F,
          hashValue: U
        } = this._getHashAttribute(m.hashAttribute);
        let H = m.meta ? m.meta[_] : {};
        let q = {
          key: H.key || "" + _,
          featureId: R,
          inExperiment: B,
          hashUsed: C,
          variationId: _,
          value: m.variations[_],
          hashAttribute: F,
          hashValue: U
        };
        if (H.name) {
          q.name = H.name;
        }
        if (L !== undefined) {
          q.bucket = L;
        }
        if (H.passthrough) {
          q.passthrough = H.passthrough;
        }
        return q;
      }
      _getContextUrl() {
        return this._ctx.url || (ea ? window.location.href : "");
      }
      _urlIsValid(m) {
        let _ = this._getContextUrl();
        if (!_) {
          return false;
        }
        let C = _.replace(/^https?:\/\//, "").replace(/^[^/]*\//, "/");
        return !!m.test(_) || !!m.test(C);
      }
      _hasGroupOverlap(m) {
        let _ = this._ctx.groups || {};
        for (let C = 0; C < m.length; C++) {
          if (_[m[C]]) {
            return true;
          }
        }
        return false;
      }
      _applyDOMChanges(m) {
        if (!ea) {
          return;
        }
        let _ = [];
        if (m.css) {
          let C = document.createElement("style");
          C.innerHTML = m.css;
          document.head.appendChild(C);
          _.push(() => C.remove());
        }
        if (m.js) {
          let C = document.createElement("script");
          C.innerHTML = m.js;
          document.body.appendChild(C);
          _.push(() => C.remove());
        }
        if (m.domMutations) {
          m.domMutations.forEach(m => {
            _.push(V.declarative(m).revert);
          });
        }
        return () => {
          _.forEach(m => m());
        };
      }
    };
    var es = C(67294);
    let ec = es.createContext({});
    function useFeatureIsOn(m) {
      let _ = function () {
        let {
          growthbook: m
        } = es.useContext(ec);
        return m;
      }();
      return !!_ && _.isOn(m);
    }
    let GrowthBookProvider = ({
      children: m,
      growthbook: _
    }) => {
      let [C, R] = es.useState(0);
      es.useEffect(() => {
        if (_ && _.setRenderer) {
          _.setRenderer(() => {
            R(m => m + 1);
          });
          return () => {
            _.setRenderer(() => {});
          };
        }
      }, [_]);
      return es.createElement(ec.Provider, {
        value: {
          growthbook: _
        }
      }, m);
    };
  },
  27243: function (m, _) {
    "use strict";

    let r = () => typeof window != "undefined";
    let t = () => !!r() && !!window.hj;
    let e = (m, ..._) => {
      if (r() && window.hj) {
        return window.hj(m, ..._);
      }
      throw Error("Hotjar is not available, make sure init has been called.");
    };
    let n = (m, _, C) => {
      if (!((m, _, C) => {
        try {
          let R = document.getElementById(_) || document.createElement("script");
          R.id = _;
          R.nonce = C;
          R.innerText = m;
          R.crossOrigin = "anonymous";
          document.head.appendChild(R);
          return true;
        } catch (m) {
          return false;
        }
      })(`(function(h,o,t,j,a,r){h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};h._hjSettings={hjid:${m},hjsv:${_},hjdebug:${(C == null ? undefined : C.debug) || false}};a=o.getElementsByTagName('head')[0];r=o.createElement('script');r.async=1;r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;a.appendChild(r);})(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');`, "hotjar-init-script", C == null ? undefined : C.nonce) || !t()) {
        throw Error("Failed to initialize Hotjar tracking script.");
      }
    };
    _.Z = {
      init: (m, _, C) => {
        try {
          n(m, _, C);
          return true;
        } catch (m) {
          console.error("Error:", m);
          return false;
        }
      },
      event: m => {
        try {
          e("event", m);
          return true;
        } catch (m) {
          console.error("Error:", m);
          return false;
        }
      },
      identify: (m, _) => {
        try {
          e("identify", m, _);
          return true;
        } catch (m) {
          console.error("Error:", m);
          return false;
        }
      },
      stateChange: m => {
        try {
          e("stateChange", m);
          return true;
        } catch (m) {
          console.error("Error:", m);
          return false;
        }
      },
      isReady: t
    };
  },
  9669: function (m, _, C) {
    m.exports = C(51609);
  },
  55448: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = C(36026);
    var B = C(4372);
    var F = C(15327);
    var U = C(94097);
    var H = C(16373);
    var q = C(67985);
    var V = C(77874);
    var X = C(82648);
    var K = C(60644);
    var Y = C(90205);
    m.exports = function (m) {
      return new Promise(function (_, C) {
        var Q;
        var et = m.data;
        var er = m.headers;
        var en = m.responseType;
        function done() {
          if (m.cancelToken) {
            m.cancelToken.unsubscribe(Q);
          }
          if (m.signal) {
            m.signal.removeEventListener("abort", Q);
          }
        }
        if (R.isFormData(et) && R.isStandardBrowserEnv()) {
          delete er["Content-Type"];
        }
        var ei = new XMLHttpRequest();
        if (m.auth) {
          var eo = m.auth.username || "";
          var ea = m.auth.password ? unescape(encodeURIComponent(m.auth.password)) : "";
          er.Authorization = "Basic " + btoa(eo + ":" + ea);
        }
        var es = U(m.baseURL, m.url);
        function onloadend() {
          if (ei) {
            var R = "getAllResponseHeaders" in ei ? H(ei.getAllResponseHeaders()) : null;
            L(function (m) {
              _(m);
              done();
            }, function (m) {
              C(m);
              done();
            }, {
              data: en && en !== "text" && en !== "json" ? ei.response : ei.responseText,
              status: ei.status,
              statusText: ei.statusText,
              headers: R,
              config: m,
              request: ei
            });
            ei = null;
          }
        }
        ei.open(m.method.toUpperCase(), F(es, m.params, m.paramsSerializer), true);
        ei.timeout = m.timeout;
        if ("onloadend" in ei) {
          ei.onloadend = onloadend;
        } else {
          ei.onreadystatechange = function () {
            if (ei && ei.readyState === 4 && (ei.status !== 0 || ei.responseURL && ei.responseURL.indexOf("file:") === 0)) {
              setTimeout(onloadend);
            }
          };
        }
        ei.onabort = function () {
          if (ei) {
            C(new X("Request aborted", X.ECONNABORTED, m, ei));
            ei = null;
          }
        };
        ei.onerror = function () {
          C(new X("Network Error", X.ERR_NETWORK, m, ei, ei));
          ei = null;
        };
        ei.ontimeout = function () {
          var _ = m.timeout ? "timeout of " + m.timeout + "ms exceeded" : "timeout exceeded";
          var R = m.transitional || V;
          if (m.timeoutErrorMessage) {
            _ = m.timeoutErrorMessage;
          }
          C(new X(_, R.clarifyTimeoutError ? X.ETIMEDOUT : X.ECONNABORTED, m, ei));
          ei = null;
        };
        if (R.isStandardBrowserEnv()) {
          var ec = (m.withCredentials || q(es)) && m.xsrfCookieName ? B.read(m.xsrfCookieName) : undefined;
          if (ec) {
            er[m.xsrfHeaderName] = ec;
          }
        }
        if ("setRequestHeader" in ei) {
          R.forEach(er, function (m, _) {
            if (et === undefined && _.toLowerCase() === "content-type") {
              delete er[_];
            } else {
              ei.setRequestHeader(_, m);
            }
          });
        }
        if (!R.isUndefined(m.withCredentials)) {
          ei.withCredentials = !!m.withCredentials;
        }
        if (en && en !== "json") {
          ei.responseType = m.responseType;
        }
        if (typeof m.onDownloadProgress == "function") {
          ei.addEventListener("progress", m.onDownloadProgress);
        }
        if (typeof m.onUploadProgress == "function" && ei.upload) {
          ei.upload.addEventListener("progress", m.onUploadProgress);
        }
        if (m.cancelToken || m.signal) {
          Q = function (m) {
            if (ei) {
              C(!m || m && m.type ? new K() : m);
              ei.abort();
              ei = null;
            }
          };
          if (m.cancelToken) {
            m.cancelToken.subscribe(Q);
          }
          if (m.signal) {
            if (m.signal.aborted) {
              Q();
            } else {
              m.signal.addEventListener("abort", Q);
            }
          }
        }
        et ||= null;
        var el = Y(es);
        if (el && ["http", "https", "file"].indexOf(el) === -1) {
          C(new X("Unsupported protocol " + el + ":", X.ERR_BAD_REQUEST, m));
          return;
        }
        ei.send(et);
      });
    };
  },
  51609: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = C(91849);
    var B = C(30321);
    var F = C(47185);
    var U = function createInstance(m) {
      var _ = new B(m);
      var C = L(B.prototype.request, _);
      R.extend(C, B.prototype, _);
      R.extend(C, _);
      C.create = function (_) {
        return createInstance(F(m, _));
      };
      return C;
    }(C(45546));
    U.Axios = B;
    U.CanceledError = C(60644);
    U.CancelToken = C(14972);
    U.isCancel = C(26502);
    U.VERSION = C(97288).version;
    U.toFormData = C(47675);
    U.AxiosError = C(82648);
    U.Cancel = U.CanceledError;
    U.all = function (m) {
      return Promise.all(m);
    };
    U.spread = C(8713);
    U.isAxiosError = C(16268);
    m.exports = U;
    m.exports.default = U;
  },
  14972: function (m, _, C) {
    "use strict";

    var R = C(60644);
    function CancelToken(m) {
      if (typeof m != "function") {
        throw TypeError("executor must be a function.");
      }
      this.promise = new Promise(function (m) {
        _ = m;
      });
      var _;
      var C = this;
      this.promise.then(function (m) {
        if (C._listeners) {
          var _;
          var R = C._listeners.length;
          for (_ = 0; _ < R; _++) {
            C._listeners[_](m);
          }
          C._listeners = null;
        }
      });
      this.promise.then = function (m) {
        var _;
        var R = new Promise(function (m) {
          C.subscribe(m);
          _ = m;
        }).then(m);
        R.cancel = function () {
          C.unsubscribe(_);
        };
        return R;
      };
      m(function (m) {
        if (!C.reason) {
          C.reason = new R(m);
          _(C.reason);
        }
      });
    }
    CancelToken.prototype.throwIfRequested = function () {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function (m) {
      if (this.reason) {
        m(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(m);
      } else {
        this._listeners = [m];
      }
    };
    CancelToken.prototype.unsubscribe = function (m) {
      if (this._listeners) {
        var _ = this._listeners.indexOf(m);
        if (_ !== -1) {
          this._listeners.splice(_, 1);
        }
      }
    };
    CancelToken.source = function () {
      var m;
      return {
        token: new CancelToken(function (_) {
          m = _;
        }),
        cancel: m
      };
    };
    m.exports = CancelToken;
  },
  60644: function (m, _, C) {
    "use strict";

    var R = C(82648);
    function CanceledError(m) {
      R.call(this, m == null ? "canceled" : m, R.ERR_CANCELED);
      this.name = "CanceledError";
    }
    C(64867).inherits(CanceledError, R, {
      __CANCEL__: true
    });
    m.exports = CanceledError;
  },
  26502: function (m) {
    "use strict";

    m.exports = function (m) {
      return !!m && !!m.__CANCEL__;
    };
  },
  30321: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = C(15327);
    var B = C(80782);
    var F = C(13572);
    var U = C(47185);
    var H = C(94097);
    var q = C(54875);
    var V = q.validators;
    function Axios(m) {
      this.defaults = m;
      this.interceptors = {
        request: new B(),
        response: new B()
      };
    }
    Axios.prototype.request = function (m, _) {
      if (typeof m == "string") {
        (_ = _ || {}).url = m;
      } else {
        _ = m || {};
      }
      if ((_ = U(this.defaults, _)).method) {
        _.method = _.method.toLowerCase();
      } else if (this.defaults.method) {
        _.method = this.defaults.method.toLowerCase();
      } else {
        _.method = "get";
      }
      var C;
      var R = _.transitional;
      if (R !== undefined) {
        q.assertOptions(R, {
          silentJSONParsing: V.transitional(V.boolean),
          forcedJSONParsing: V.transitional(V.boolean),
          clarifyTimeoutError: V.transitional(V.boolean)
        }, false);
      }
      var L = [];
      var B = true;
      this.interceptors.request.forEach(function (m) {
        if (typeof m.runWhen != "function" || m.runWhen(_) !== false) {
          B = B && m.synchronous;
          L.unshift(m.fulfilled, m.rejected);
        }
      });
      var H = [];
      this.interceptors.response.forEach(function (m) {
        H.push(m.fulfilled, m.rejected);
      });
      if (!B) {
        var X = [F, undefined];
        Array.prototype.unshift.apply(X, L);
        X = X.concat(H);
        C = Promise.resolve(_);
        while (X.length) {
          C = C.then(X.shift(), X.shift());
        }
        return C;
      }
      var K = _;
      for (; L.length;) {
        var Y = L.shift();
        var Q = L.shift();
        try {
          K = Y(K);
        } catch (m) {
          Q(m);
          break;
        }
      }
      try {
        C = F(K);
      } catch (m) {
        return Promise.reject(m);
      }
      while (H.length) {
        C = C.then(H.shift(), H.shift());
      }
      return C;
    };
    Axios.prototype.getUri = function (m) {
      return L(H((m = U(this.defaults, m)).baseURL, m.url), m.params, m.paramsSerializer);
    };
    R.forEach(["delete", "get", "head", "options"], function (m) {
      Axios.prototype[m] = function (_, C) {
        return this.request(U(C || {}, {
          method: m,
          url: _,
          data: (C || {}).data
        }));
      };
    });
    R.forEach(["post", "put", "patch"], function (m) {
      function generateHTTPMethod(_) {
        return function (C, R, L) {
          return this.request(U(L || {}, {
            method: m,
            headers: _ ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: C,
            data: R
          }));
        };
      }
      Axios.prototype[m] = generateHTTPMethod();
      Axios.prototype[m + "Form"] = generateHTTPMethod(true);
    });
    m.exports = Axios;
  },
  82648: function (m, _, C) {
    "use strict";

    var R = C(64867);
    function AxiosError(m, _, C, R, L) {
      Error.call(this);
      this.message = m;
      this.name = "AxiosError";
      if (_) {
        this.code = _;
      }
      if (C) {
        this.config = C;
      }
      if (R) {
        this.request = R;
      }
      if (L) {
        this.response = L;
      }
    }
    R.inherits(AxiosError, Error, {
      toJSON: function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var L = AxiosError.prototype;
    var B = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function (m) {
      B[m] = {
        value: m
      };
    });
    Object.defineProperties(AxiosError, B);
    Object.defineProperty(L, "isAxiosError", {
      value: true
    });
    AxiosError.from = function (m, _, C, B, F, U) {
      var H = Object.create(L);
      R.toFlatObject(m, H, function (m) {
        return m !== Error.prototype;
      });
      AxiosError.call(H, m.message, _, C, B, F);
      H.name = m.name;
      if (U) {
        Object.assign(H, U);
      }
      return H;
    };
    m.exports = AxiosError;
  },
  80782: function (m, _, C) {
    "use strict";

    var R = C(64867);
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function (m, _, C) {
      this.handlers.push({
        fulfilled: m,
        rejected: _,
        synchronous: !!C && C.synchronous,
        runWhen: C ? C.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function (m) {
      this.handlers[m] &&= null;
    };
    InterceptorManager.prototype.forEach = function (m) {
      R.forEach(this.handlers, function (_) {
        if (_ !== null) {
          m(_);
        }
      });
    };
    m.exports = InterceptorManager;
  },
  94097: function (m, _, C) {
    "use strict";

    var R = C(91793);
    var L = C(7303);
    m.exports = function (m, _) {
      if (m && !R(_)) {
        return L(m, _);
      } else {
        return _;
      }
    };
  },
  13572: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = C(18527);
    var B = C(26502);
    var F = C(45546);
    var U = C(60644);
    function throwIfCancellationRequested(m) {
      if (m.cancelToken) {
        m.cancelToken.throwIfRequested();
      }
      if (m.signal && m.signal.aborted) {
        throw new U();
      }
    }
    m.exports = function (m) {
      throwIfCancellationRequested(m);
      m.headers = m.headers || {};
      m.data = L.call(m, m.data, m.headers, m.transformRequest);
      m.headers = R.merge(m.headers.common || {}, m.headers[m.method] || {}, m.headers);
      R.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (_) {
        delete m.headers[_];
      });
      return (m.adapter || F.adapter)(m).then(function (_) {
        throwIfCancellationRequested(m);
        _.data = L.call(m, _.data, _.headers, m.transformResponse);
        return _;
      }, function (_) {
        if (!B(_)) {
          throwIfCancellationRequested(m);
          if (_ && _.response) {
            _.response.data = L.call(m, _.response.data, _.response.headers, m.transformResponse);
          }
        }
        return Promise.reject(_);
      });
    };
  },
  47185: function (m, _, C) {
    "use strict";

    var R = C(64867);
    m.exports = function (m, _) {
      _ = _ || {};
      var C = {};
      function getMergedValue(m, _) {
        if (R.isPlainObject(m) && R.isPlainObject(_)) {
          return R.merge(m, _);
        } else if (R.isPlainObject(_)) {
          return R.merge({}, _);
        } else if (R.isArray(_)) {
          return _.slice();
        } else {
          return _;
        }
      }
      function mergeDeepProperties(C) {
        if (R.isUndefined(_[C])) {
          if (R.isUndefined(m[C])) {
            return undefined;
          } else {
            return getMergedValue(undefined, m[C]);
          }
        } else {
          return getMergedValue(m[C], _[C]);
        }
      }
      function valueFromConfig2(m) {
        if (!R.isUndefined(_[m])) {
          return getMergedValue(undefined, _[m]);
        }
      }
      function defaultToConfig2(C) {
        if (R.isUndefined(_[C])) {
          if (R.isUndefined(m[C])) {
            return undefined;
          } else {
            return getMergedValue(undefined, m[C]);
          }
        } else {
          return getMergedValue(undefined, _[C]);
        }
      }
      function mergeDirectKeys(C) {
        if (C in _) {
          return getMergedValue(m[C], _[C]);
        } else if (C in m) {
          return getMergedValue(undefined, m[C]);
        } else {
          return undefined;
        }
      }
      var L = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys
      };
      R.forEach(Object.keys(m).concat(Object.keys(_)), function (m) {
        var _ = L[m] || mergeDeepProperties;
        var B = _(m);
        if (!R.isUndefined(B) || _ === mergeDirectKeys) {
          C[m] = B;
        }
      });
      return C;
    };
  },
  36026: function (m, _, C) {
    "use strict";

    var R = C(82648);
    m.exports = function (m, _, C) {
      var L = C.config.validateStatus;
      if (!C.status || !L || L(C.status)) {
        m(C);
      } else {
        _(new R("Request failed with status code " + C.status, [R.ERR_BAD_REQUEST, R.ERR_BAD_RESPONSE][Math.floor(C.status / 100) - 4], C.config, C.request, C));
      }
    };
  },
  18527: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = C(45546);
    m.exports = function (m, _, C) {
      var B = this || L;
      R.forEach(C, function (C) {
        m = C.call(B, m, _);
      });
      return m;
    };
  },
  45546: function (m, _, C) {
    "use strict";

    var R;
    var L = C(34155);
    var B = C(64867);
    var F = C(16016);
    var U = C(82648);
    var H = C(77874);
    var q = C(47675);
    var V = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(m, _) {
      if (!B.isUndefined(m) && B.isUndefined(m["Content-Type"])) {
        m["Content-Type"] = _;
      }
    }
    var X = {
      transitional: H,
      adapter: (typeof XMLHttpRequest != "undefined" ? R = C(55448) : L !== undefined && Object.prototype.toString.call(L) === "[object process]" && (R = C(55448)), R),
      transformRequest: [function (m, _) {
        F(_, "Accept");
        F(_, "Content-Type");
        if (B.isFormData(m) || B.isArrayBuffer(m) || B.isBuffer(m) || B.isStream(m) || B.isFile(m) || B.isBlob(m)) {
          return m;
        }
        if (B.isArrayBufferView(m)) {
          return m.buffer;
        }
        if (B.isURLSearchParams(m)) {
          setContentTypeIfUnset(_, "application/x-www-form-urlencoded;charset=utf-8");
          return m.toString();
        }
        var C;
        var R = B.isObject(m);
        var L = _ && _["Content-Type"];
        if ((C = B.isFileList(m)) || R && L === "multipart/form-data") {
          var U = this.env && this.env.FormData;
          return q(C ? {
            "files[]": m
          } : m, U && new U());
        }
        if (R || L === "application/json") {
          setContentTypeIfUnset(_, "application/json");
          return function (m, _, C) {
            if (B.isString(m)) {
              try {
                (0, JSON.parse)(m);
                return B.trim(m);
              } catch (m) {
                if (m.name !== "SyntaxError") {
                  throw m;
                }
              }
            }
            return (0, JSON.stringify)(m);
          }(m);
        } else {
          return m;
        }
      }],
      transformResponse: [function (m) {
        var _ = this.transitional || X.transitional;
        var C = _ && _.silentJSONParsing;
        var R = _ && _.forcedJSONParsing;
        var L = !C && this.responseType === "json";
        if (L || R && B.isString(m) && m.length) {
          try {
            return JSON.parse(m);
          } catch (m) {
            if (L) {
              if (m.name === "SyntaxError") {
                throw U.from(m, U.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw m;
            }
          }
        }
        return m;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: C(91623)
      },
      validateStatus: function (m) {
        return m >= 200 && m < 300;
      },
      headers: {
        common: {
          Accept: "application/json, text/plain, */*"
        }
      }
    };
    B.forEach(["delete", "get", "head"], function (m) {
      X.headers[m] = {};
    });
    B.forEach(["post", "put", "patch"], function (m) {
      X.headers[m] = B.merge(V);
    });
    m.exports = X;
  },
  77874: function (m) {
    "use strict";

    m.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  },
  97288: function (m) {
    m.exports = {
      version: "0.27.2"
    };
  },
  91849: function (m) {
    "use strict";

    m.exports = function (m, _) {
      return function () {
        for (var C = Array(arguments.length), R = 0; R < C.length; R++) {
          C[R] = arguments[R];
        }
        return m.apply(_, C);
      };
    };
  },
  15327: function (m, _, C) {
    "use strict";

    var R = C(64867);
    function encode(m) {
      return encodeURIComponent(m).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    m.exports = function (m, _, C) {
      if (!_) {
        return m;
      }
      if (C) {
        L = C(_);
      } else if (R.isURLSearchParams(_)) {
        L = _.toString();
      } else {
        var L;
        var B = [];
        R.forEach(_, function (m, _) {
          if (m != null) {
            if (R.isArray(m)) {
              _ += "[]";
            } else {
              m = [m];
            }
            R.forEach(m, function (m) {
              if (R.isDate(m)) {
                m = m.toISOString();
              } else if (R.isObject(m)) {
                m = JSON.stringify(m);
              }
              B.push(encode(_) + "=" + encode(m));
            });
          }
        });
        L = B.join("&");
      }
      if (L) {
        var F = m.indexOf("#");
        if (F !== -1) {
          m = m.slice(0, F);
        }
        m += (m.indexOf("?") === -1 ? "?" : "&") + L;
      }
      return m;
    };
  },
  7303: function (m) {
    "use strict";

    m.exports = function (m, _) {
      if (_) {
        return m.replace(/\/+$/, "") + "/" + _.replace(/^\/+/, "");
      } else {
        return m;
      }
    };
  },
  4372: function (m, _, C) {
    "use strict";

    var R = C(64867);
    m.exports = R.isStandardBrowserEnv() ? {
      write: function (m, _, C, L, B, F) {
        var U = [];
        U.push(m + "=" + encodeURIComponent(_));
        if (R.isNumber(C)) {
          U.push("expires=" + new Date(C).toGMTString());
        }
        if (R.isString(L)) {
          U.push("path=" + L);
        }
        if (R.isString(B)) {
          U.push("domain=" + B);
        }
        if (F === true) {
          U.push("secure");
        }
        document.cookie = U.join("; ");
      },
      read: function (m) {
        var _ = document.cookie.match(RegExp("(^|;\\s*)(" + m + ")=([^;]*)"));
        if (_) {
          return decodeURIComponent(_[3]);
        } else {
          return null;
        }
      },
      remove: function (m) {
        this.write(m, "", Date.now() - 86400000);
      }
    } : {
      write: function () {},
      read: function () {
        return null;
      },
      remove: function () {}
    };
  },
  91793: function (m) {
    "use strict";

    m.exports = function (m) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(m);
    };
  },
  16268: function (m, _, C) {
    "use strict";

    var R = C(64867);
    m.exports = function (m) {
      return R.isObject(m) && m.isAxiosError === true;
    };
  },
  67985: function (m, _, C) {
    "use strict";

    var R = C(64867);
    m.exports = R.isStandardBrowserEnv() ? function () {
      var m;
      var _ = /(msie|trident)/i.test(navigator.userAgent);
      var C = document.createElement("a");
      function resolveURL(m) {
        var R = m;
        if (_) {
          C.setAttribute("href", R);
          R = C.href;
        }
        C.setAttribute("href", R);
        return {
          href: C.href,
          protocol: C.protocol ? C.protocol.replace(/:$/, "") : "",
          host: C.host,
          search: C.search ? C.search.replace(/^\?/, "") : "",
          hash: C.hash ? C.hash.replace(/^#/, "") : "",
          hostname: C.hostname,
          port: C.port,
          pathname: C.pathname.charAt(0) === "/" ? C.pathname : "/" + C.pathname
        };
      }
      m = resolveURL(window.location.href);
      return function (_) {
        var C = R.isString(_) ? resolveURL(_) : _;
        return C.protocol === m.protocol && C.host === m.host;
      };
    }() : function () {
      return true;
    };
  },
  16016: function (m, _, C) {
    "use strict";

    var R = C(64867);
    m.exports = function (m, _) {
      R.forEach(m, function (C, R) {
        if (R !== _ && R.toUpperCase() === _.toUpperCase()) {
          m[_] = C;
          delete m[R];
        }
      });
    };
  },
  91623: function (m) {
    m.exports = null;
  },
  16373: function (m, _, C) {
    "use strict";

    var R = C(64867);
    var L = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    m.exports = function (m) {
      var _;
      var C;
      var B;
      var F = {};
      if (m) {
        R.forEach(m.split("\n"), function (m) {
          B = m.indexOf(":");
          _ = R.trim(m.substr(0, B)).toLowerCase();
          C = R.trim(m.substr(B + 1));
          if (_ && (!F[_] || !(L.indexOf(_) >= 0))) {
            if (_ === "set-cookie") {
              F[_] = (F[_] ? F[_] : []).concat([C]);
            } else {
              F[_] = F[_] ? F[_] + ", " + C : C;
            }
          }
        });
      }
      return F;
    };
  },
  90205: function (m) {
    "use strict";

    m.exports = function (m) {
      var _ = /^([-+\w]{1,25})(:?\/\/|:)/.exec(m);
      return _ && _[1] || "";
    };
  },
  8713: function (m) {
    "use strict";

    m.exports = function (m) {
      return function (_) {
        return m.apply(null, _);
      };
    };
  },
  47675: function (m, _, C) {
    "use strict";

    var R = C(48764).lW;
    var L = C(64867);
    m.exports = function (m, _) {
      _ = _ || new FormData();
      var C = [];
      function convertValue(m) {
        if (m === null) {
          return "";
        } else if (L.isDate(m)) {
          return m.toISOString();
        } else if (L.isArrayBuffer(m) || L.isTypedArray(m)) {
          if (typeof Blob == "function") {
            return new Blob([m]);
          } else {
            return R.from(m);
          }
        } else {
          return m;
        }
      }
      (function build(m, R) {
        if (L.isPlainObject(m) || L.isArray(m)) {
          if (C.indexOf(m) !== -1) {
            throw Error("Circular reference detected in " + R);
          }
          C.push(m);
          L.forEach(m, function (m, C) {
            if (!L.isUndefined(m)) {
              var B;
              var F = R ? R + "." + C : C;
              if (m && !R && typeof m == "object") {
                if (L.endsWith(C, "{}")) {
                  m = JSON.stringify(m);
                } else if (L.endsWith(C, "[]") && (B = L.toArray(m))) {
                  B.forEach(function (m) {
                    if (!L.isUndefined(m)) {
                      _.append(F, convertValue(m));
                    }
                  });
                  return;
                }
              }
              build(m, F);
            }
          });
          C.pop();
        } else {
          _.append(R, convertValue(m));
        }
      })(m);
      return _;
    };
  },
  54875: function (m, _, C) {
    "use strict";

    var R = C(97288).version;
    var L = C(82648);
    var B = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function (m, _) {
      B[m] = function (C) {
        return typeof C === m || "a" + (_ < 1 ? "n " : " ") + m;
      };
    });
    var F = {};
    B.transitional = function (m, _, C) {
      function formatMessage(m, _) {
        return "[Axios v" + R + "] Transitional option '" + m + "'" + _ + (C ? ". " + C : "");
      }
      return function (C, R, B) {
        if (m === false) {
          throw new L(formatMessage(R, " has been removed" + (_ ? " in " + _ : "")), L.ERR_DEPRECATED);
        }
        if (_ && !F[R]) {
          F[R] = true;
          console.warn(formatMessage(R, " has been deprecated since v" + _ + " and will be removed in the near future"));
        }
        return !m || m(C, R, B);
      };
    };
    m.exports = {
      assertOptions: function (m, _, C) {
        if (typeof m != "object") {
          throw new L("options must be an object", L.ERR_BAD_OPTION_VALUE);
        }
        var R = Object.keys(m);
        for (var B = R.length; B-- > 0;) {
          var F = R[B];
          var U = _[F];
          if (U) {
            var H = m[F];
            var q = H === undefined || U(H, F, m);
            if (q !== true) {
              throw new L("option " + F + " must be " + q, L.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (C !== true) {
            throw new L("Unknown option " + F, L.ERR_BAD_OPTION);
          }
        }
      },
      validators: B
    };
  },
  64867: function (m, _, C) {
    "use strict";

    var R;
    var L;
    var B = C(91849);
    var F = Object.prototype.toString;
    R = Object.create(null);
    function U(m) {
      var _ = F.call(m);
      return R[_] ||= _.slice(8, -1).toLowerCase();
    }
    function kindOfTest(m) {
      m = m.toLowerCase();
      return function (_) {
        return U(_) === m;
      };
    }
    function isArray(m) {
      return Array.isArray(m);
    }
    function isUndefined(m) {
      return m === undefined;
    }
    var H = kindOfTest("ArrayBuffer");
    function isObject(m) {
      return m !== null && typeof m == "object";
    }
    function isPlainObject(m) {
      if (U(m) !== "object") {
        return false;
      }
      var _ = Object.getPrototypeOf(m);
      return _ === null || _ === Object.prototype;
    }
    var q = kindOfTest("Date");
    var V = kindOfTest("File");
    var X = kindOfTest("Blob");
    var K = kindOfTest("FileList");
    function isFunction(m) {
      return F.call(m) === "[object Function]";
    }
    var Y = kindOfTest("URLSearchParams");
    function forEach(m, _) {
      if (m != null) {
        if (typeof m != "object") {
          m = [m];
        }
        if (isArray(m)) {
          for (var C = 0, R = m.length; C < R; C++) {
            _.call(null, m[C], C, m);
          }
        } else {
          for (var L in m) {
            if (Object.prototype.hasOwnProperty.call(m, L)) {
              _.call(null, m[L], L, m);
            }
          }
        }
      }
    }
    L = typeof Uint8Array != "undefined" && Object.getPrototypeOf(Uint8Array);
    function Q(m) {
      return L && m instanceof L;
    }
    m.exports = {
      isArray: isArray,
      isArrayBuffer: H,
      isBuffer: function (m) {
        return m !== null && !isUndefined(m) && m.constructor !== null && !isUndefined(m.constructor) && typeof m.constructor.isBuffer == "function" && m.constructor.isBuffer(m);
      },
      isFormData: function (m) {
        var _ = "[object FormData]";
        return m && (typeof FormData == "function" && m instanceof FormData || F.call(m) === _ || isFunction(m.toString) && m.toString() === _);
      },
      isArrayBufferView: function (m) {
        if (typeof ArrayBuffer != "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(m);
        } else {
          return m && m.buffer && H(m.buffer);
        }
      },
      isString: function (m) {
        return typeof m == "string";
      },
      isNumber: function (m) {
        return typeof m == "number";
      },
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: q,
      isFile: V,
      isBlob: X,
      isFunction: isFunction,
      isStream: function (m) {
        return isObject(m) && isFunction(m.pipe);
      },
      isURLSearchParams: Y,
      isStandardBrowserEnv: function () {
        return (typeof navigator == "undefined" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window != "undefined" && typeof document != "undefined";
      },
      forEach: forEach,
      merge: function merge() {
        var m = {};
        function assignValue(_, C) {
          if (isPlainObject(m[C]) && isPlainObject(_)) {
            m[C] = merge(m[C], _);
          } else if (isPlainObject(_)) {
            m[C] = merge({}, _);
          } else if (isArray(_)) {
            m[C] = _.slice();
          } else {
            m[C] = _;
          }
        }
        for (var _ = 0, C = arguments.length; _ < C; _++) {
          forEach(arguments[_], assignValue);
        }
        return m;
      },
      extend: function (m, _, C) {
        forEach(_, function (_, R) {
          if (C && typeof _ == "function") {
            m[R] = B(_, C);
          } else {
            m[R] = _;
          }
        });
        return m;
      },
      trim: function (m) {
        if (m.trim) {
          return m.trim();
        } else {
          return m.replace(/^\s+|\s+$/g, "");
        }
      },
      stripBOM: function (m) {
        if (m.charCodeAt(0) === 65279) {
          m = m.slice(1);
        }
        return m;
      },
      inherits: function (m, _, C, R) {
        m.prototype = Object.create(_.prototype, R);
        m.prototype.constructor = m;
        if (C) {
          Object.assign(m.prototype, C);
        }
      },
      toFlatObject: function (m, _, C) {
        var R;
        var L;
        var B;
        var F = {};
        _ = _ || {};
        do {
          for (L = (R = Object.getOwnPropertyNames(m)).length; L-- > 0;) {
            if (!F[B = R[L]]) {
              _[B] = m[B];
              F[B] = true;
            }
          }
          m = Object.getPrototypeOf(m);
        } while (m && (!C || C(m, _)) && m !== Object.prototype);
        return _;
      },
      kindOf: U,
      kindOfTest: kindOfTest,
      endsWith: function (m, _, C) {
        m = String(m);
        if (C === undefined || C > m.length) {
          C = m.length;
        }
        C -= _.length;
        var R = m.indexOf(_, C);
        return R !== -1 && R === C;
      },
      toArray: function (m) {
        if (!m) {
          return null;
        }
        var _ = m.length;
        if (isUndefined(_)) {
          return null;
        }
        var C = Array(_);
        for (; _-- > 0;) {
          C[_] = m[_];
        }
        return C;
      },
      isTypedArray: Q,
      isFileList: K
    };
  },
  79742: function (m, _) {
    "use strict";

    _.byteLength = function (m) {
      var _ = getLens(m);
      var C = _[0];
      var R = _[1];
      return (C + R) * 3 / 4 - R;
    };
    _.toByteArray = function (m) {
      var _;
      var C;
      var B = getLens(m);
      var F = B[0];
      var U = B[1];
      var H = new L((F + U) * 3 / 4 - U);
      var q = 0;
      var V = U > 0 ? F - 4 : F;
      for (C = 0; C < V; C += 4) {
        _ = R[m.charCodeAt(C)] << 18 | R[m.charCodeAt(C + 1)] << 12 | R[m.charCodeAt(C + 2)] << 6 | R[m.charCodeAt(C + 3)];
        H[q++] = _ >> 16 & 255;
        H[q++] = _ >> 8 & 255;
        H[q++] = _ & 255;
      }
      if (U === 2) {
        _ = R[m.charCodeAt(C)] << 2 | R[m.charCodeAt(C + 1)] >> 4;
        H[q++] = _ & 255;
      }
      if (U === 1) {
        _ = R[m.charCodeAt(C)] << 10 | R[m.charCodeAt(C + 1)] << 4 | R[m.charCodeAt(C + 2)] >> 2;
        H[q++] = _ >> 8 & 255;
        H[q++] = _ & 255;
      }
      return H;
    };
    _.fromByteArray = function (m) {
      var _;
      var R = m.length;
      var L = R % 3;
      var B = [];
      for (var F = 0, U = R - L; F < U; F += 16383) {
        B.push(function (m, _, R) {
          var L;
          var B = [];
          for (var F = _; F < R; F += 3) {
            B.push(C[(L = (m[F] << 16 & 16711680) + (m[F + 1] << 8 & 65280) + (m[F + 2] & 255)) >> 18 & 63] + C[L >> 12 & 63] + C[L >> 6 & 63] + C[L & 63]);
          }
          return B.join("");
        }(m, F, F + 16383 > U ? U : F + 16383));
      }
      if (L === 1) {
        B.push(C[(_ = m[R - 1]) >> 2] + C[_ << 4 & 63] + "==");
      } else if (L === 2) {
        B.push(C[(_ = (m[R - 2] << 8) + m[R - 1]) >> 10] + C[_ >> 4 & 63] + C[_ << 2 & 63] + "=");
      }
      return B.join("");
    };
    var C = [];
    var R = [];
    var L = typeof Uint8Array != "undefined" ? Uint8Array : Array;
    var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var F = 0, U = B.length; F < U; ++F) {
      C[F] = B[F];
      R[B.charCodeAt(F)] = F;
    }
    function getLens(m) {
      var _ = m.length;
      if (_ % 4 > 0) {
        throw Error("Invalid string. Length must be a multiple of 4");
      }
      var C = m.indexOf("=");
      if (C === -1) {
        C = _;
      }
      var R = C === _ ? 0 : 4 - C % 4;
      return [C, R];
    }
    R["-".charCodeAt(0)] = 62;
    R["_".charCodeAt(0)] = 63;
  },
  48764: function (m, _, C) {
    "use strict";

    /*!
    * The buffer module from node.js, for the browser.
    *
    * @author   Feross Aboukhadijeh <http://feross.org>
    * @license  MIT
    */
    var R = C(79742);
    var L = C(80645);
    var B = C(87300);
    function kMaxLength() {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return 2147483647;
      } else {
        return 1073741823;
      }
    }
    function createBuffer(m, _) {
      if (kMaxLength() < _) {
        throw RangeError("Invalid typed array length");
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        (m = new Uint8Array(_)).__proto__ = Buffer.prototype;
      } else {
        if (m === null) {
          m = new Buffer(_);
        }
        m.length = _;
      }
      return m;
    }
    function Buffer(m, _, C) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(m, _, C);
      }
      if (typeof m == "number") {
        if (typeof _ == "string") {
          throw Error("If encoding is specified then the first argument must be a string");
        }
        return allocUnsafe(this, m);
      }
      return from(this, m, _, C);
    }
    function from(m, _, C, R) {
      if (typeof _ == "number") {
        throw TypeError("\"value\" argument must not be a number");
      }
      if (typeof ArrayBuffer != "undefined" && _ instanceof ArrayBuffer) {
        return function (m, _, C, R) {
          _.byteLength;
          if (C < 0 || _.byteLength < C) {
            throw RangeError("'offset' is out of bounds");
          }
          if (_.byteLength < C + (R || 0)) {
            throw RangeError("'length' is out of bounds");
          }
          _ = C === undefined && R === undefined ? new Uint8Array(_) : R === undefined ? new Uint8Array(_, C) : new Uint8Array(_, C, R);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            (m = _).__proto__ = Buffer.prototype;
          } else {
            m = fromArrayLike(m, _);
          }
          return m;
        }(m, _, C, R);
      } else if (typeof _ == "string") {
        return function (m, _, C) {
          if (typeof C != "string" || C === "") {
            C = "utf8";
          }
          if (!Buffer.isEncoding(C)) {
            throw TypeError("\"encoding\" must be a valid string encoding");
          }
          var R = byteLength(_, C) | 0;
          var L = (m = createBuffer(m, R)).write(_, C);
          if (L !== R) {
            m = m.slice(0, L);
          }
          return m;
        }(m, _, C);
      } else {
        return function (m, _) {
          if (Buffer.isBuffer(_)) {
            var C;
            var R = checked(_.length) | 0;
            if ((m = createBuffer(m, R)).length !== 0) {
              _.copy(m, 0, 0, R);
            }
            return m;
          }
          if (_) {
            if (typeof ArrayBuffer != "undefined" && _.buffer instanceof ArrayBuffer || "length" in _) {
              if (typeof _.length != "number" || (C = _.length) != C) {
                return createBuffer(m, 0);
              } else {
                return fromArrayLike(m, _);
              }
            }
            if (_.type === "Buffer" && B(_.data)) {
              return fromArrayLike(m, _.data);
            }
          }
          throw TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(m, _);
      }
    }
    function assertSize(m) {
      if (typeof m != "number") {
        throw TypeError("\"size\" argument must be a number");
      }
      if (m < 0) {
        throw RangeError("\"size\" argument must not be negative");
      }
    }
    function allocUnsafe(m, _) {
      assertSize(_);
      m = createBuffer(m, _ < 0 ? 0 : checked(_) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var C = 0; C < _; ++C) {
          m[C] = 0;
        }
      }
      return m;
    }
    function fromArrayLike(m, _) {
      var C = _.length < 0 ? 0 : checked(_.length) | 0;
      m = createBuffer(m, C);
      for (var R = 0; R < C; R += 1) {
        m[R] = _[R] & 255;
      }
      return m;
    }
    function checked(m) {
      if (m >= kMaxLength()) {
        throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
      }
      return m | 0;
    }
    function byteLength(m, _) {
      if (Buffer.isBuffer(m)) {
        return m.length;
      }
      if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(m) || m instanceof ArrayBuffer)) {
        return m.byteLength;
      }
      if (typeof m != "string") {
        m = "" + m;
      }
      var C = m.length;
      if (C === 0) {
        return 0;
      }
      var R = false;
      for (;;) {
        switch (_) {
          case "ascii":
          case "latin1":
          case "binary":
            return C;
          case "utf8":
          case "utf-8":
          case undefined:
            return utf8ToBytes(m).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return C * 2;
          case "hex":
            return C >>> 1;
          case "base64":
            return base64ToBytes(m).length;
          default:
            if (R) {
              return utf8ToBytes(m).length;
            }
            _ = ("" + _).toLowerCase();
            R = true;
        }
      }
    }
    function slowToString(m, _, C) {
      var L;
      var B;
      var F = false;
      if (_ === undefined || _ < 0) {
        _ = 0;
      }
      if (_ > this.length || ((C === undefined || C > this.length) && (C = this.length), C <= 0 || (C >>>= 0) <= (_ >>>= 0))) {
        return "";
      }
      for (m ||= "utf8";;) {
        switch (m) {
          case "hex":
            return function (m, _, C) {
              var R;
              var L = m.length;
              if (!_ || _ < 0) {
                _ = 0;
              }
              if (!C || C < 0 || C > L) {
                C = L;
              }
              var B = "";
              for (var F = _; F < C; ++F) {
                B += (R = m[F]) < 16 ? "0" + R.toString(16) : R.toString(16);
              }
              return B;
            }(this, _, C);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, _, C);
          case "ascii":
            return function (m, _, C) {
              var R = "";
              C = Math.min(m.length, C);
              for (var L = _; L < C; ++L) {
                R += String.fromCharCode(m[L] & 127);
              }
              return R;
            }(this, _, C);
          case "latin1":
          case "binary":
            return function (m, _, C) {
              var R = "";
              C = Math.min(m.length, C);
              for (var L = _; L < C; ++L) {
                R += String.fromCharCode(m[L]);
              }
              return R;
            }(this, _, C);
          case "base64":
            L = _;
            B = C;
            if (L === 0 && B === this.length) {
              return R.fromByteArray(this);
            } else {
              return R.fromByteArray(this.slice(L, B));
            }
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return function (m, _, C) {
              for (var R = m.slice(_, C), L = "", B = 0; B < R.length; B += 2) {
                L += String.fromCharCode(R[B] + R[B + 1] * 256);
              }
              return L;
            }(this, _, C);
          default:
            if (F) {
              throw TypeError("Unknown encoding: " + m);
            }
            m = (m + "").toLowerCase();
            F = true;
        }
      }
    }
    function swap(m, _, C) {
      var R = m[_];
      m[_] = m[C];
      m[C] = R;
    }
    function bidirectionalIndexOf(m, _, C, R, L) {
      if (m.length === 0) {
        return -1;
      }
      if (typeof C == "string") {
        R = C;
        C = 0;
      } else if (C > 2147483647) {
        C = 2147483647;
      } else if (C < -2147483648) {
        C = -2147483648;
      }
      if (isNaN(C = +C)) {
        C = L ? 0 : m.length - 1;
      }
      if (C < 0) {
        C = m.length + C;
      }
      if (C >= m.length) {
        if (L) {
          return -1;
        }
        C = m.length - 1;
      } else if (C < 0) {
        if (!L) {
          return -1;
        }
        C = 0;
      }
      if (typeof _ == "string") {
        _ = Buffer.from(_, R);
      }
      if (Buffer.isBuffer(_)) {
        if (_.length === 0) {
          return -1;
        } else {
          return arrayIndexOf(m, _, C, R, L);
        }
      }
      if (typeof _ == "number") {
        _ &= 255;
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function") {
          if (L) {
            return Uint8Array.prototype.indexOf.call(m, _, C);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(m, _, C);
          }
        } else {
          return arrayIndexOf(m, [_], C, R, L);
        }
      }
      throw TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(m, _, C, R, L) {
      var B;
      var F = 1;
      var U = m.length;
      var H = _.length;
      if (R !== undefined && ((R = String(R).toLowerCase()) === "ucs2" || R === "ucs-2" || R === "utf16le" || R === "utf-16le")) {
        if (m.length < 2 || _.length < 2) {
          return -1;
        }
        F = 2;
        U /= 2;
        H /= 2;
        C /= 2;
      }
      function read(m, _) {
        if (F === 1) {
          return m[_];
        } else {
          return m.readUInt16BE(_ * F);
        }
      }
      if (L) {
        var q = -1;
        for (B = C; B < U; B++) {
          if (read(m, B) === read(_, q === -1 ? 0 : B - q)) {
            if (q === -1) {
              q = B;
            }
            if (B - q + 1 === H) {
              return q * F;
            }
          } else {
            if (q !== -1) {
              B -= B - q;
            }
            q = -1;
          }
        }
      } else {
        if (C + H > U) {
          C = U - H;
        }
        B = C;
        for (; B >= 0; B--) {
          var V = true;
          for (var X = 0; X < H; X++) {
            if (read(m, B + X) !== read(_, X)) {
              V = false;
              break;
            }
          }
          if (V) {
            return B;
          }
        }
      }
      return -1;
    }
    function utf8Slice(m, _, C) {
      C = Math.min(m.length, C);
      var R = [];
      for (var L = _; L < C;) {
        var B;
        var F;
        var U;
        var H;
        var q = m[L];
        var V = null;
        var X = q > 239 ? 4 : q > 223 ? 3 : q > 191 ? 2 : 1;
        if (L + X <= C) {
          switch (X) {
            case 1:
              if (q < 128) {
                V = q;
              }
              break;
            case 2:
              if (((B = m[L + 1]) & 192) == 128 && (H = (q & 31) << 6 | B & 63) > 127) {
                V = H;
              }
              break;
            case 3:
              B = m[L + 1];
              F = m[L + 2];
              if ((B & 192) == 128 && (F & 192) == 128 && (H = (q & 15) << 12 | (B & 63) << 6 | F & 63) > 2047 && (H < 55296 || H > 57343)) {
                V = H;
              }
              break;
            case 4:
              B = m[L + 1];
              F = m[L + 2];
              U = m[L + 3];
              if ((B & 192) == 128 && (F & 192) == 128 && (U & 192) == 128 && (H = (q & 15) << 18 | (B & 63) << 12 | (F & 63) << 6 | U & 63) > 65535 && H < 1114112) {
                V = H;
              }
          }
        }
        if (V === null) {
          V = 65533;
          X = 1;
        } else if (V > 65535) {
          V -= 65536;
          R.push(V >>> 10 & 1023 | 55296);
          V = V & 1023 | 56320;
        }
        R.push(V);
        L += X;
      }
      return function (m) {
        var _ = m.length;
        if (_ <= 4096) {
          return String.fromCharCode.apply(String, m);
        }
        var C = "";
        for (var R = 0; R < _;) {
          C += String.fromCharCode.apply(String, m.slice(R, R += 4096));
        }
        return C;
      }(R);
    }
    function checkOffset(m, _, C) {
      if (m % 1 != 0 || m < 0) {
        throw RangeError("offset is not uint");
      }
      if (m + _ > C) {
        throw RangeError("Trying to access beyond buffer length");
      }
    }
    function checkInt(m, _, C, R, L, B) {
      if (!Buffer.isBuffer(m)) {
        throw TypeError("\"buffer\" argument must be a Buffer instance");
      }
      if (_ > L || _ < B) {
        throw RangeError("\"value\" argument is out of bounds");
      }
      if (C + R > m.length) {
        throw RangeError("Index out of range");
      }
    }
    function objectWriteUInt16(m, _, C, R) {
      if (_ < 0) {
        _ = 65535 + _ + 1;
      }
      for (var L = 0, B = Math.min(m.length - C, 2); L < B; ++L) {
        m[C + L] = (_ & 255 << (R ? L : 1 - L) * 8) >>> (R ? L : 1 - L) * 8;
      }
    }
    function objectWriteUInt32(m, _, C, R) {
      if (_ < 0) {
        _ = 4294967295 + _ + 1;
      }
      for (var L = 0, B = Math.min(m.length - C, 4); L < B; ++L) {
        m[C + L] = _ >>> (R ? L : 3 - L) * 8 & 255;
      }
    }
    function checkIEEE754(m, _, C, R, L, B) {
      if (C + R > m.length || C < 0) {
        throw RangeError("Index out of range");
      }
    }
    function writeFloat(m, _, C, R, B) {
      if (!B) {
        checkIEEE754(m, _, C, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      L.write(m, _, C, R, 23, 4);
      return C + 4;
    }
    function writeDouble(m, _, C, R, B) {
      if (!B) {
        checkIEEE754(m, _, C, 8, 1.7976931348623157e+308, -1.7976931348623157e+308);
      }
      L.write(m, _, C, R, 52, 8);
      return C + 8;
    }
    _.lW = Buffer;
    _.h2 = 50;
    Buffer.TYPED_ARRAY_SUPPORT = C.g.TYPED_ARRAY_SUPPORT !== undefined ? C.g.TYPED_ARRAY_SUPPORT : function () {
      try {
        var m = new Uint8Array(1);
        m.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function () {
            return 42;
          }
        };
        return m.foo() === 42 && typeof m.subarray == "function" && m.subarray(1, 1).byteLength === 0;
      } catch (m) {
        return false;
      }
    }();
    kMaxLength();
    Buffer.poolSize = 8192;
    Buffer._augment = function (m) {
      m.__proto__ = Buffer.prototype;
      return m;
    };
    Buffer.from = function (m, _, C) {
      return from(null, m, _, C);
    };
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol != "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        });
      }
    }
    Buffer.alloc = function (m, _, C) {
      assertSize(m);
      if (m <= 0) {
        return createBuffer(null, m);
      } else if (_ !== undefined) {
        if (typeof C == "string") {
          return createBuffer(null, m).fill(_, C);
        } else {
          return createBuffer(null, m).fill(_);
        }
      } else {
        return createBuffer(null, m);
      }
    };
    Buffer.allocUnsafe = function (m) {
      return allocUnsafe(null, m);
    };
    Buffer.allocUnsafeSlow = function (m) {
      return allocUnsafe(null, m);
    };
    Buffer.isBuffer = function (m) {
      return m != null && !!m._isBuffer;
    };
    Buffer.compare = function (m, _) {
      if (!Buffer.isBuffer(m) || !Buffer.isBuffer(_)) {
        throw TypeError("Arguments must be Buffers");
      }
      if (m === _) {
        return 0;
      }
      var C = m.length;
      var R = _.length;
      for (var L = 0, B = Math.min(C, R); L < B; ++L) {
        if (m[L] !== _[L]) {
          C = m[L];
          R = _[L];
          break;
        }
      }
      if (C < R) {
        return -1;
      } else if (R < C) {
        return 1;
      } else {
        return 0;
      }
    };
    Buffer.isEncoding = function (m) {
      switch (String(m).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function (m, _) {
      if (!B(m)) {
        throw TypeError("\"list\" argument must be an Array of Buffers");
      }
      if (m.length === 0) {
        return Buffer.alloc(0);
      }
      if (_ === undefined) {
        C = 0;
        _ = 0;
        for (; C < m.length; ++C) {
          _ += m[C].length;
        }
      }
      var C;
      var R = Buffer.allocUnsafe(_);
      var L = 0;
      for (C = 0; C < m.length; ++C) {
        var F = m[C];
        if (!Buffer.isBuffer(F)) {
          throw TypeError("\"list\" argument must be an Array of Buffers");
        }
        F.copy(R, L);
        L += F.length;
      }
      return R;
    };
    Buffer.byteLength = byteLength;
    Buffer.prototype._isBuffer = true;
    Buffer.prototype.swap16 = function () {
      var m = this.length;
      if (m % 2 != 0) {
        throw RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var _ = 0; _ < m; _ += 2) {
        swap(this, _, _ + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function () {
      var m = this.length;
      if (m % 4 != 0) {
        throw RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var _ = 0; _ < m; _ += 4) {
        swap(this, _, _ + 3);
        swap(this, _ + 1, _ + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function () {
      var m = this.length;
      if (m % 8 != 0) {
        throw RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var _ = 0; _ < m; _ += 8) {
        swap(this, _, _ + 7);
        swap(this, _ + 1, _ + 6);
        swap(this, _ + 2, _ + 5);
        swap(this, _ + 3, _ + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function () {
      var m = this.length | 0;
      if (m === 0) {
        return "";
      } else if (arguments.length == 0) {
        return utf8Slice(this, 0, m);
      } else {
        return slowToString.apply(this, arguments);
      }
    };
    Buffer.prototype.equals = function (m) {
      if (!Buffer.isBuffer(m)) {
        throw TypeError("Argument must be a Buffer");
      }
      return this === m || Buffer.compare(this, m) === 0;
    };
    Buffer.prototype.inspect = function () {
      var m = "";
      var C = _.h2;
      if (this.length > 0) {
        m = this.toString("hex", 0, C).match(/.{2}/g).join(" ");
        if (this.length > C) {
          m += " ... ";
        }
      }
      return "<Buffer " + m + ">";
    };
    Buffer.prototype.compare = function (m, _, C, R, L) {
      if (!Buffer.isBuffer(m)) {
        throw TypeError("Argument must be a Buffer");
      }
      if (_ === undefined) {
        _ = 0;
      }
      if (C === undefined) {
        C = m ? m.length : 0;
      }
      if (R === undefined) {
        R = 0;
      }
      if (L === undefined) {
        L = this.length;
      }
      if (_ < 0 || C > m.length || R < 0 || L > this.length) {
        throw RangeError("out of range index");
      }
      if (R >= L && _ >= C) {
        return 0;
      }
      if (R >= L) {
        return -1;
      }
      if (_ >= C) {
        return 1;
      }
      _ >>>= 0;
      C >>>= 0;
      R >>>= 0;
      L >>>= 0;
      if (this === m) {
        return 0;
      }
      var B = L - R;
      var F = C - _;
      for (var U = Math.min(B, F), H = this.slice(R, L), q = m.slice(_, C), V = 0; V < U; ++V) {
        if (H[V] !== q[V]) {
          B = H[V];
          F = q[V];
          break;
        }
      }
      if (B < F) {
        return -1;
      } else if (F < B) {
        return 1;
      } else {
        return 0;
      }
    };
    Buffer.prototype.includes = function (m, _, C) {
      return this.indexOf(m, _, C) !== -1;
    };
    Buffer.prototype.indexOf = function (m, _, C) {
      return bidirectionalIndexOf(this, m, _, C, true);
    };
    Buffer.prototype.lastIndexOf = function (m, _, C) {
      return bidirectionalIndexOf(this, m, _, C, false);
    };
    Buffer.prototype.write = function (m, _, C, R) {
      if (_ === undefined) {
        R = "utf8";
        C = this.length;
        _ = 0;
      } else if (C === undefined && typeof _ == "string") {
        R = _;
        C = this.length;
        _ = 0;
      } else if (isFinite(_)) {
        _ |= 0;
        if (isFinite(C)) {
          C |= 0;
          if (R === undefined) {
            R = "utf8";
          }
        } else {
          R = C;
          C = undefined;
        }
      } else {
        throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var L;
      var B;
      var F;
      var U;
      var H;
      var q;
      var V;
      var X;
      var K;
      var Y;
      var Q;
      var et;
      var er = this.length - _;
      if (C === undefined || C > er) {
        C = er;
      }
      if (m.length > 0 && (C < 0 || _ < 0) || _ > this.length) {
        throw RangeError("Attempt to write outside buffer bounds");
      }
      R ||= "utf8";
      var en = false;
      for (;;) {
        switch (R) {
          case "hex":
            return function (m, _, C, R) {
              C = Number(C) || 0;
              var L = m.length - C;
              if (R) {
                if ((R = Number(R)) > L) {
                  R = L;
                }
              } else {
                R = L;
              }
              var B = _.length;
              if (B % 2 != 0) {
                throw TypeError("Invalid hex string");
              }
              if (R > B / 2) {
                R = B / 2;
              }
              for (var F = 0; F < R; ++F) {
                var U = parseInt(_.substr(F * 2, 2), 16);
                if (isNaN(U)) {
                  break;
                }
                m[C + F] = U;
              }
              return F;
            }(this, m, _, C);
          case "utf8":
          case "utf-8":
            H = _;
            q = C;
            return blitBuffer(utf8ToBytes(m, this.length - H), this, H, q);
          case "ascii":
            V = _;
            X = C;
            return blitBuffer(asciiToBytes(m), this, V, X);
          case "latin1":
          case "binary":
            L = this;
            B = m;
            F = _;
            U = C;
            return blitBuffer(asciiToBytes(B), L, F, U);
          case "base64":
            K = _;
            Y = C;
            return blitBuffer(base64ToBytes(m), this, K, Y);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            Q = _;
            et = C;
            return blitBuffer(function (m, _) {
              var C;
              var R;
              var L = [];
              for (var B = 0; B < m.length && !((_ -= 2) < 0); ++B) {
                R = (C = m.charCodeAt(B)) >> 8;
                L.push(C % 256);
                L.push(R);
              }
              return L;
            }(m, this.length - Q), this, Q, et);
          default:
            if (en) {
              throw TypeError("Unknown encoding: " + R);
            }
            R = ("" + R).toLowerCase();
            en = true;
        }
      }
    };
    Buffer.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    Buffer.prototype.slice = function (m, _) {
      var C;
      var R = this.length;
      m = ~~m;
      _ = _ === undefined ? R : ~~_;
      if (m < 0) {
        if ((m += R) < 0) {
          m = 0;
        }
      } else if (m > R) {
        m = R;
      }
      if (_ < 0) {
        if ((_ += R) < 0) {
          _ = 0;
        }
      } else if (_ > R) {
        _ = R;
      }
      if (_ < m) {
        _ = m;
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        (C = this.subarray(m, _)).__proto__ = Buffer.prototype;
      } else {
        var L = _ - m;
        C = new Buffer(L, undefined);
        for (var B = 0; B < L; ++B) {
          C[B] = this[B + m];
        }
      }
      return C;
    };
    Buffer.prototype.readUIntLE = function (m, _, C) {
      m |= 0;
      _ |= 0;
      if (!C) {
        checkOffset(m, _, this.length);
      }
      var R = this[m];
      for (var L = 1, B = 0; ++B < _ && (L *= 256);) {
        R += this[m + B] * L;
      }
      return R;
    };
    Buffer.prototype.readUIntBE = function (m, _, C) {
      m |= 0;
      _ |= 0;
      if (!C) {
        checkOffset(m, _, this.length);
      }
      var R = this[m + --_];
      for (var L = 1; _ > 0 && (L *= 256);) {
        R += this[m + --_] * L;
      }
      return R;
    };
    Buffer.prototype.readUInt8 = function (m, _) {
      if (!_) {
        checkOffset(m, 1, this.length);
      }
      return this[m];
    };
    Buffer.prototype.readUInt16LE = function (m, _) {
      if (!_) {
        checkOffset(m, 2, this.length);
      }
      return this[m] | this[m + 1] << 8;
    };
    Buffer.prototype.readUInt16BE = function (m, _) {
      if (!_) {
        checkOffset(m, 2, this.length);
      }
      return this[m] << 8 | this[m + 1];
    };
    Buffer.prototype.readUInt32LE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216;
    };
    Buffer.prototype.readUInt32BE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
    };
    Buffer.prototype.readIntLE = function (m, _, C) {
      m |= 0;
      _ |= 0;
      if (!C) {
        checkOffset(m, _, this.length);
      }
      var R = this[m];
      for (var L = 1, B = 0; ++B < _ && (L *= 256);) {
        R += this[m + B] * L;
      }
      if (R >= (L *= 128)) {
        R -= Math.pow(2, _ * 8);
      }
      return R;
    };
    Buffer.prototype.readIntBE = function (m, _, C) {
      m |= 0;
      _ |= 0;
      if (!C) {
        checkOffset(m, _, this.length);
      }
      for (var R = _, L = 1, B = this[m + --R]; R > 0 && (L *= 256);) {
        B += this[m + --R] * L;
      }
      if (B >= (L *= 128)) {
        B -= Math.pow(2, _ * 8);
      }
      return B;
    };
    Buffer.prototype.readInt8 = function (m, _) {
      if (!_) {
        checkOffset(m, 1, this.length);
      }
      if (this[m] & 128) {
        return -((255 - this[m] + 1) * 1);
      } else {
        return this[m];
      }
    };
    Buffer.prototype.readInt16LE = function (m, _) {
      if (!_) {
        checkOffset(m, 2, this.length);
      }
      var C = this[m] | this[m + 1] << 8;
      if (C & 32768) {
        return C | 4294901760;
      } else {
        return C;
      }
    };
    Buffer.prototype.readInt16BE = function (m, _) {
      if (!_) {
        checkOffset(m, 2, this.length);
      }
      var C = this[m + 1] | this[m] << 8;
      if (C & 32768) {
        return C | 4294901760;
      } else {
        return C;
      }
    };
    Buffer.prototype.readInt32LE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
    };
    Buffer.prototype.readFloatLE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return L.read(this, m, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function (m, _) {
      if (!_) {
        checkOffset(m, 4, this.length);
      }
      return L.read(this, m, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function (m, _) {
      if (!_) {
        checkOffset(m, 8, this.length);
      }
      return L.read(this, m, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function (m, _) {
      if (!_) {
        checkOffset(m, 8, this.length);
      }
      return L.read(this, m, false, 52, 8);
    };
    Buffer.prototype.writeUIntLE = function (m, _, C, R) {
      m = +m;
      _ |= 0;
      C |= 0;
      if (!R) {
        var L = Math.pow(2, C * 8) - 1;
        checkInt(this, m, _, C, L, 0);
      }
      var B = 1;
      var F = 0;
      for (this[_] = m & 255; ++F < C && (B *= 256);) {
        this[_ + F] = m / B & 255;
      }
      return _ + C;
    };
    Buffer.prototype.writeUIntBE = function (m, _, C, R) {
      m = +m;
      _ |= 0;
      C |= 0;
      if (!R) {
        var L = Math.pow(2, C * 8) - 1;
        checkInt(this, m, _, C, L, 0);
      }
      var B = C - 1;
      var F = 1;
      for (this[_ + B] = m & 255; --B >= 0 && (F *= 256);) {
        this[_ + B] = m / F & 255;
      }
      return _ + C;
    };
    Buffer.prototype.writeUInt8 = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 1, 255, 0);
      }
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        m = Math.floor(m);
      }
      this[_] = m & 255;
      return _ + 1;
    };
    Buffer.prototype.writeUInt16LE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 2, 65535, 0);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m & 255;
        this[_ + 1] = m >>> 8;
      } else {
        objectWriteUInt16(this, m, _, true);
      }
      return _ + 2;
    };
    Buffer.prototype.writeUInt16BE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 2, 65535, 0);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m >>> 8;
        this[_ + 1] = m & 255;
      } else {
        objectWriteUInt16(this, m, _, false);
      }
      return _ + 2;
    };
    Buffer.prototype.writeUInt32LE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 4, 4294967295, 0);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_ + 3] = m >>> 24;
        this[_ + 2] = m >>> 16;
        this[_ + 1] = m >>> 8;
        this[_] = m & 255;
      } else {
        objectWriteUInt32(this, m, _, true);
      }
      return _ + 4;
    };
    Buffer.prototype.writeUInt32BE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 4, 4294967295, 0);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m >>> 24;
        this[_ + 1] = m >>> 16;
        this[_ + 2] = m >>> 8;
        this[_ + 3] = m & 255;
      } else {
        objectWriteUInt32(this, m, _, false);
      }
      return _ + 4;
    };
    Buffer.prototype.writeIntLE = function (m, _, C, R) {
      m = +m;
      _ |= 0;
      if (!R) {
        var L = Math.pow(2, C * 8 - 1);
        checkInt(this, m, _, C, L - 1, -L);
      }
      var B = 0;
      var F = 1;
      var U = 0;
      for (this[_] = m & 255; ++B < C && (F *= 256);) {
        if (m < 0 && U === 0 && this[_ + B - 1] !== 0) {
          U = 1;
        }
        this[_ + B] = (m / F >> 0) - U & 255;
      }
      return _ + C;
    };
    Buffer.prototype.writeIntBE = function (m, _, C, R) {
      m = +m;
      _ |= 0;
      if (!R) {
        var L = Math.pow(2, C * 8 - 1);
        checkInt(this, m, _, C, L - 1, -L);
      }
      var B = C - 1;
      var F = 1;
      var U = 0;
      for (this[_ + B] = m & 255; --B >= 0 && (F *= 256);) {
        if (m < 0 && U === 0 && this[_ + B + 1] !== 0) {
          U = 1;
        }
        this[_ + B] = (m / F >> 0) - U & 255;
      }
      return _ + C;
    };
    Buffer.prototype.writeInt8 = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 1, 127, -128);
      }
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        m = Math.floor(m);
      }
      if (m < 0) {
        m = 255 + m + 1;
      }
      this[_] = m & 255;
      return _ + 1;
    };
    Buffer.prototype.writeInt16LE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 2, 32767, -32768);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m & 255;
        this[_ + 1] = m >>> 8;
      } else {
        objectWriteUInt16(this, m, _, true);
      }
      return _ + 2;
    };
    Buffer.prototype.writeInt16BE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 2, 32767, -32768);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m >>> 8;
        this[_ + 1] = m & 255;
      } else {
        objectWriteUInt16(this, m, _, false);
      }
      return _ + 2;
    };
    Buffer.prototype.writeInt32LE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 4, 2147483647, -2147483648);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m & 255;
        this[_ + 1] = m >>> 8;
        this[_ + 2] = m >>> 16;
        this[_ + 3] = m >>> 24;
      } else {
        objectWriteUInt32(this, m, _, true);
      }
      return _ + 4;
    };
    Buffer.prototype.writeInt32BE = function (m, _, C) {
      m = +m;
      _ |= 0;
      if (!C) {
        checkInt(this, m, _, 4, 2147483647, -2147483648);
      }
      if (m < 0) {
        m = 4294967295 + m + 1;
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[_] = m >>> 24;
        this[_ + 1] = m >>> 16;
        this[_ + 2] = m >>> 8;
        this[_ + 3] = m & 255;
      } else {
        objectWriteUInt32(this, m, _, false);
      }
      return _ + 4;
    };
    Buffer.prototype.writeFloatLE = function (m, _, C) {
      return writeFloat(this, m, _, true, C);
    };
    Buffer.prototype.writeFloatBE = function (m, _, C) {
      return writeFloat(this, m, _, false, C);
    };
    Buffer.prototype.writeDoubleLE = function (m, _, C) {
      return writeDouble(this, m, _, true, C);
    };
    Buffer.prototype.writeDoubleBE = function (m, _, C) {
      return writeDouble(this, m, _, false, C);
    };
    Buffer.prototype.copy = function (m, _, C, R) {
      C ||= 0;
      if (!R && R !== 0) {
        R = this.length;
      }
      if (_ >= m.length) {
        _ = m.length;
      }
      _ ||= 0;
      if (R > 0 && R < C) {
        R = C;
      }
      if (R === C || m.length === 0 || this.length === 0) {
        return 0;
      }
      if (_ < 0) {
        throw RangeError("targetStart out of bounds");
      }
      if (C < 0 || C >= this.length) {
        throw RangeError("sourceStart out of bounds");
      }
      if (R < 0) {
        throw RangeError("sourceEnd out of bounds");
      }
      if (R > this.length) {
        R = this.length;
      }
      if (m.length - _ < R - C) {
        R = m.length - _ + C;
      }
      var L;
      var B = R - C;
      if (this === m && C < _ && _ < R) {
        for (L = B - 1; L >= 0; --L) {
          m[L + _] = this[L + C];
        }
      } else if (B < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        for (L = 0; L < B; ++L) {
          m[L + _] = this[L + C];
        }
      } else {
        Uint8Array.prototype.set.call(m, this.subarray(C, C + B), _);
      }
      return B;
    };
    Buffer.prototype.fill = function (m, _, C, R) {
      if (typeof m == "string") {
        if (typeof _ == "string") {
          R = _;
          _ = 0;
          C = this.length;
        } else if (typeof C == "string") {
          R = C;
          C = this.length;
        }
        if (m.length === 1) {
          var L;
          var B = m.charCodeAt(0);
          if (B < 256) {
            m = B;
          }
        }
        if (R !== undefined && typeof R != "string") {
          throw TypeError("encoding must be a string");
        }
        if (typeof R == "string" && !Buffer.isEncoding(R)) {
          throw TypeError("Unknown encoding: " + R);
        }
      } else if (typeof m == "number") {
        m &= 255;
      }
      if (_ < 0 || this.length < _ || this.length < C) {
        throw RangeError("Out of range index");
      }
      if (C <= _) {
        return this;
      }
      _ >>>= 0;
      C = C === undefined ? this.length : C >>> 0;
      m ||= 0;
      if (typeof m == "number") {
        for (L = _; L < C; ++L) {
          this[L] = m;
        }
      } else {
        var F = Buffer.isBuffer(m) ? m : utf8ToBytes(new Buffer(m, R).toString());
        var U = F.length;
        for (L = 0; L < C - _; ++L) {
          this[L + _] = F[L % U];
        }
      }
      return this;
    };
    var F = /[^+\/0-9A-Za-z-_]/g;
    function utf8ToBytes(m, _) {
      _ = _ || Infinity;
      var C;
      for (var R = m.length, L = null, B = [], F = 0; F < R; ++F) {
        if ((C = m.charCodeAt(F)) > 55295 && C < 57344) {
          if (!L) {
            if (C > 56319 || F + 1 === R) {
              if ((_ -= 3) > -1) {
                B.push(239, 191, 189);
              }
              continue;
            }
            L = C;
            continue;
          }
          if (C < 56320) {
            if ((_ -= 3) > -1) {
              B.push(239, 191, 189);
            }
            L = C;
            continue;
          }
          C = (L - 55296 << 10 | C - 56320) + 65536;
        } else if (L && (_ -= 3) > -1) {
          B.push(239, 191, 189);
        }
        L = null;
        if (C < 128) {
          if ((_ -= 1) < 0) {
            break;
          }
          B.push(C);
        } else if (C < 2048) {
          if ((_ -= 2) < 0) {
            break;
          }
          B.push(C >> 6 | 192, C & 63 | 128);
        } else if (C < 65536) {
          if ((_ -= 3) < 0) {
            break;
          }
          B.push(C >> 12 | 224, C >> 6 & 63 | 128, C & 63 | 128);
        } else if (C < 1114112) {
          if ((_ -= 4) < 0) {
            break;
          }
          B.push(C >> 18 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, C & 63 | 128);
        } else {
          throw Error("Invalid code point");
        }
      }
      return B;
    }
    function asciiToBytes(m) {
      var _ = [];
      for (var C = 0; C < m.length; ++C) {
        _.push(m.charCodeAt(C) & 255);
      }
      return _;
    }
    function base64ToBytes(m) {
      return R.toByteArray(function (m) {
        var _;
        if ((m = ((_ = m).trim ? _.trim() : _.replace(/^\s+|\s+$/g, "")).replace(F, "")).length < 2) {
          return "";
        }
        while (m.length % 4 != 0) {
          m += "=";
        }
        return m;
      }(m));
    }
    function blitBuffer(m, _, C, R) {
      for (var L = 0; L < R && !(L + C >= _.length) && !(L >= m.length); ++L) {
        _[L + C] = m[L];
      }
      return L;
    }
  },
  87300: function (m) {
    var _ = {}.toString;
    m.exports = Array.isArray || function (m) {
      return _.call(m) == "[object Array]";
    };
  },
  80645: function (m, _) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    _.read = function (m, _, C, R, L) {
      var B;
      var F;
      var U = L * 8 - R - 1;
      var H = (1 << U) - 1;
      var q = H >> 1;
      var V = -7;
      var X = C ? L - 1 : 0;
      var K = C ? -1 : 1;
      var Y = m[_ + X];
      X += K;
      B = Y & (1 << -V) - 1;
      Y >>= -V;
      V += U;
      for (; V > 0; V -= 8) {
        B = B * 256 + m[_ + X];
        X += K;
      }
      F = B & (1 << -V) - 1;
      B >>= -V;
      V += R;
      for (; V > 0; V -= 8) {
        F = F * 256 + m[_ + X];
        X += K;
      }
      if (B === 0) {
        B = 1 - q;
      } else {
        if (B === H) {
          if (F) {
            return NaN;
          } else {
            return (Y ? -1 : 1) * Infinity;
          }
        }
        F += Math.pow(2, R);
        B -= q;
      }
      return (Y ? -1 : 1) * F * Math.pow(2, B - R);
    };
    _.write = function (m, _, C, R, L, B) {
      var F;
      var U;
      var H;
      var q = B * 8 - L - 1;
      var V = (1 << q) - 1;
      var X = V >> 1;
      var K = L === 23 ? 5.960464477539062e-8 : 0;
      var Y = R ? 0 : B - 1;
      var Q = R ? 1 : -1;
      var et = _ < 0 || _ === 0 && 1 / _ < 0 ? 1 : 0;
      for (isNaN(_ = Math.abs(_)) || _ === Infinity ? (U = isNaN(_) ? 1 : 0, F = V) : (F = Math.floor(Math.log(_) / Math.LN2), _ * (H = Math.pow(2, -F)) < 1 && (F--, H *= 2), F + X >= 1 ? _ += K / H : _ += K * Math.pow(2, 1 - X), _ * H >= 2 && (F++, H /= 2), F + X >= V ? (U = 0, F = V) : F + X >= 1 ? (U = (_ * H - 1) * Math.pow(2, L), F += X) : (U = _ * Math.pow(2, X - 1) * Math.pow(2, L), F = 0)); L >= 8; L -= 8) {
        m[C + Y] = U & 255;
        Y += Q;
        U /= 256;
      }
      F = F << L | U;
      q += L;
      for (; q > 0; q -= 8) {
        m[C + Y] = F & 255;
        Y += Q;
        F /= 256;
      }
      m[C + Y - Q] |= et * 128;
    };
  },
  83198: function (m, _, C) {
    "use strict";

    let R;
    let L;
    let B;
    let F;
    let U;
    let H;
    function isShadowRoot(m) {
      let _ = m == null ? undefined : m.host;
      return (_ == null ? undefined : _.shadowRoot) === m;
    }
    function isNativeShadowDom(m) {
      return Object.prototype.toString.call(m) === "[object ShadowRoot]";
    }
    function stringifyStylesheet(m) {
      try {
        var _;
        let C = m.rules || m.cssRules;
        if (C) {
          if ((_ = Array.from(C, stringifyRule).join("")).includes(" background-clip: text;") && !_.includes(" -webkit-background-clip: text;")) {
            _ = _.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;");
          }
          return _;
        } else {
          return null;
        }
      } catch (m) {
        return null;
      }
    }
    function stringifyRule(m) {
      let _;
      if ("styleSheet" in m) {
        try {
          _ = stringifyStylesheet(m.styleSheet) || function (m) {
            let {
              cssText: _
            } = m;
            if (_.split("\"").length < 3) {
              return _;
            }
            let C = ["@import", `url(${JSON.stringify(m.href)})`];
            if (m.layerName === "") {
              C.push("layer");
            } else if (m.layerName) {
              C.push(`layer(${m.layerName})`);
            }
            if (m.supportsText) {
              C.push(`supports(${m.supportsText})`);
            }
            if (m.media.length) {
              C.push(m.media.mediaText);
            }
            return C.join(" ") + ";";
          }(m);
        } catch (m) {}
      } else if ("selectorText" in m && m.selectorText.includes(":")) {
        return m.cssText.replace(/(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm, "$1\\$2");
      }
      return _ || m.cssText;
    }
    C.d(_, {
      Z: function () {
        return t3;
      }
    });
    (eT = eR ||= {})[eT.Document = 0] = "Document";
    eT[eT.DocumentType = 1] = "DocumentType";
    eT[eT.Element = 2] = "Element";
    eT[eT.Text = 3] = "Text";
    eT[eT.CDATA = 4] = "CDATA";
    eT[eT.Comment = 5] = "Comment";
    let Mirror = class Mirror {
      constructor() {
        this.idNodeMap = new Map();
        this.nodeMetaMap = new WeakMap();
      }
      getId(m) {
        if (!m) {
          return -1;
        }
        let C = this.getMeta(m)?.id;
        return C ?? -1;
      }
      getNode(m) {
        return this.idNodeMap.get(m) || null;
      }
      getIds() {
        return Array.from(this.idNodeMap.keys());
      }
      getMeta(m) {
        return this.nodeMetaMap.get(m) || null;
      }
      removeNodeFromMap(m) {
        let _ = this.getId(m);
        this.idNodeMap.delete(_);
        if (m.childNodes) {
          m.childNodes.forEach(m => this.removeNodeFromMap(m));
        }
      }
      has(m) {
        return this.idNodeMap.has(m);
      }
      hasNode(m) {
        return this.nodeMetaMap.has(m);
      }
      add(m, _) {
        let C = _.id;
        this.idNodeMap.set(C, m);
        this.nodeMetaMap.set(m, _);
      }
      replace(m, _) {
        let C = this.getNode(m);
        if (C) {
          let m = this.nodeMetaMap.get(C);
          if (m) {
            this.nodeMetaMap.set(_, m);
          }
        }
        this.idNodeMap.set(m, _);
      }
      reset() {
        this.idNodeMap = new Map();
        this.nodeMetaMap = new WeakMap();
      }
    };
    function maskInputValue({
      element: m,
      maskInputOptions: _,
      tagName: C,
      type: R,
      value: L,
      maskInputFn: B
    }) {
      let F = L || "";
      let U = R && toLowerCase(R);
      if (_[C.toLowerCase()] || U && _[U]) {
        F = B ? B(F, m) : "*".repeat(F.length);
      }
      return F;
    }
    function toLowerCase(m) {
      return m.toLowerCase();
    }
    let q = "__rrweb_original__";
    function getInputType(m) {
      let _ = m.type;
      if (m.hasAttribute("data-rr-is-password")) {
        return "password";
      } else if (_) {
        return toLowerCase(_);
      } else {
        return null;
      }
    }
    function extractFileExtension(m, _) {
      let R;
      try {
        R = new URL(m, _ ?? window.location.href);
      } catch (m) {
        return null;
      }
      let L = R.pathname.match(/\.([0-9a-z]+)(?:$)/i);
      return (L == null ? undefined : L[1]) ?? null;
    }
    let V = 1;
    let X = RegExp("[^a-z0-9-_:]");
    function genId() {
      return V++;
    }
    let K = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
    let Y = /^(?:[a-z+]+:)?\/\//i;
    let Q = /^www\..*/i;
    let et = /^(data:)([^,]*),(.*)/i;
    function absoluteToStylesheet(m, _) {
      return (m || "").replace(K, (m, C, R, L, B, F) => {
        let U = R || B || F;
        let H = C || L || "";
        if (!U) {
          return m;
        }
        if (Y.test(U) || Q.test(U) || et.test(U)) {
          return `url(${H}${U}${H})`;
        }
        if (U[0] === "/") {
          return `url(${H}${(_.indexOf("//") > -1 ? _.split("/").slice(0, 3).join("/") : _.split("/")[0]).split("?")[0] + U}${H})`;
        }
        let q = _.split("/");
        let V = U.split("/");
        q.pop();
        for (let m of V) {
          if (m !== ".") {
            if (m === "..") {
              q.pop();
            } else {
              q.push(m);
            }
          }
        }
        return `url(${H}${q.join("/")}${H})`;
      });
    }
    let er = /^[^ \t\n\r\u000c]+/;
    let en = /^[, \t\n\r\u000c]+/;
    function absoluteToDoc(m, _) {
      if (!_ || _.trim() === "") {
        return _;
      }
      let C = m.createElement("a");
      C.href = _;
      return C.href;
    }
    function getHref() {
      let m = document.createElement("a");
      m.href = "";
      return m.href;
    }
    function transformAttribute(m, _, C, R) {
      if (R) {
        if (C !== "src" && (C !== "href" || _ === "use" && R[0] === "#") && (C !== "xlink:href" || R[0] === "#") && (C !== "background" || _ !== "table" && _ !== "td" && _ !== "th")) {
          if (C === "srcset") {
            return function (m, _) {
              if (_.trim() === "") {
                return _;
              }
              let C = 0;
              function collectCharacters(m) {
                let R;
                let L = m.exec(_.substring(C));
                if (L) {
                  R = L[0];
                  C += R.length;
                  return R;
                } else {
                  return "";
                }
              }
              let R = [];
              while (collectCharacters(en), !(C >= _.length)) {
                let L = collectCharacters(er);
                if (L.slice(-1) === ",") {
                  L = absoluteToDoc(m, L.substring(0, L.length - 1));
                  R.push(L);
                } else {
                  let B = "";
                  L = absoluteToDoc(m, L);
                  let F = false;
                  while (true) {
                    let m = _.charAt(C);
                    if (m === "") {
                      R.push((L + B).trim());
                      break;
                    }
                    if (F) {
                      if (m === ")") {
                        F = false;
                      }
                    } else {
                      if (m === ",") {
                        C += 1;
                        R.push((L + B).trim());
                        break;
                      }
                      if (m === "(") {
                        F = true;
                      }
                    }
                    B += m;
                    C += 1;
                  }
                }
              }
              return R.join(", ");
            }(m, R);
          } else if (C === "style") {
            return absoluteToStylesheet(R, getHref());
          } else if (_ === "object" && C === "data") {
            return absoluteToDoc(m, R);
          } else {
            return R;
          }
        } else {
          return absoluteToDoc(m, R);
        }
      } else {
        return R;
      }
    }
    function ignoreAttribute(m, _, C) {
      return (m === "video" || m === "audio") && _ === "autoplay";
    }
    function classMatchesRegex(m, _, C) {
      if (!m) {
        return false;
      }
      if (m.nodeType !== m.ELEMENT_NODE) {
        return !!C && classMatchesRegex(m.parentNode, _, C);
      }
      for (let C = m.classList.length; C--;) {
        let R = m.classList[C];
        if (_.test(R)) {
          return true;
        }
      }
      return !!C && classMatchesRegex(m.parentNode, _, C);
    }
    function needMaskingText(m, _, C, R) {
      try {
        let L = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
        if (L === null) {
          return false;
        }
        if (typeof _ == "string") {
          if (R) {
            if (L.closest(`.${_}`)) {
              return true;
            }
          } else if (L.classList.contains(_)) {
            return true;
          }
        } else if (classMatchesRegex(L, _, R)) {
          return true;
        }
        if (C) {
          if (R) {
            if (L.closest(C)) {
              return true;
            }
          } else if (L.matches(C)) {
            return true;
          }
        }
      } catch (m) {}
      return false;
    }
    function lowerIfExists(m) {
      if (m == null) {
        return "";
      } else {
        return m.toLowerCase();
      }
    }
    function serializeNodeWithId(m, _) {
      let C;
      let {
        doc: B,
        mirror: F,
        blockClass: U,
        blockSelector: H,
        maskTextClass: V,
        maskTextSelector: K,
        skipChild: Y = false,
        inlineStylesheet: Q = true,
        maskInputOptions: et = {},
        maskTextFn: er,
        maskInputFn: en,
        slimDOMOptions: ei,
        dataURLOptions: eo = {},
        inlineImages: ea = false,
        recordCanvas: es = false,
        onSerialize: ec,
        onIframeLoad: el,
        iframeLoadTimeout: eu = 5000,
        onStylesheetLoad: ed,
        stylesheetLoadTimeout: ep = 5000,
        keepIframeSrcFn: eh = () => false,
        newlyAddedElement: ef = false
      } = _;
      let {
        needsMask: em
      } = _;
      let {
        preserveWhiteSpace: eg = true
      } = _;
      if (!em && m.childNodes) {
        let _ = em === undefined;
        em = needMaskingText(m, V, K, _);
      }
      let ey = function (m, _) {
        let {
          doc: C,
          mirror: B,
          blockClass: F,
          blockSelector: U,
          needsMask: H,
          inlineStylesheet: V,
          maskInputOptions: K = {},
          maskTextFn: Y,
          maskInputFn: Q,
          dataURLOptions: et = {},
          inlineImages: er,
          recordCanvas: en,
          keepIframeSrcFn: ei,
          newlyAddedElement: eo = false
        } = _;
        let ea = function (m, _) {
          if (!_.hasNode(m)) {
            return;
          }
          let C = _.getId(m);
          if (C === 1) {
            return undefined;
          } else {
            return C;
          }
        }(C, B);
        switch (m.nodeType) {
          case m.DOCUMENT_NODE:
            if (m.compatMode !== "CSS1Compat") {
              return {
                type: eR.Document,
                childNodes: [],
                compatMode: m.compatMode
              };
            }
            return {
              type: eR.Document,
              childNodes: []
            };
          case m.DOCUMENT_TYPE_NODE:
            return {
              type: eR.DocumentType,
              name: m.name,
              publicId: m.publicId,
              systemId: m.systemId,
              rootId: ea
            };
          case m.ELEMENT_NODE:
            return function (m, _) {
              let C;
              let {
                doc: B,
                blockClass: F,
                blockSelector: U,
                inlineStylesheet: H,
                maskInputOptions: V = {},
                maskInputFn: K,
                dataURLOptions: Y = {},
                inlineImages: Q,
                recordCanvas: et,
                keepIframeSrcFn: er,
                newlyAddedElement: en = false,
                rootId: ei
              } = _;
              let eo = function (m, _, C) {
                try {
                  if (typeof _ == "string") {
                    if (m.classList.contains(_)) {
                      return true;
                    }
                  } else {
                    for (let C = m.classList.length; C--;) {
                      let R = m.classList[C];
                      if (_.test(R)) {
                        return true;
                      }
                    }
                  }
                  if (C) {
                    return m.matches(C);
                  }
                } catch (m) {}
                return false;
              }(m, F, U);
              let ea = function (m) {
                if (m instanceof HTMLFormElement) {
                  return "form";
                }
                let _ = toLowerCase(m.tagName);
                if (X.test(_)) {
                  return "div";
                } else {
                  return _;
                }
              }(m);
              let es = {};
              let ec = m.attributes.length;
              for (let _ = 0; _ < ec; _++) {
                let C = m.attributes[_];
                if (!ignoreAttribute(ea, C.name, C.value)) {
                  es[C.name] = transformAttribute(B, ea, toLowerCase(C.name), C.value);
                }
              }
              if (ea === "link" && H) {
                let _ = Array.from(B.styleSheets).find(_ => _.href === m.href);
                let C = null;
                if (_) {
                  C = stringifyStylesheet(_);
                }
                if (C) {
                  delete es.rel;
                  delete es.href;
                  es._cssText = absoluteToStylesheet(C, _.href);
                }
              }
              if (ea === "style" && m.sheet && !(m.innerText || m.textContent || "").trim().length) {
                let _ = stringifyStylesheet(m.sheet);
                if (_) {
                  es._cssText = absoluteToStylesheet(_, getHref());
                }
              }
              if (ea === "input" || ea === "textarea" || ea === "select") {
                let _ = m.value;
                let C = m.checked;
                if (es.type !== "radio" && es.type !== "checkbox" && es.type !== "submit" && es.type !== "button" && _) {
                  es.value = maskInputValue({
                    element: m,
                    type: getInputType(m),
                    tagName: ea,
                    value: _,
                    maskInputOptions: V,
                    maskInputFn: K
                  });
                } else if (C) {
                  es.checked = C;
                }
              }
              if (ea === "option") {
                if (m.selected && !V.select) {
                  es.selected = true;
                } else {
                  delete es.selected;
                }
              }
              if (ea === "canvas" && et) {
                if (m.__context === "2d") {
                  if (!function (m) {
                    let _ = m.getContext("2d");
                    if (!_) {
                      return true;
                    }
                    for (let C = 0; C < m.width; C += 50) {
                      for (let R = 0; R < m.height; R += 50) {
                        let L = _.getImageData;
                        let B = q in L ? L[q] : L;
                        let F = new Uint32Array(B.call(_, C, R, Math.min(50, m.width - C), Math.min(50, m.height - R)).data.buffer);
                        if (F.some(m => m !== 0)) {
                          return false;
                        }
                      }
                    }
                    return true;
                  }(m)) {
                    es.rr_dataURL = m.toDataURL(Y.type, Y.quality);
                  }
                } else if (!("__context" in m)) {
                  let _ = m.toDataURL(Y.type, Y.quality);
                  let C = document.createElement("canvas");
                  C.width = m.width;
                  C.height = m.height;
                  let R = C.toDataURL(Y.type, Y.quality);
                  if (_ !== R) {
                    es.rr_dataURL = _;
                  }
                }
              }
              if (ea === "img" && Q) {
                if (!R) {
                  L = (R = B.createElement("canvas")).getContext("2d");
                }
                let _ = m.crossOrigin;
                m.crossOrigin = "anonymous";
                let recordInlineImage = () => {
                  m.removeEventListener("load", recordInlineImage);
                  try {
                    R.width = m.naturalWidth;
                    R.height = m.naturalHeight;
                    L.drawImage(m, 0, 0);
                    es.rr_dataURL = R.toDataURL(Y.type, Y.quality);
                  } catch (_) {
                    console.warn(`Cannot inline img src=${m.currentSrc}! Error: ${_}`);
                  }
                  if (_) {
                    es.crossOrigin = _;
                  } else {
                    m.removeAttribute("crossorigin");
                  }
                };
                if (m.complete && m.naturalWidth !== 0) {
                  recordInlineImage();
                } else {
                  m.addEventListener("load", recordInlineImage);
                }
              }
              if (ea === "audio" || ea === "video") {
                let _ = es;
                _.rr_mediaState = m.paused ? "paused" : "played";
                _.rr_mediaCurrentTime = m.currentTime;
                _.rr_mediaPlaybackRate = m.playbackRate;
                _.rr_mediaMuted = m.muted;
                _.rr_mediaLoop = m.loop;
                _.rr_mediaVolume = m.volume;
              }
              if (!en) {
                if (m.scrollLeft) {
                  es.rr_scrollLeft = m.scrollLeft;
                }
                if (m.scrollTop) {
                  es.rr_scrollTop = m.scrollTop;
                }
              }
              if (eo) {
                let {
                  width: _,
                  height: C
                } = m.getBoundingClientRect();
                es = {
                  class: es.class,
                  rr_width: `${_}px`,
                  rr_height: `${C}px`
                };
              }
              if (ea === "iframe" && !er(es.src)) {
                if (!m.contentDocument) {
                  es.rr_src = es.src;
                }
                delete es.src;
              }
              try {
                if (customElements.get(ea)) {
                  C = true;
                }
              } catch (m) {}
              return {
                type: eR.Element,
                tagName: ea,
                attributes: es,
                childNodes: [],
                isSVG: m.tagName === "svg" || !!m.ownerSVGElement || undefined,
                needBlock: eo,
                rootId: ei,
                isCustom: C
              };
            }(m, {
              doc: C,
              blockClass: F,
              blockSelector: U,
              inlineStylesheet: V,
              maskInputOptions: K,
              maskInputFn: Q,
              dataURLOptions: et,
              inlineImages: er,
              recordCanvas: en,
              keepIframeSrcFn: ei,
              newlyAddedElement: eo,
              rootId: ea
            });
          case m.TEXT_NODE:
            return function (m, _) {
              let {
                needsMask: R,
                maskTextFn: L,
                rootId: B
              } = _;
              let F = m.parentNode && m.parentNode.tagName;
              let U = m.textContent;
              let H = F === "STYLE" || undefined;
              let q = F === "SCRIPT" || undefined;
              if (H && U) {
                try {
                  if (!m.nextSibling && !m.previousSibling) {
                    if (m.parentNode.sheet?.cssRules) {
                      U = stringifyStylesheet(m.parentNode.sheet);
                    }
                  }
                } catch (_) {
                  console.warn(`Cannot get CSS styles from text's parentNode. Error: ${_}`, m);
                }
                U = absoluteToStylesheet(U, getHref());
              }
              if (q) {
                U = "SCRIPT_PLACEHOLDER";
              }
              if (!H && !q && U && R) {
                U = L ? L(U, m.parentElement) : U.replace(/[\S]/g, "*");
              }
              return {
                type: eR.Text,
                textContent: U || "",
                isStyle: H,
                rootId: B
              };
            }(m, {
              needsMask: H,
              maskTextFn: Y,
              rootId: ea
            });
          case m.CDATA_SECTION_NODE:
            return {
              type: eR.CDATA,
              textContent: "",
              rootId: ea
            };
          case m.COMMENT_NODE:
            return {
              type: eR.Comment,
              textContent: m.textContent || "",
              rootId: ea
            };
          default:
            return false;
        }
      }(m, {
        doc: B,
        mirror: F,
        blockClass: U,
        blockSelector: H,
        needsMask: em,
        inlineStylesheet: Q,
        maskInputOptions: et,
        maskTextFn: er,
        maskInputFn: en,
        dataURLOptions: eo,
        inlineImages: ea,
        recordCanvas: es,
        keepIframeSrcFn: eh,
        newlyAddedElement: ef
      });
      if (!ey) {
        console.warn(m, "not serialized");
        return null;
      }
      C = F.hasNode(m) ? F.getId(m) : !function (m, _) {
        if (_.comment && m.type === eR.Comment) {
          return true;
        }
        if (m.type === eR.Element) {
          if (_.script && (m.tagName === "script" || m.tagName === "link" && (m.attributes.rel === "preload" || m.attributes.rel === "modulepreload") && m.attributes.as === "script" || m.tagName === "link" && m.attributes.rel === "prefetch" && typeof m.attributes.href == "string" && extractFileExtension(m.attributes.href) === "js") || _.headFavicon && (m.tagName === "link" && m.attributes.rel === "shortcut icon" || m.tagName === "meta" && (lowerIfExists(m.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(m.attributes.name) === "application-name" || lowerIfExists(m.attributes.rel) === "icon" || lowerIfExists(m.attributes.rel) === "apple-touch-icon" || lowerIfExists(m.attributes.rel) === "shortcut icon"))) {
            return true;
          }
          if (m.tagName === "meta") {
            if (_.headMetaDescKeywords && lowerIfExists(m.attributes.name).match(/^description|keywords$/) || _.headMetaSocial && (lowerIfExists(m.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(m.attributes.name).match(/^(og|twitter):/) || lowerIfExists(m.attributes.name) === "pinterest")) {
              return true;
            }
            if (_.headMetaRobots && (lowerIfExists(m.attributes.name) === "robots" || lowerIfExists(m.attributes.name) === "googlebot" || lowerIfExists(m.attributes.name) === "bingbot")) {
              return true;
            }
            if (_.headMetaHttpEquiv && m.attributes["http-equiv"] !== undefined) {
              return true;
            } else if (_.headMetaAuthorship && (lowerIfExists(m.attributes.name) === "author" || lowerIfExists(m.attributes.name) === "generator" || lowerIfExists(m.attributes.name) === "framework" || lowerIfExists(m.attributes.name) === "publisher" || lowerIfExists(m.attributes.name) === "progid" || lowerIfExists(m.attributes.property).match(/^article:/) || lowerIfExists(m.attributes.property).match(/^product:/))) {
              return true;
            } else if (_.headMetaVerification && (lowerIfExists(m.attributes.name) === "google-site-verification" || lowerIfExists(m.attributes.name) === "yandex-verification" || lowerIfExists(m.attributes.name) === "csrf-token" || lowerIfExists(m.attributes.name) === "p:domain_verify" || lowerIfExists(m.attributes.name) === "verify-v1" || lowerIfExists(m.attributes.name) === "verification" || lowerIfExists(m.attributes.name) === "shopify-checkout-api-token")) {
              return true;
            }
          }
        }
        return false;
      }(ey, ei) && (eg || ey.type !== eR.Text || ey.isStyle || ey.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : -2;
      let e_ = Object.assign(ey, {
        id: C
      });
      F.add(m, e_);
      if (C === -2) {
        return null;
      }
      if (ec) {
        ec(m);
      }
      let ev = !Y;
      if (e_.type === eR.Element) {
        ev = ev && !e_.needBlock;
        delete e_.needBlock;
        let _ = m.shadowRoot;
        if (_ && isNativeShadowDom(_)) {
          e_.isShadowHost = true;
        }
      }
      if ((e_.type === eR.Document || e_.type === eR.Element) && ev) {
        if (ei.headWhitespace && e_.type === eR.Element && e_.tagName === "head") {
          eg = false;
        }
        let _ = {
          doc: B,
          mirror: F,
          blockClass: U,
          blockSelector: H,
          needsMask: em,
          maskTextClass: V,
          maskTextSelector: K,
          skipChild: Y,
          inlineStylesheet: Q,
          maskInputOptions: et,
          maskTextFn: er,
          maskInputFn: en,
          slimDOMOptions: ei,
          dataURLOptions: eo,
          inlineImages: ea,
          recordCanvas: es,
          preserveWhiteSpace: eg,
          onSerialize: ec,
          onIframeLoad: el,
          iframeLoadTimeout: eu,
          onStylesheetLoad: ed,
          stylesheetLoadTimeout: ep,
          keepIframeSrcFn: eh
        };
        if (e_.type === eR.Element && e_.tagName === "textarea" && e_.attributes.value !== undefined) ;else {
          for (let C of Array.from(m.childNodes)) {
            let m = serializeNodeWithId(C, _);
            if (m) {
              e_.childNodes.push(m);
            }
          }
        }
        if (m.nodeType === m.ELEMENT_NODE && m.shadowRoot) {
          for (let C of Array.from(m.shadowRoot.childNodes)) {
            let R = serializeNodeWithId(C, _);
            if (R) {
              if (isNativeShadowDom(m.shadowRoot)) {
                R.isShadow = true;
              }
              e_.childNodes.push(R);
            }
          }
        }
      }
      if (m.parentNode && isShadowRoot(m.parentNode) && isNativeShadowDom(m.parentNode)) {
        e_.isShadow = true;
      }
      if (e_.type === eR.Element && e_.tagName === "iframe") {
        (function (m, _, C) {
          let R;
          let L = m.contentWindow;
          if (!L) {
            return;
          }
          let B = false;
          try {
            R = L.document.readyState;
          } catch (m) {
            return;
          }
          if (R !== "complete") {
            let R = setTimeout(() => {
              if (!B) {
                _();
                B = true;
              }
            }, C);
            m.addEventListener("load", () => {
              clearTimeout(R);
              B = true;
              _();
            });
            return;
          }
          let F = "about:blank";
          if (L.location.href !== F || m.src === F || m.src === "") {
            setTimeout(_, 0);
            return m.addEventListener("load", _);
          }
          m.addEventListener("load", _);
        })(m, () => {
          let _ = m.contentDocument;
          if (_ && el) {
            let C = serializeNodeWithId(_, {
              doc: _,
              mirror: F,
              blockClass: U,
              blockSelector: H,
              needsMask: em,
              maskTextClass: V,
              maskTextSelector: K,
              skipChild: false,
              inlineStylesheet: Q,
              maskInputOptions: et,
              maskTextFn: er,
              maskInputFn: en,
              slimDOMOptions: ei,
              dataURLOptions: eo,
              inlineImages: ea,
              recordCanvas: es,
              preserveWhiteSpace: eg,
              onSerialize: ec,
              onIframeLoad: el,
              iframeLoadTimeout: eu,
              onStylesheetLoad: ed,
              stylesheetLoadTimeout: ep,
              keepIframeSrcFn: eh
            });
            if (C) {
              el(m, C);
            }
          }
        }, eu);
      }
      if (e_.type === eR.Element && e_.tagName === "link" && typeof e_.attributes.rel == "string" && (e_.attributes.rel === "stylesheet" || e_.attributes.rel === "preload" && typeof e_.attributes.href == "string" && extractFileExtension(e_.attributes.href) === "css")) {
        (function (m, _, C) {
          let R;
          let L = false;
          try {
            R = m.sheet;
          } catch (m) {
            return;
          }
          if (R) {
            return;
          }
          let B = setTimeout(() => {
            if (!L) {
              _();
              L = true;
            }
          }, C);
          m.addEventListener("load", () => {
            clearTimeout(B);
            L = true;
            _();
          });
        })(m, () => {
          if (ed) {
            let _ = serializeNodeWithId(m, {
              doc: B,
              mirror: F,
              blockClass: U,
              blockSelector: H,
              needsMask: em,
              maskTextClass: V,
              maskTextSelector: K,
              skipChild: false,
              inlineStylesheet: Q,
              maskInputOptions: et,
              maskTextFn: er,
              maskInputFn: en,
              slimDOMOptions: ei,
              dataURLOptions: eo,
              inlineImages: ea,
              recordCanvas: es,
              preserveWhiteSpace: eg,
              onSerialize: ec,
              onIframeLoad: el,
              iframeLoadTimeout: eu,
              onStylesheetLoad: ed,
              stylesheetLoadTimeout: ep,
              keepIframeSrcFn: eh
            });
            if (_) {
              ed(m, _);
            }
          }
        }, ep);
      }
      return e_;
    }
    function on(m, _, C = document) {
      let R = {
        capture: true,
        passive: true
      };
      C.addEventListener(m, _, R);
      return () => C.removeEventListener(m, _, R);
    }
    let ei = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
    let eo = {
      map: {},
      getId: () => {
        console.error(ei);
        return -1;
      },
      getNode: () => {
        console.error(ei);
        return null;
      },
      removeNodeFromMap() {
        console.error(ei);
      },
      has: () => {
        console.error(ei);
        return false;
      },
      reset() {
        console.error(ei);
      }
    };
    function throttle(m, _, C = {}) {
      let R = null;
      let L = 0;
      return function (...B) {
        let F = Date.now();
        if (!L && C.leading === false) {
          L = F;
        }
        let U = _ - (F - L);
        let H = this;
        if (U <= 0 || U > _) {
          if (R) {
            clearTimeout(R);
            R = null;
          }
          L = F;
          m.apply(H, B);
        } else if (!R && C.trailing !== false) {
          R = setTimeout(() => {
            L = C.leading === false ? 0 : Date.now();
            R = null;
            m.apply(H, B);
          }, U);
        }
      };
    }
    function hookSetter(m, _, C, R, L = window) {
      let B = L.Object.getOwnPropertyDescriptor(m, _);
      L.Object.defineProperty(m, _, R ? C : {
        set(m) {
          setTimeout(() => {
            C.set.call(this, m);
          }, 0);
          if (B && B.set) {
            B.set.call(this, m);
          }
        }
      });
      return () => hookSetter(m, _, B || {}, true);
    }
    function patch(m, _, C) {
      try {
        if (!(_ in m)) {
          return () => {};
        }
        let R = m[_];
        let L = C(R);
        if (typeof L == "function") {
          L.prototype = L.prototype || {};
          Object.defineProperties(L, {
            __rrweb_original__: {
              enumerable: false,
              value: R
            }
          });
        }
        m[_] = L;
        return () => {
          m[_] = R;
        };
      } catch (m) {
        return () => {};
      }
    }
    if (typeof window != "undefined" && window.Proxy && window.Reflect) {
      eo = new Proxy(eo, {
        get: (m, _, C) => {
          if (_ === "map") {
            console.error(ei);
          }
          return Reflect.get(m, _, C);
        }
      });
    }
    let ea = Date.now;
    function getWindowScroll(m) {
      let U = m.document;
      return {
        left: U.scrollingElement ? U.scrollingElement.scrollLeft : m.pageXOffset !== undefined ? m.pageXOffset : (U == null ? undefined : U.documentElement.scrollLeft) || (U == null ? undefined : U.body)?.parentElement?.scrollLeft || (U == null ? undefined : U.body)?.scrollLeft || 0,
        top: U.scrollingElement ? U.scrollingElement.scrollTop : m.pageYOffset !== undefined ? m.pageYOffset : (U == null ? undefined : U.documentElement.scrollTop) || (U == null ? undefined : U.body)?.parentElement?.scrollTop || (U == null ? undefined : U.body)?.scrollTop || 0
      };
    }
    function getWindowHeight() {
      return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
    }
    function getWindowWidth() {
      return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
    }
    function closestElementOfNode(m) {
      if (!m) {
        return null;
      }
      let _ = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
      return _;
    }
    function isBlocked(m, _, C, R) {
      if (!m) {
        return false;
      }
      let L = closestElementOfNode(m);
      if (!L) {
        return false;
      }
      try {
        if (typeof _ == "string") {
          if (L.classList.contains(_) || R && L.closest("." + _) !== null) {
            return true;
          }
        } else if (classMatchesRegex(L, _, R)) {
          return true;
        }
      } catch (m) {}
      return !!C && (!!L.matches(C) || !!R && L.closest(C) !== null);
    }
    function isIgnored(m, _) {
      return _.getId(m) === -2;
    }
    function legacy_isTouchEvent(m) {
      return !!m.changedTouches;
    }
    function isSerializedIframe(m, _) {
      return m.nodeName === "IFRAME" && !!_.getMeta(m);
    }
    function isSerializedStylesheet(m, _) {
      return m.nodeName === "LINK" && m.nodeType === m.ELEMENT_NODE && !!m.getAttribute && m.getAttribute("rel") === "stylesheet" && !!_.getMeta(m);
    }
    function hasShadowRoot(m) {
      return !!(m == null ? undefined : m.shadowRoot);
    }
    if (!/[1-9][0-9]{12}/.test(Date.now().toString())) {
      ea = () => new Date().getTime();
    }
    let StyleSheetMirror = class StyleSheetMirror {
      constructor() {
        this.id = 1;
        this.styleIDMap = new WeakMap();
        this.idStyleMap = new Map();
      }
      getId(m) {
        return this.styleIDMap.get(m) ?? -1;
      }
      has(m) {
        return this.styleIDMap.has(m);
      }
      add(m, _) {
        let C;
        if (this.has(m)) {
          return this.getId(m);
        } else {
          C = _ === undefined ? this.id++ : _;
          this.styleIDMap.set(m, C);
          this.idStyleMap.set(C, m);
          return C;
        }
      }
      getStyle(m) {
        return this.idStyleMap.get(m) || null;
      }
      reset() {
        this.styleIDMap = new WeakMap();
        this.idStyleMap = new Map();
        this.id = 1;
      }
      generateId() {
        return this.id++;
      }
    };
    function getShadowHost(m) {
      var _;
      let R = null;
      if (((_ = m.getRootNode) === null || _ === undefined ? undefined : _.call(m))?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && m.getRootNode().host) {
        R = m.getRootNode().host;
      }
      return R;
    }
    function inDom(m) {
      let _ = m.ownerDocument;
      return !!_ && (_.contains(m) || function (m) {
        let _ = m.ownerDocument;
        if (!_) {
          return false;
        }
        let C = function (m) {
          let _;
          let C = m;
          while (_ = getShadowHost(C)) {
            C = _;
          }
          return C;
        }(m);
        return _.contains(C);
      }(m));
    }
    var es;
    var ec;
    var el;
    var eu;
    var ed;
    var ep;
    var eh;
    var ef;
    var em;
    var eg;
    var ey;
    var e_;
    var ev;
    var eb;
    var eS;
    var ew;
    var eE;
    var ek;
    var ex;
    var eI;
    var eO;
    var eC;
    var eM;
    var eT;
    var eA;
    var eR;
    var eP;
    var eD;
    var eL;
    (eA = eN || {})[eA.DomContentLoaded = 0] = "DomContentLoaded";
    eA[eA.Load = 1] = "Load";
    eA[eA.FullSnapshot = 2] = "FullSnapshot";
    eA[eA.IncrementalSnapshot = 3] = "IncrementalSnapshot";
    eA[eA.Meta = 4] = "Meta";
    eA[eA.Custom = 5] = "Custom";
    eA[eA.Plugin = 6] = "Plugin";
    var eN = eA;
    (es = eB || {})[es.Mutation = 0] = "Mutation";
    es[es.MouseMove = 1] = "MouseMove";
    es[es.MouseInteraction = 2] = "MouseInteraction";
    es[es.Scroll = 3] = "Scroll";
    es[es.ViewportResize = 4] = "ViewportResize";
    es[es.Input = 5] = "Input";
    es[es.TouchMove = 6] = "TouchMove";
    es[es.MediaInteraction = 7] = "MediaInteraction";
    es[es.StyleSheetRule = 8] = "StyleSheetRule";
    es[es.CanvasMutation = 9] = "CanvasMutation";
    es[es.Font = 10] = "Font";
    es[es.Log = 11] = "Log";
    es[es.Drag = 12] = "Drag";
    es[es.StyleDeclaration = 13] = "StyleDeclaration";
    es[es.Selection = 14] = "Selection";
    es[es.AdoptedStyleSheet = 15] = "AdoptedStyleSheet";
    es[es.CustomElement = 16] = "CustomElement";
    var eB = es;
    (ec = ej || {})[ec.MouseUp = 0] = "MouseUp";
    ec[ec.MouseDown = 1] = "MouseDown";
    ec[ec.Click = 2] = "Click";
    ec[ec.ContextMenu = 3] = "ContextMenu";
    ec[ec.DblClick = 4] = "DblClick";
    ec[ec.Focus = 5] = "Focus";
    ec[ec.Blur = 6] = "Blur";
    ec[ec.TouchStart = 7] = "TouchStart";
    ec[ec.TouchMove_Departed = 8] = "TouchMove_Departed";
    ec[ec.TouchEnd = 9] = "TouchEnd";
    ec[ec.TouchCancel = 10] = "TouchCancel";
    var ej = ec;
    (el = eF || {})[el.Mouse = 0] = "Mouse";
    el[el.Pen = 1] = "Pen";
    el[el.Touch = 2] = "Touch";
    var eF = el;
    (eu = eU || {})[eu["2D"] = 0] = "2D";
    eu[eu.WebGL = 1] = "WebGL";
    eu[eu.WebGL2 = 2] = "WebGL2";
    var eU = eu;
    let DoubleLinkedList = class DoubleLinkedList {
      constructor() {
        this.length = 0;
        this.head = null;
        this.tail = null;
      }
      get(m) {
        if (m >= this.length) {
          throw Error("Position outside of list range");
        }
        let _ = this.head;
        for (let C = 0; C < m; C++) {
          _ = (_ == null ? undefined : _.next) || null;
        }
        return _;
      }
      addNode(m) {
        let _ = {
          value: m,
          previous: null,
          next: null
        };
        m.__ln = _;
        if (m.previousSibling && "__ln" in m.previousSibling) {
          let C = m.previousSibling.__ln.next;
          _.next = C;
          _.previous = m.previousSibling.__ln;
          m.previousSibling.__ln.next = _;
          if (C) {
            C.previous = _;
          }
        } else if (m.nextSibling && "__ln" in m.nextSibling && m.nextSibling.__ln.previous) {
          let C = m.nextSibling.__ln.previous;
          _.previous = C;
          _.next = m.nextSibling.__ln;
          m.nextSibling.__ln.previous = _;
          if (C) {
            C.next = _;
          }
        } else {
          if (this.head) {
            this.head.previous = _;
          }
          _.next = this.head;
          this.head = _;
        }
        if (_.next === null) {
          this.tail = _;
        }
        this.length++;
      }
      removeNode(m) {
        let _ = m.__ln;
        if (this.head) {
          if (_.previous) {
            _.previous.next = _.next;
            if (_.next) {
              _.next.previous = _.previous;
            } else {
              this.tail = _.previous;
            }
          } else {
            this.head = _.next;
            if (this.head) {
              this.head.previous = null;
            } else {
              this.tail = null;
            }
          }
          if (m.__ln) {
            delete m.__ln;
          }
          this.length--;
        }
      }
    };
    let moveKey = (m, _) => `${m}@${_}`;
    let MutationBuffer = class MutationBuffer {
      constructor() {
        this.frozen = false;
        this.locked = false;
        this.texts = [];
        this.attributes = [];
        this.attributeMap = new WeakMap();
        this.removes = [];
        this.mapRemoves = [];
        this.movedMap = {};
        this.addedSet = new Set();
        this.movedSet = new Set();
        this.droppedSet = new Set();
        this.processMutations = m => {
          m.forEach(this.processMutation);
          this.emit();
        };
        this.emit = () => {
          if (this.frozen || this.locked) {
            return;
          }
          let m = [];
          let _ = new Set();
          let C = new DoubleLinkedList();
          let getNextId = m => {
            let _ = m;
            let C = -2;
            while (C === -2) {
              C = (_ = _ && _.nextSibling) && this.mirror.getId(_);
            }
            return C;
          };
          let pushAdd = R => {
            if (!R.parentNode || !inDom(R) || R.parentNode.tagName === "TEXTAREA") {
              return;
            }
            let L = isShadowRoot(R.parentNode) ? this.mirror.getId(getShadowHost(R)) : this.mirror.getId(R.parentNode);
            let B = getNextId(R);
            if (L === -1 || B === -1) {
              return C.addNode(R);
            }
            let F = serializeNodeWithId(R, {
              doc: this.doc,
              mirror: this.mirror,
              blockClass: this.blockClass,
              blockSelector: this.blockSelector,
              maskTextClass: this.maskTextClass,
              maskTextSelector: this.maskTextSelector,
              skipChild: true,
              newlyAddedElement: true,
              inlineStylesheet: this.inlineStylesheet,
              maskInputOptions: this.maskInputOptions,
              maskTextFn: this.maskTextFn,
              maskInputFn: this.maskInputFn,
              slimDOMOptions: this.slimDOMOptions,
              dataURLOptions: this.dataURLOptions,
              recordCanvas: this.recordCanvas,
              inlineImages: this.inlineImages,
              onSerialize: m => {
                if (isSerializedIframe(m, this.mirror)) {
                  this.iframeManager.addIframe(m);
                }
                if (isSerializedStylesheet(m, this.mirror)) {
                  this.stylesheetManager.trackLinkElement(m);
                }
                if (hasShadowRoot(R)) {
                  this.shadowDomManager.addShadowRoot(R.shadowRoot, this.doc);
                }
              },
              onIframeLoad: (m, _) => {
                this.iframeManager.attachIframe(m, _);
                this.shadowDomManager.observeAttachShadow(m);
              },
              onStylesheetLoad: (m, _) => {
                this.stylesheetManager.attachLinkElement(m, _);
              }
            });
            if (F) {
              m.push({
                parentId: L,
                nextId: B,
                node: F
              });
              _.add(F.id);
            }
          };
          while (this.mapRemoves.length) {
            this.mirror.removeNodeFromMap(this.mapRemoves.shift());
          }
          for (let m of this.movedSet) {
            if (!isParentRemoved(this.removes, m, this.mirror) || this.movedSet.has(m.parentNode)) {
              pushAdd(m);
            }
          }
          for (let m of this.addedSet) {
            if (isAncestorInSet(this.droppedSet, m) || isParentRemoved(this.removes, m, this.mirror)) {
              if (isAncestorInSet(this.movedSet, m)) {
                pushAdd(m);
              } else {
                this.droppedSet.add(m);
              }
            } else {
              pushAdd(m);
            }
          }
          let R = null;
          while (C.length) {
            let m = null;
            if (R) {
              let _ = this.mirror.getId(R.value.parentNode);
              let C = getNextId(R.value);
              if (_ !== -1 && C !== -1) {
                m = R;
              }
            }
            if (!m) {
              let _ = C.tail;
              while (_) {
                let C = _;
                _ = _.previous;
                if (C) {
                  let _ = this.mirror.getId(C.value.parentNode);
                  let R = getNextId(C.value);
                  if (R === -1) {
                    continue;
                  }
                  if (_ !== -1) {
                    m = C;
                    break;
                  }
                  {
                    let _ = C.value;
                    if (_.parentNode && _.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      let R = _.parentNode.host;
                      let L = this.mirror.getId(R);
                      if (L !== -1) {
                        m = C;
                        break;
                      }
                    }
                  }
                }
              }
            }
            if (!m) {
              while (C.head) {
                C.removeNode(C.head.value);
              }
              break;
            }
            R = m.previous;
            C.removeNode(m.value);
            pushAdd(m.value);
          }
          let L = {
            texts: this.texts.map(m => {
              let _ = m.node;
              if (_.parentNode && _.parentNode.tagName === "TEXTAREA") {
                this.genTextAreaValueMutation(_.parentNode);
              }
              return {
                id: this.mirror.getId(_),
                value: m.value
              };
            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
            attributes: this.attributes.map(m => {
              let {
                attributes: _
              } = m;
              if (typeof _.style == "string") {
                let C = JSON.stringify(m.styleDiff);
                let R = JSON.stringify(m._unchangedStyles);
                if (C.length < _.style.length && (C + R).split("var(").length === _.style.split("var(").length) {
                  _.style = m.styleDiff;
                }
              }
              return {
                id: this.mirror.getId(m.node),
                attributes: _
              };
            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
            removes: this.removes,
            adds: m
          };
          if (L.texts.length || L.attributes.length || L.removes.length || L.adds.length) {
            this.texts = [];
            this.attributes = [];
            this.attributeMap = new WeakMap();
            this.removes = [];
            this.addedSet = new Set();
            this.movedSet = new Set();
            this.droppedSet = new Set();
            this.movedMap = {};
            this.mutationCb(L);
          }
        };
        this.genTextAreaValueMutation = m => {
          let _ = this.attributeMap.get(m);
          if (!_) {
            _ = {
              node: m,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(_);
            this.attributeMap.set(m, _);
          }
          _.attributes.value = Array.from(m.childNodes, m => m.textContent || "").join("");
        };
        this.processMutation = m => {
          if (!isIgnored(m.target, this.mirror)) {
            switch (m.type) {
              case "characterData":
                {
                  let _ = m.target.textContent;
                  if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && _ !== m.oldValue) {
                    this.texts.push({
                      value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && _ ? this.maskTextFn ? this.maskTextFn(_, closestElementOfNode(m.target)) : _.replace(/[\S]/g, "*") : _,
                      node: m.target
                    });
                  }
                  break;
                }
              case "attributes":
                {
                  let _ = m.target;
                  let C = m.attributeName;
                  let R = m.target.getAttribute(C);
                  if (C === "value") {
                    let m = getInputType(_);
                    R = maskInputValue({
                      element: _,
                      maskInputOptions: this.maskInputOptions,
                      tagName: _.tagName,
                      type: m,
                      value: R,
                      maskInputFn: this.maskInputFn
                    });
                  }
                  if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || R === m.oldValue) {
                    return;
                  }
                  let L = this.attributeMap.get(m.target);
                  if (_.tagName === "IFRAME" && C === "src" && !this.keepIframeSrcFn(R)) {
                    if (_.contentDocument) {
                      return;
                    }
                    C = "rr_src";
                  }
                  if (!L) {
                    L = {
                      node: m.target,
                      attributes: {},
                      styleDiff: {},
                      _unchangedStyles: {}
                    };
                    this.attributes.push(L);
                    this.attributeMap.set(m.target, L);
                  }
                  if (C === "type" && _.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
                    _.setAttribute("data-rr-is-password", "true");
                  }
                  if (!ignoreAttribute(_.tagName, C) && (L.attributes[C] = transformAttribute(this.doc, toLowerCase(_.tagName), toLowerCase(C), R), C === "style")) {
                    if (!this.unattachedDoc) {
                      try {
                        this.unattachedDoc = document.implementation.createHTMLDocument();
                      } catch (m) {
                        this.unattachedDoc = this.doc;
                      }
                    }
                    let C = this.unattachedDoc.createElement("span");
                    if (m.oldValue) {
                      C.setAttribute("style", m.oldValue);
                    }
                    for (let R of Array.from(_.style)) {
                      let m = _.style.getPropertyValue(R);
                      let B = _.style.getPropertyPriority(R);
                      if (m !== C.style.getPropertyValue(R) || B !== C.style.getPropertyPriority(R)) {
                        if (B === "") {
                          L.styleDiff[R] = m;
                        } else {
                          L.styleDiff[R] = [m, B];
                        }
                      } else {
                        L._unchangedStyles[R] = [m, B];
                      }
                    }
                    for (let m of Array.from(C.style)) {
                      if (_.style.getPropertyValue(m) === "") {
                        L.styleDiff[m] = false;
                      }
                    }
                  }
                  break;
                }
              case "childList":
                if (isBlocked(m.target, this.blockClass, this.blockSelector, true)) {
                  return;
                }
                if (m.target.tagName === "TEXTAREA") {
                  this.genTextAreaValueMutation(m.target);
                  return;
                }
                m.addedNodes.forEach(_ => this.genAdds(_, m.target));
                m.removedNodes.forEach(_ => {
                  let C = this.mirror.getId(_);
                  let R = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
                  if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && !isIgnored(_, this.mirror) && this.mirror.getId(_) !== -1) {
                    if (this.addedSet.has(_)) {
                      deepDelete(this.addedSet, _);
                      this.droppedSet.add(_);
                    } else if ((!this.addedSet.has(m.target) || C !== -1) && !function isAncestorRemoved(m, _) {
                      if (isShadowRoot(m)) {
                        return false;
                      }
                      let C = _.getId(m);
                      return !_.has(C) || (!m.parentNode || m.parentNode.nodeType !== m.DOCUMENT_NODE) && (!m.parentNode || isAncestorRemoved(m.parentNode, _));
                    }(m.target, this.mirror)) {
                      if (this.movedSet.has(_) && this.movedMap[moveKey(C, R)]) {
                        deepDelete(this.movedSet, _);
                      } else {
                        this.removes.push({
                          parentId: R,
                          id: C,
                          isShadow: !!isShadowRoot(m.target) && !!isNativeShadowDom(m.target) || undefined
                        });
                      }
                    }
                    this.mapRemoves.push(_);
                  }
                });
            }
          }
        };
        this.genAdds = (m, _) => {
          if (!this.processedNodeManager.inOtherBuffer(m, this) && !this.addedSet.has(m) && !this.movedSet.has(m)) {
            if (this.mirror.hasNode(m)) {
              if (isIgnored(m, this.mirror)) {
                return;
              }
              this.movedSet.add(m);
              let C = null;
              if (_ && this.mirror.hasNode(_)) {
                C = this.mirror.getId(_);
              }
              if (C && C !== -1) {
                this.movedMap[moveKey(this.mirror.getId(m), C)] = true;
              }
            } else {
              this.addedSet.add(m);
              this.droppedSet.delete(m);
            }
            if (!isBlocked(m, this.blockClass, this.blockSelector, false)) {
              m.childNodes.forEach(m => this.genAdds(m));
              if (hasShadowRoot(m)) {
                m.shadowRoot.childNodes.forEach(_ => {
                  this.processedNodeManager.add(_, this);
                  this.genAdds(_, m);
                });
              }
            }
          }
        };
      }
      init(m) {
        ["mutationCb", "blockClass", "blockSelector", "maskTextClass", "maskTextSelector", "inlineStylesheet", "maskInputOptions", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(_ => {
          this[_] = m[_];
        });
      }
      freeze() {
        this.frozen = true;
        this.canvasManager.freeze();
      }
      unfreeze() {
        this.frozen = false;
        this.canvasManager.unfreeze();
        this.emit();
      }
      isFrozen() {
        return this.frozen;
      }
      lock() {
        this.locked = true;
        this.canvasManager.lock();
      }
      unlock() {
        this.locked = false;
        this.canvasManager.unlock();
        this.emit();
      }
      reset() {
        this.shadowDomManager.reset();
        this.canvasManager.reset();
      }
    };
    function deepDelete(m, _) {
      m.delete(_);
      _.childNodes.forEach(_ => deepDelete(m, _));
    }
    function isParentRemoved(m, _, C) {
      return m.length !== 0 && function _isParentRemoved(m, _, C) {
        let {
          parentNode: R
        } = _;
        if (!R) {
          return false;
        }
        let L = C.getId(R);
        return !!m.some(m => m.id === L) || _isParentRemoved(m, R, C);
      }(m, _, C);
    }
    function isAncestorInSet(m, _) {
      return m.size !== 0 && function _isAncestorInSet(m, _) {
        let {
          parentNode: C
        } = _;
        return !!C && (!!m.has(C) || _isAncestorInSet(m, C));
      }(m, _);
    }
    let callbackWrapper = m => B ? (..._) => {
      try {
        return m(..._);
      } catch (m) {
        if (B && B(m) === true) {
          return;
        }
        throw m;
      }
    } : m;
    let eH = [];
    function getEventTarget(m) {
      try {
        if ("composedPath" in m) {
          let _ = m.composedPath();
          if (_.length) {
            return _[0];
          }
        } else if ("path" in m && m.path.length) {
          return m.path[0];
        }
      } catch (m) {}
      return m && m.target;
    }
    function initMutationObserver(m, _) {
      var C;
      var R;
      let L = new MutationBuffer();
      eH.push(L);
      L.init(m);
      let B = window.MutationObserver || window.__rrMutationObserver;
      let F = (R = (C = window == null ? undefined : window.Zone) === null || C === undefined ? undefined : C.__symbol__) === null || R === undefined ? undefined : R.call(C, "MutationObserver");
      if (F && window[F]) {
        B = window[F];
      }
      let U = new B(callbackWrapper(L.processMutations.bind(L)));
      U.observe(_, {
        attributes: true,
        attributeOldValue: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true
      });
      return U;
    }
    function initScrollObserver({
      scrollCb: m,
      doc: _,
      mirror: C,
      blockClass: R,
      blockSelector: L,
      sampling: B
    }) {
      let F = callbackWrapper(throttle(callbackWrapper(B => {
        let F = getEventTarget(B);
        if (!F || isBlocked(F, R, L, true)) {
          return;
        }
        let U = C.getId(F);
        if (F === _ && _.defaultView) {
          let C = getWindowScroll(_.defaultView);
          m({
            id: U,
            x: C.left,
            y: C.top
          });
        } else {
          m({
            id: U,
            x: F.scrollLeft,
            y: F.scrollTop
          });
        }
      }), B.scroll || 100));
      return on("scroll", F, _);
    }
    let eW = ["INPUT", "TEXTAREA", "SELECT"];
    let e$ = new WeakMap();
    function getNestedCSSRulePositions(m) {
      return function (m, _) {
        if (hasNestedCSSRule("CSSGroupingRule") && m.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && m.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && m.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && m.parentRule instanceof CSSConditionRule) {
          let C = Array.from(m.parentRule.cssRules);
          let R = C.indexOf(m);
          _.unshift(R);
        } else if (m.parentStyleSheet) {
          let C = Array.from(m.parentStyleSheet.cssRules);
          let R = C.indexOf(m);
          _.unshift(R);
        }
        return _;
      }(m, []);
    }
    function getIdAndStyleId(m, _, C) {
      let R;
      let L;
      if (m) {
        if (m.ownerNode) {
          R = _.getId(m.ownerNode);
        } else {
          L = C.getId(m);
        }
        return {
          styleId: L,
          id: R
        };
      } else {
        return {};
      }
    }
    function initAdoptedStyleSheetObserver({
      mirror: m,
      stylesheetManager: _
    }, C) {
      let F = null;
      F = C.nodeName === "#document" ? m.getId(C) : m.getId(C.host);
      let U = C.nodeName === "#document" ? C.defaultView?.Document : C.ownerDocument?.defaultView?.ShadowRoot;
      let H = (U == null ? undefined : U.prototype) ? Object.getOwnPropertyDescriptor(U == null ? undefined : U.prototype, "adoptedStyleSheets") : undefined;
      if (F !== null && F !== -1 && U && H) {
        Object.defineProperty(C, "adoptedStyleSheets", {
          configurable: H.configurable,
          enumerable: H.enumerable,
          get() {
            var m;
            if ((m = H.get) === null || m === undefined) {
              return undefined;
            } else {
              return m.call(this);
            }
          },
          set(m) {
            var C;
            let R = (C = H.set) === null || C === undefined ? undefined : C.call(this, m);
            if (F !== null && F !== -1) {
              try {
                _.adoptStyleSheets(m, F);
              } catch (m) {}
            }
            return R;
          }
        });
        return callbackWrapper(() => {
          Object.defineProperty(C, "adoptedStyleSheets", {
            configurable: H.configurable,
            enumerable: H.enumerable,
            get: H.get,
            set: H.set
          });
        });
      } else {
        return () => {};
      }
    }
    function initObservers(m, _ = {}) {
      let C;
      let R = m.doc.defaultView;
      if (!R) {
        return () => {};
      }
      (function (m, _) {
        let {
          mutationCb: C,
          mousemoveCb: R,
          mouseInteractionCb: L,
          scrollCb: B,
          viewportResizeCb: F,
          inputCb: U,
          mediaInteractionCb: H,
          styleSheetRuleCb: q,
          styleDeclarationCb: V,
          canvasMutationCb: X,
          fontCb: K,
          selectionCb: Y,
          customElementCb: Q
        } = m;
        m.mutationCb = (...m) => {
          if (_.mutation) {
            _.mutation(...m);
          }
          C(...m);
        };
        m.mousemoveCb = (...m) => {
          if (_.mousemove) {
            _.mousemove(...m);
          }
          R(...m);
        };
        m.mouseInteractionCb = (...m) => {
          if (_.mouseInteraction) {
            _.mouseInteraction(...m);
          }
          L(...m);
        };
        m.scrollCb = (...m) => {
          if (_.scroll) {
            _.scroll(...m);
          }
          B(...m);
        };
        m.viewportResizeCb = (...m) => {
          if (_.viewportResize) {
            _.viewportResize(...m);
          }
          F(...m);
        };
        m.inputCb = (...m) => {
          if (_.input) {
            _.input(...m);
          }
          U(...m);
        };
        m.mediaInteractionCb = (...m) => {
          if (_.mediaInteaction) {
            _.mediaInteaction(...m);
          }
          H(...m);
        };
        m.styleSheetRuleCb = (...m) => {
          if (_.styleSheetRule) {
            _.styleSheetRule(...m);
          }
          q(...m);
        };
        m.styleDeclarationCb = (...m) => {
          if (_.styleDeclaration) {
            _.styleDeclaration(...m);
          }
          V(...m);
        };
        m.canvasMutationCb = (...m) => {
          if (_.canvasMutation) {
            _.canvasMutation(...m);
          }
          X(...m);
        };
        m.fontCb = (...m) => {
          if (_.font) {
            _.font(...m);
          }
          K(...m);
        };
        m.selectionCb = (...m) => {
          if (_.selection) {
            _.selection(...m);
          }
          Y(...m);
        };
        m.customElementCb = (...m) => {
          if (_.customElement) {
            _.customElement(...m);
          }
          Q(...m);
        };
      })(m, _);
      if (m.recordDOM) {
        C = initMutationObserver(m, m.doc);
      }
      let L = function ({
        mousemoveCb: m,
        sampling: _,
        doc: C,
        mirror: R
      }) {
        let L;
        if (_.mousemove === false) {
          return () => {};
        }
        let B = typeof _.mousemove == "number" ? _.mousemove : 50;
        let F = typeof _.mousemoveCallback == "number" ? _.mousemoveCallback : 500;
        let U = [];
        let H = throttle(callbackWrapper(_ => {
          let C = Date.now() - L;
          m(U.map(m => {
            m.timeOffset -= C;
            return m;
          }), _);
          U = [];
          L = null;
        }), F);
        let q = callbackWrapper(throttle(callbackWrapper(m => {
          let _ = getEventTarget(m);
          let {
            clientX: C,
            clientY: B
          } = legacy_isTouchEvent(m) ? m.changedTouches[0] : m;
          L ||= ea();
          U.push({
            x: C,
            y: B,
            id: R.getId(_),
            timeOffset: ea() - L
          });
          H(typeof DragEvent != "undefined" && m instanceof DragEvent ? eB.Drag : m instanceof MouseEvent ? eB.MouseMove : eB.TouchMove);
        }), B, {
          trailing: false
        }));
        let V = [on("mousemove", q, C), on("touchmove", q, C), on("drag", q, C)];
        return callbackWrapper(() => {
          V.forEach(m => m());
        });
      }(m);
      let B = function ({
        mouseInteractionCb: m,
        doc: _,
        mirror: C,
        blockClass: R,
        blockSelector: L,
        sampling: B
      }) {
        if (B.mouseInteraction === false) {
          return () => {};
        }
        let F = B.mouseInteraction === true || B.mouseInteraction === undefined ? {} : B.mouseInteraction;
        let U = [];
        let H = null;
        let getHandler = _ => B => {
          let F = getEventTarget(B);
          if (isBlocked(F, R, L, true)) {
            return;
          }
          let U = null;
          let q = _;
          if ("pointerType" in B) {
            switch (B.pointerType) {
              case "mouse":
                U = eF.Mouse;
                break;
              case "touch":
                U = eF.Touch;
                break;
              case "pen":
                U = eF.Pen;
            }
            if (U === eF.Touch) {
              if (ej[_] === ej.MouseDown) {
                q = "TouchStart";
              } else if (ej[_] === ej.MouseUp) {
                q = "TouchEnd";
              }
            } else {
              eF.Pen;
            }
          } else if (legacy_isTouchEvent(B)) {
            U = eF.Touch;
          }
          if (U !== null) {
            H = U;
            if (q.startsWith("Touch") && U === eF.Touch || q.startsWith("Mouse") && U === eF.Mouse) {
              U = null;
            }
          } else if (ej[_] === ej.Click) {
            U = H;
            H = null;
          }
          let V = legacy_isTouchEvent(B) ? B.changedTouches[0] : B;
          if (!V) {
            return;
          }
          let X = C.getId(F);
          let {
            clientX: K,
            clientY: Y
          } = V;
          callbackWrapper(m)(Object.assign({
            type: ej[q],
            id: X,
            x: K,
            y: Y
          }, U !== null && {
            pointerType: U
          }));
        };
        Object.keys(ej).filter(m => Number.isNaN(Number(m)) && !m.endsWith("_Departed") && F[m] !== false).forEach(m => {
          let C = toLowerCase(m);
          let R = getHandler(m);
          if (window.PointerEvent) {
            switch (ej[m]) {
              case ej.MouseDown:
              case ej.MouseUp:
                C = C.replace("mouse", "pointer");
                break;
              case ej.TouchStart:
              case ej.TouchEnd:
                return;
            }
          }
          U.push(on(C, R, _));
        });
        return callbackWrapper(() => {
          U.forEach(m => m());
        });
      }(m);
      let F = initScrollObserver(m);
      let U = function ({
        viewportResizeCb: m
      }, {
        win: _
      }) {
        let C = -1;
        let R = -1;
        let L = callbackWrapper(throttle(callbackWrapper(() => {
          let _ = getWindowHeight();
          let L = getWindowWidth();
          if (C !== _ || R !== L) {
            m({
              width: Number(L),
              height: Number(_)
            });
            C = _;
            R = L;
          }
        }), 200));
        return on("resize", L, _);
      }(m, {
        win: R
      });
      let H = function ({
        inputCb: m,
        doc: _,
        mirror: C,
        blockClass: R,
        blockSelector: L,
        ignoreClass: B,
        ignoreSelector: F,
        maskInputOptions: U,
        maskInputFn: H,
        sampling: q,
        userTriggeredOnInput: V
      }) {
        function eventHandler(m) {
          let C = getEventTarget(m);
          let q = m.isTrusted;
          let X = C && C.tagName;
          if (C && X === "OPTION") {
            C = C.parentElement;
          }
          if (!C || !X || eW.indexOf(X) < 0 || isBlocked(C, R, L, true) || C.classList.contains(B) || F && C.matches(F)) {
            return;
          }
          let K = C.value;
          let Y = false;
          let Q = getInputType(C) || "";
          if (Q === "radio" || Q === "checkbox") {
            Y = C.checked;
          } else if (U[X.toLowerCase()] || U[Q]) {
            K = maskInputValue({
              element: C,
              maskInputOptions: U,
              tagName: X,
              type: Q,
              value: K,
              maskInputFn: H
            });
          }
          cbWithDedup(C, V ? {
            text: K,
            isChecked: Y,
            userTriggered: q
          } : {
            text: K,
            isChecked: Y
          });
          let et = C.name;
          if (Q === "radio" && et && Y) {
            _.querySelectorAll(`input[type="radio"][name="${et}"]`).forEach(m => {
              if (m !== C) {
                let _ = m.value;
                cbWithDedup(m, V ? {
                  text: _,
                  isChecked: !Y,
                  userTriggered: false
                } : {
                  text: _,
                  isChecked: !Y
                });
              }
            });
          }
        }
        function cbWithDedup(_, R) {
          let L = e$.get(_);
          if (!L || L.text !== R.text || L.isChecked !== R.isChecked) {
            e$.set(_, R);
            let L = C.getId(_);
            callbackWrapper(m)(Object.assign(Object.assign({}, R), {
              id: L
            }));
          }
        }
        let X = q.input === "last" ? ["change"] : ["input", "change"];
        let K = X.map(m => on(m, callbackWrapper(eventHandler), _));
        let Y = _.defaultView;
        if (!Y) {
          return () => {
            K.forEach(m => m());
          };
        }
        let Q = Y.Object.getOwnPropertyDescriptor(Y.HTMLInputElement.prototype, "value");
        let et = [[Y.HTMLInputElement.prototype, "value"], [Y.HTMLInputElement.prototype, "checked"], [Y.HTMLSelectElement.prototype, "value"], [Y.HTMLTextAreaElement.prototype, "value"], [Y.HTMLSelectElement.prototype, "selectedIndex"], [Y.HTMLOptionElement.prototype, "selected"]];
        if (Q && Q.set) {
          K.push(...et.map(m => hookSetter(m[0], m[1], {
            set() {
              callbackWrapper(eventHandler)({
                target: this,
                isTrusted: false
              });
            }
          }, false, Y)));
        }
        return callbackWrapper(() => {
          K.forEach(m => m());
        });
      }(m);
      let q = function ({
        mediaInteractionCb: m,
        blockClass: _,
        blockSelector: C,
        mirror: R,
        sampling: L,
        doc: B
      }) {
        let F = callbackWrapper(B => throttle(callbackWrapper(L => {
          let F = getEventTarget(L);
          if (!F || isBlocked(F, _, C, true)) {
            return;
          }
          let {
            currentTime: U,
            volume: H,
            muted: q,
            playbackRate: V,
            loop: X
          } = F;
          m({
            type: B,
            id: R.getId(F),
            currentTime: U,
            volume: H,
            muted: q,
            playbackRate: V,
            loop: X
          });
        }), L.media || 500));
        let U = [on("play", F(0), B), on("pause", F(1), B), on("seeked", F(2), B), on("volumechange", F(3), B), on("ratechange", F(4), B)];
        return callbackWrapper(() => {
          U.forEach(m => m());
        });
      }(m);
      let styleSheetObserver = () => {};
      let adoptedStyleSheetObserver = () => {};
      let styleDeclarationObserver = () => {};
      let fontObserver = () => {};
      if (m.recordDOM) {
        styleSheetObserver = function ({
          styleSheetRuleCb: m,
          mirror: _,
          stylesheetManager: C
        }, {
          win: R
        }) {
          let L;
          let B;
          if (!R.CSSStyleSheet || !R.CSSStyleSheet.prototype) {
            return () => {};
          }
          let F = R.CSSStyleSheet.prototype.insertRule;
          R.CSSStyleSheet.prototype.insertRule = new Proxy(F, {
            apply: callbackWrapper((R, L, B) => {
              let [F, U] = B;
              let {
                id: H,
                styleId: q
              } = getIdAndStyleId(L, _, C.styleMirror);
              if (H && H !== -1 || q && q !== -1) {
                m({
                  id: H,
                  styleId: q,
                  adds: [{
                    rule: F,
                    index: U
                  }]
                });
              }
              return R.apply(L, B);
            })
          });
          let U = R.CSSStyleSheet.prototype.deleteRule;
          R.CSSStyleSheet.prototype.deleteRule = new Proxy(U, {
            apply: callbackWrapper((R, L, B) => {
              let [F] = B;
              let {
                id: U,
                styleId: H
              } = getIdAndStyleId(L, _, C.styleMirror);
              if (U && U !== -1 || H && H !== -1) {
                m({
                  id: U,
                  styleId: H,
                  removes: [{
                    index: F
                  }]
                });
              }
              return R.apply(L, B);
            })
          });
          if (R.CSSStyleSheet.prototype.replace) {
            L = R.CSSStyleSheet.prototype.replace;
            R.CSSStyleSheet.prototype.replace = new Proxy(L, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    replace: F
                  });
                }
                return R.apply(L, B);
              })
            });
          }
          if (R.CSSStyleSheet.prototype.replaceSync) {
            B = R.CSSStyleSheet.prototype.replaceSync;
            R.CSSStyleSheet.prototype.replaceSync = new Proxy(B, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    replaceSync: F
                  });
                }
                return R.apply(L, B);
              })
            });
          }
          let H = {};
          if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
            H.CSSGroupingRule = R.CSSGroupingRule;
          } else {
            if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
              H.CSSMediaRule = R.CSSMediaRule;
            }
            if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
              H.CSSConditionRule = R.CSSConditionRule;
            }
            if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
              H.CSSSupportsRule = R.CSSSupportsRule;
            }
          }
          let q = {};
          Object.entries(H).forEach(([R, L]) => {
            q[R] = {
              insertRule: L.prototype.insertRule,
              deleteRule: L.prototype.deleteRule
            };
            L.prototype.insertRule = new Proxy(q[R].insertRule, {
              apply: callbackWrapper((R, L, B) => {
                let [F, U] = B;
                let {
                  id: H,
                  styleId: q
                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                if (H && H !== -1 || q && q !== -1) {
                  m({
                    id: H,
                    styleId: q,
                    adds: [{
                      rule: F,
                      index: [...getNestedCSSRulePositions(L), U || 0]
                    }]
                  });
                }
                return R.apply(L, B);
              })
            });
            L.prototype.deleteRule = new Proxy(q[R].deleteRule, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    removes: [{
                      index: [...getNestedCSSRulePositions(L), F]
                    }]
                  });
                }
                return R.apply(L, B);
              })
            });
          });
          return callbackWrapper(() => {
            R.CSSStyleSheet.prototype.insertRule = F;
            R.CSSStyleSheet.prototype.deleteRule = U;
            if (L) {
              R.CSSStyleSheet.prototype.replace = L;
            }
            if (B) {
              R.CSSStyleSheet.prototype.replaceSync = B;
            }
            Object.entries(H).forEach(([m, _]) => {
              _.prototype.insertRule = q[m].insertRule;
              _.prototype.deleteRule = q[m].deleteRule;
            });
          });
        }(m, {
          win: R
        });
        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(m, m.doc);
        styleDeclarationObserver = function ({
          styleDeclarationCb: m,
          mirror: _,
          ignoreCSSAttributes: C,
          stylesheetManager: R
        }, {
          win: L
        }) {
          let B = L.CSSStyleDeclaration.prototype.setProperty;
          L.CSSStyleDeclaration.prototype.setProperty = new Proxy(B, {
            apply: callbackWrapper((L, F, U) => {
              let [q, V, X] = U;
              if (C.has(q)) {
                return B.apply(F, [q, V, X]);
              }
              let {
                id: K,
                styleId: Y
              } = getIdAndStyleId(F.parentRule?.parentStyleSheet, _, R.styleMirror);
              if (K && K !== -1 || Y && Y !== -1) {
                m({
                  id: K,
                  styleId: Y,
                  set: {
                    property: q,
                    value: V,
                    priority: X
                  },
                  index: getNestedCSSRulePositions(F.parentRule)
                });
              }
              return L.apply(F, U);
            })
          });
          let F = L.CSSStyleDeclaration.prototype.removeProperty;
          L.CSSStyleDeclaration.prototype.removeProperty = new Proxy(F, {
            apply: callbackWrapper((L, B, U) => {
              let [q] = U;
              if (C.has(q)) {
                return F.apply(B, [q]);
              }
              let {
                id: V,
                styleId: X
              } = getIdAndStyleId(B.parentRule?.parentStyleSheet, _, R.styleMirror);
              if (V && V !== -1 || X && X !== -1) {
                m({
                  id: V,
                  styleId: X,
                  remove: {
                    property: q
                  },
                  index: getNestedCSSRulePositions(B.parentRule)
                });
              }
              return L.apply(B, U);
            })
          });
          return callbackWrapper(() => {
            L.CSSStyleDeclaration.prototype.setProperty = B;
            L.CSSStyleDeclaration.prototype.removeProperty = F;
          });
        }(m, {
          win: R
        });
        if (m.collectFonts) {
          fontObserver = function ({
            fontCb: m,
            doc: _
          }) {
            let C = _.defaultView;
            if (!C) {
              return () => {};
            }
            let R = [];
            let L = new WeakMap();
            let B = C.FontFace;
            C.FontFace = function (m, _, C) {
              let R = new B(m, _, C);
              L.set(R, {
                family: m,
                buffer: typeof _ != "string",
                descriptors: C,
                fontSource: typeof _ == "string" ? _ : JSON.stringify(Array.from(new Uint8Array(_)))
              });
              return R;
            };
            let F = patch(_.fonts, "add", function (_) {
              return function (C) {
                setTimeout(callbackWrapper(() => {
                  let _ = L.get(C);
                  if (_) {
                    m(_);
                    L.delete(C);
                  }
                }), 0);
                return _.apply(this, [C]);
              };
            });
            R.push(() => {
              C.FontFace = B;
            });
            R.push(F);
            return callbackWrapper(() => {
              R.forEach(m => m());
            });
          }(m);
        }
      }
      let V = function (m) {
        let {
          doc: _,
          mirror: C,
          blockClass: R,
          blockSelector: L,
          selectionCb: B
        } = m;
        let F = true;
        let U = callbackWrapper(() => {
          let m = _.getSelection();
          if (!m || F && (m == null ? undefined : m.isCollapsed)) {
            return;
          }
          F = m.isCollapsed || false;
          let U = [];
          let H = m.rangeCount || 0;
          for (let _ = 0; _ < H; _++) {
            let B = m.getRangeAt(_);
            let {
              startContainer: F,
              startOffset: H,
              endContainer: q,
              endOffset: V
            } = B;
            let X = isBlocked(F, R, L, true) || isBlocked(q, R, L, true);
            if (!X) {
              U.push({
                start: C.getId(F),
                startOffset: H,
                end: C.getId(q),
                endOffset: V
              });
            }
          }
          B({
            ranges: U
          });
        });
        U();
        return on("selectionchange", U);
      }(m);
      let X = function ({
        doc: m,
        customElementCb: _
      }) {
        let C = m.defaultView;
        if (!C || !C.customElements) {
          return () => {};
        }
        let R = patch(C.customElements, "define", function (m) {
          return function (C, R, L) {
            try {
              _({
                define: {
                  name: C
                }
              });
            } catch (m) {
              console.warn(`Custom element callback failed for ${C}`);
            }
            return m.apply(this, [C, R, L]);
          };
        });
        return R;
      }(m);
      let K = [];
      for (let _ of m.plugins) {
        K.push(_.observer(_.callback, R, _.options));
      }
      return callbackWrapper(() => {
        eH.forEach(m => m.reset());
        if (C != null) {
          C.disconnect();
        }
        L();
        B();
        F();
        U();
        H();
        q();
        styleSheetObserver();
        adoptedStyleSheetObserver();
        styleDeclarationObserver();
        fontObserver();
        V();
        X();
        K.forEach(m => m());
      });
    }
    function hasNestedCSSRule(m) {
      return window[m] !== undefined;
    }
    function canMonkeyPatchNestedCSSRule(m) {
      return window[m] !== undefined && !!window[m].prototype && !!("insertRule" in window[m].prototype) && !!("deleteRule" in window[m].prototype);
    }
    let CrossOriginIframeMirror = class CrossOriginIframeMirror {
      constructor(m) {
        this.generateIdFn = m;
        this.iframeIdToRemoteIdMap = new WeakMap();
        this.iframeRemoteIdToIdMap = new WeakMap();
      }
      getId(m, _, C, R) {
        let L = C || this.getIdToRemoteIdMap(m);
        let B = R || this.getRemoteIdToIdMap(m);
        let F = L.get(_);
        if (!F) {
          F = this.generateIdFn();
          L.set(_, F);
          B.set(F, _);
        }
        return F;
      }
      getIds(m, _) {
        let C = this.getIdToRemoteIdMap(m);
        let R = this.getRemoteIdToIdMap(m);
        return _.map(_ => this.getId(m, _, C, R));
      }
      getRemoteId(m, _, C) {
        let R = C || this.getRemoteIdToIdMap(m);
        if (typeof _ != "number") {
          return _;
        }
        let L = R.get(_);
        return L || -1;
      }
      getRemoteIds(m, _) {
        let C = this.getRemoteIdToIdMap(m);
        return _.map(_ => this.getRemoteId(m, _, C));
      }
      reset(m) {
        if (!m) {
          this.iframeIdToRemoteIdMap = new WeakMap();
          this.iframeRemoteIdToIdMap = new WeakMap();
          return;
        }
        this.iframeIdToRemoteIdMap.delete(m);
        this.iframeRemoteIdToIdMap.delete(m);
      }
      getIdToRemoteIdMap(m) {
        let _ = this.iframeIdToRemoteIdMap.get(m);
        if (!_) {
          _ = new Map();
          this.iframeIdToRemoteIdMap.set(m, _);
        }
        return _;
      }
      getRemoteIdToIdMap(m) {
        let _ = this.iframeRemoteIdToIdMap.get(m);
        if (!_) {
          _ = new Map();
          this.iframeRemoteIdToIdMap.set(m, _);
        }
        return _;
      }
    };
    let IframeManager = class IframeManager {
      constructor(m) {
        this.iframes = new WeakMap();
        this.crossOriginIframeMap = new WeakMap();
        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
        this.crossOriginIframeRootIdMap = new WeakMap();
        this.mutationCb = m.mutationCb;
        this.wrappedEmit = m.wrappedEmit;
        this.stylesheetManager = m.stylesheetManager;
        this.recordCrossOriginIframes = m.recordCrossOriginIframes;
        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));
        this.mirror = m.mirror;
        if (this.recordCrossOriginIframes) {
          window.addEventListener("message", this.handleMessage.bind(this));
        }
      }
      addIframe(m) {
        this.iframes.set(m, true);
        if (m.contentWindow) {
          this.crossOriginIframeMap.set(m.contentWindow, m);
        }
      }
      addLoadListener(m) {
        this.loadListener = m;
      }
      attachIframe(m, _) {
        var C;
        this.mutationCb({
          adds: [{
            parentId: this.mirror.getId(m),
            nextId: null,
            node: _
          }],
          removes: [],
          texts: [],
          attributes: [],
          isAttachIframe: true
        });
        if ((C = this.loadListener) !== null && C !== undefined) {
          C.call(this, m);
        }
        if (m.contentDocument && m.contentDocument.adoptedStyleSheets && m.contentDocument.adoptedStyleSheets.length > 0) {
          this.stylesheetManager.adoptStyleSheets(m.contentDocument.adoptedStyleSheets, this.mirror.getId(m.contentDocument));
        }
      }
      handleMessage(m) {
        if (m.data.type !== "rrweb" || m.origin !== m.data.origin) {
          return;
        }
        let _ = m.source;
        if (!_) {
          return;
        }
        let C = this.crossOriginIframeMap.get(m.source);
        if (!C) {
          return;
        }
        let R = this.transformCrossOriginEvent(C, m.data.event);
        if (R) {
          this.wrappedEmit(R, m.data.isCheckout);
        }
      }
      transformCrossOriginEvent(m, _) {
        var C;
        switch (_.type) {
          case eN.FullSnapshot:
            {
              this.crossOriginIframeMirror.reset(m);
              this.crossOriginIframeStyleMirror.reset(m);
              this.replaceIdOnNode(_.data.node, m);
              let C = _.data.node.id;
              this.crossOriginIframeRootIdMap.set(m, C);
              this.patchRootIdOnNode(_.data.node, C);
              return {
                timestamp: _.timestamp,
                type: eN.IncrementalSnapshot,
                data: {
                  source: eB.Mutation,
                  adds: [{
                    parentId: this.mirror.getId(m),
                    nextId: null,
                    node: _.data.node
                  }],
                  removes: [],
                  texts: [],
                  attributes: [],
                  isAttachIframe: true
                }
              };
            }
          case eN.Meta:
          case eN.Load:
          case eN.DomContentLoaded:
            break;
          case eN.Plugin:
            return _;
          case eN.Custom:
            this.replaceIds(_.data.payload, m, ["id", "parentId", "previousId", "nextId"]);
            return _;
          case eN.IncrementalSnapshot:
            switch (_.data.source) {
              case eB.Mutation:
                _.data.adds.forEach(_ => {
                  this.replaceIds(_, m, ["parentId", "nextId", "previousId"]);
                  this.replaceIdOnNode(_.node, m);
                  let C = this.crossOriginIframeRootIdMap.get(m);
                  if (C) {
                    this.patchRootIdOnNode(_.node, C);
                  }
                });
                _.data.removes.forEach(_ => {
                  this.replaceIds(_, m, ["parentId", "id"]);
                });
                _.data.attributes.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                _.data.texts.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                return _;
              case eB.Drag:
              case eB.TouchMove:
              case eB.MouseMove:
                _.data.positions.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                return _;
              case eB.ViewportResize:
                return false;
              case eB.MediaInteraction:
              case eB.MouseInteraction:
              case eB.Scroll:
              case eB.CanvasMutation:
              case eB.Input:
                this.replaceIds(_.data, m, ["id"]);
                return _;
              case eB.StyleSheetRule:
              case eB.StyleDeclaration:
                this.replaceIds(_.data, m, ["id"]);
                this.replaceStyleIds(_.data, m, ["styleId"]);
                return _;
              case eB.Font:
                return _;
              case eB.Selection:
                _.data.ranges.forEach(_ => {
                  this.replaceIds(_, m, ["start", "end"]);
                });
                return _;
              case eB.AdoptedStyleSheet:
                this.replaceIds(_.data, m, ["id"]);
                this.replaceStyleIds(_.data, m, ["styleIds"]);
                if ((C = _.data.styles) !== null && C !== undefined) {
                  C.forEach(_ => {
                    this.replaceStyleIds(_, m, ["styleId"]);
                  });
                }
                return _;
            }
        }
        return false;
      }
      replace(m, _, C, R) {
        for (let L of R) {
          if (Array.isArray(_[L]) || typeof _[L] == "number") {
            if (Array.isArray(_[L])) {
              _[L] = m.getIds(C, _[L]);
            } else {
              _[L] = m.getId(C, _[L]);
            }
          }
        }
        return _;
      }
      replaceIds(m, _, C) {
        return this.replace(this.crossOriginIframeMirror, m, _, C);
      }
      replaceStyleIds(m, _, C) {
        return this.replace(this.crossOriginIframeStyleMirror, m, _, C);
      }
      replaceIdOnNode(m, _) {
        this.replaceIds(m, _, ["id", "rootId"]);
        if ("childNodes" in m) {
          m.childNodes.forEach(m => {
            this.replaceIdOnNode(m, _);
          });
        }
      }
      patchRootIdOnNode(m, _) {
        if (m.type !== eR.Document && !m.rootId) {
          m.rootId = _;
        }
        if ("childNodes" in m) {
          m.childNodes.forEach(m => {
            this.patchRootIdOnNode(m, _);
          });
        }
      }
    };
    let ShadowDomManager = class ShadowDomManager {
      constructor(m) {
        this.shadowDoms = new WeakSet();
        this.restoreHandlers = [];
        this.mutationCb = m.mutationCb;
        this.scrollCb = m.scrollCb;
        this.bypassOptions = m.bypassOptions;
        this.mirror = m.mirror;
        this.init();
      }
      init() {
        this.reset();
        this.patchAttachShadow(Element, document);
      }
      addShadowRoot(m, _) {
        if (!isNativeShadowDom(m) || this.shadowDoms.has(m)) {
          return;
        }
        this.shadowDoms.add(m);
        let C = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), {
          doc: _,
          mutationCb: this.mutationCb,
          mirror: this.mirror,
          shadowDomManager: this
        }), m);
        this.restoreHandlers.push(() => C.disconnect());
        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), {
          scrollCb: this.scrollCb,
          doc: m,
          mirror: this.mirror
        })));
        setTimeout(() => {
          if (m.adoptedStyleSheets && m.adoptedStyleSheets.length > 0) {
            this.bypassOptions.stylesheetManager.adoptStyleSheets(m.adoptedStyleSheets, this.mirror.getId(m.host));
          }
          this.restoreHandlers.push(initAdoptedStyleSheetObserver({
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          }, m));
        }, 0);
      }
      observeAttachShadow(m) {
        if (m.contentWindow && m.contentDocument) {
          this.patchAttachShadow(m.contentWindow.Element, m.contentDocument);
        }
      }
      patchAttachShadow(m, _) {
        let C = this;
        this.restoreHandlers.push(patch(m.prototype, "attachShadow", function (m) {
          return function (R) {
            let L = m.call(this, R);
            if (this.shadowRoot && inDom(this)) {
              C.addShadowRoot(this.shadowRoot, _);
            }
            return L;
          };
        }));
      }
      reset() {
        this.restoreHandlers.forEach(m => {
          try {
            m();
          } catch (m) {}
        });
        this.restoreHandlers = [];
        this.shadowDoms = new WeakSet();
      }
    };
    for (var eq = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", eG = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256), ez = 0; ez < eq.length; ez++) {
      eG[eq.charCodeAt(ez)] = ez;
    }
    function encode(m) {
      var _;
      var C = new Uint8Array(m);
      var R = C.length;
      var L = "";
      for (_ = 0; _ < R; _ += 3) {
        L += eq[C[_] >> 2] + eq[(C[_] & 3) << 4 | C[_ + 1] >> 4] + eq[(C[_ + 1] & 15) << 2 | C[_ + 2] >> 6] + eq[C[_ + 2] & 63];
      }
      if (R % 3 == 2) {
        L = L.substring(0, L.length - 1) + "=";
      } else if (R % 3 == 1) {
        L = L.substring(0, L.length - 2) + "==";
      }
      return L;
    }
    let eV = new Map();
    let saveWebGLVar = (m, _, C) => {
      let R;
      if (!m || !isInstanceOfWebGLObject(m, _) && typeof m != "object") {
        return;
      }
      let L = m.constructor.name;
      if (!(R = eV.get(C))) {
        R = new Map();
        eV.set(C, R);
      }
      if (!R.has(L)) {
        R.set(L, []);
      }
      let B = R.get(L);
      let F = B.indexOf(m);
      if (F === -1) {
        F = B.length;
        B.push(m);
      }
      return F;
    };
    let serializeArgs = (m, _, C) => m.map(m => function serializeArg(m, _, C) {
      if (m instanceof Array) {
        return m.map(m => serializeArg(m, _, C));
      }
      if (m === null) ;else if (m instanceof Float32Array || m instanceof Float64Array || m instanceof Int32Array || m instanceof Uint32Array || m instanceof Uint8Array || m instanceof Uint16Array || m instanceof Int16Array || m instanceof Int8Array || m instanceof Uint8ClampedArray) {
        let _ = m.constructor.name;
        return {
          rr_type: _,
          args: [Object.values(m)]
        };
      } else if (m instanceof ArrayBuffer) {
        let _ = m.constructor.name;
        let C = encode(m);
        return {
          rr_type: _,
          base64: C
        };
      } else if (m instanceof DataView) {
        let R = m.constructor.name;
        return {
          rr_type: R,
          args: [serializeArg(m.buffer, _, C), m.byteOffset, m.byteLength]
        };
      } else if (m instanceof HTMLImageElement) {
        let _ = m.constructor.name;
        let {
          src: C
        } = m;
        return {
          rr_type: _,
          src: C
        };
      } else if (m instanceof HTMLCanvasElement) {
        let _ = m.toDataURL();
        return {
          rr_type: "HTMLImageElement",
          src: _
        };
      } else if (m instanceof ImageData) {
        let R = m.constructor.name;
        return {
          rr_type: R,
          args: [serializeArg(m.data, _, C), m.width, m.height]
        };
      } else if (isInstanceOfWebGLObject(m, _) || typeof m == "object") {
        let R = m.constructor.name;
        let L = saveWebGLVar(m, _, C);
        return {
          rr_type: R,
          index: L
        };
      }
      return m;
    }(m, _, C));
    let isInstanceOfWebGLObject = (m, _) => {
      let C = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter(m => typeof _[m] == "function");
      return !!C.find(C => m instanceof _[C]);
    };
    function initCanvasContextObserver(m, _, C, R) {
      let L = [];
      try {
        let B = patch(m.HTMLCanvasElement.prototype, "getContext", function (m) {
          return function (L, ...B) {
            if (!isBlocked(this, _, C, true)) {
              let m = L === "experimental-webgl" ? "webgl" : L;
              if (!("__context" in this)) {
                this.__context = m;
              }
              if (R && ["webgl", "webgl2"].includes(m)) {
                if (B[0] && typeof B[0] == "object") {
                  let m = B[0];
                  m.preserveDrawingBuffer ||= true;
                } else {
                  B.splice(0, 1, {
                    preserveDrawingBuffer: true
                  });
                }
              }
            }
            return m.apply(this, [L, ...B]);
          };
        });
        L.push(B);
      } catch (m) {
        console.error("failed to patch HTMLCanvasElement.prototype.getContext");
      }
      return () => {
        L.forEach(m => m());
      };
    }
    function patchGLPrototype(m, _, C, R, L, B, F) {
      let U = [];
      let H = Object.getOwnPropertyNames(m);
      for (let B of H) {
        if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(B)) {
          try {
            if (typeof m[B] != "function") {
              continue;
            }
            let H = patch(m, B, function (m) {
              return function (...U) {
                let H = m.apply(this, U);
                saveWebGLVar(H, F, this);
                if ("tagName" in this.canvas && !isBlocked(this.canvas, R, L, true)) {
                  let m = serializeArgs(U, F, this);
                  let R = {
                    type: _,
                    property: B,
                    args: m
                  };
                  C(this.canvas, R);
                }
                return H;
              };
            });
            U.push(H);
          } catch (L) {
            let R = hookSetter(m, B, {
              set(m) {
                C(this.canvas, {
                  type: _,
                  property: B,
                  args: [m],
                  setter: true
                });
              }
            });
            U.push(R);
          }
        }
      }
      return U;
    }
    ed = function () {
      (function () {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        function __awaiter(m, _, C, R) {
          return new (C ||= Promise)(function (L, B) {
            function fulfilled(m) {
              try {
                step(R.next(m));
              } catch (m) {
                B(m);
              }
            }
            function rejected(m) {
              try {
                step(R.throw(m));
              } catch (m) {
                B(m);
              }
            }
            function step(m) {
              var _;
              if (m.done) {
                L(m.value);
              } else {
                ((_ = m.value) instanceof C ? _ : new C(function (m) {
                  m(_);
                })).then(fulfilled, rejected);
              }
            }
            step((R = R.apply(m, _ || [])).next());
          });
        }
        for (var m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _ = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256), C = 0; C < m.length; C++) {
          _[m.charCodeAt(C)] = C;
        }
        function encode(_) {
          var C;
          var R = new Uint8Array(_);
          var L = R.length;
          var B = "";
          for (C = 0; C < L; C += 3) {
            B += m[R[C] >> 2] + m[(R[C] & 3) << 4 | R[C + 1] >> 4] + m[(R[C + 1] & 15) << 2 | R[C + 2] >> 6] + m[R[C + 2] & 63];
          }
          if (L % 3 == 2) {
            B = B.substring(0, B.length - 1) + "=";
          } else if (L % 3 == 1) {
            B = B.substring(0, B.length - 2) + "==";
          }
          return B;
        }
        let R = new Map();
        let L = new Map();
        let B = self;
        B.onmessage = function (m) {
          return __awaiter(this, undefined, undefined, function* () {
            if (!("OffscreenCanvas" in globalThis)) {
              return B.postMessage({
                id: m.data.id
              });
            }
            {
              let {
                id: _,
                bitmap: C,
                width: F,
                height: U,
                dataURLOptions: H
              } = m.data;
              let q = function (m, _, C) {
                return __awaiter(this, undefined, undefined, function* () {
                  let R = `${m}-${_}`;
                  if (!("OffscreenCanvas" in globalThis)) {
                    return "";
                  }
                  {
                    if (L.has(R)) {
                      return L.get(R);
                    }
                    let B = new OffscreenCanvas(m, _);
                    B.getContext("2d");
                    let F = yield B.convertToBlob(C);
                    let U = yield F.arrayBuffer();
                    let H = encode(U);
                    L.set(R, H);
                    return H;
                  }
                });
              }(F, U, H);
              let V = new OffscreenCanvas(F, U);
              let X = V.getContext("2d");
              X.drawImage(C, 0, 0);
              C.close();
              let K = yield V.convertToBlob(H);
              let Y = K.type;
              let Q = yield K.arrayBuffer();
              let et = encode(Q);
              if (!R.has(_) && (yield q) === et) {
                R.set(_, et);
                return B.postMessage({
                  id: _
                });
              }
              if (R.get(_) === et) {
                return B.postMessage({
                  id: _
                });
              }
              B.postMessage({
                id: _,
                type: Y,
                base64: et,
                width: F,
                height: U
              });
              R.set(_, et);
            }
          });
        };
      })();
    };
    function eJ(m) {
      var _;
      var C;
      ep = ep || (_ = function (m, _) {
        var C = _ === undefined ? null : _;
        var R = m.toString().split("\n");
        R.pop();
        R.shift();
        var L = R[0].search(/\S/);
        var B = /(['"])__worker_loader_strict__(['"])/g;
        for (var F = 0, U = R.length; F < U; ++F) {
          R[F] = R[F].substring(L).replace(B, "$1use strict$2") + "\n";
        }
        if (C) {
          R.push("//# sourceMappingURL=" + C + "\n");
        }
        return R;
      }(ed, null), C = new Blob(_, {
        type: "application/javascript"
      }), URL.createObjectURL(C));
      return new Worker(ep, m);
    }
    let CanvasManager = class CanvasManager {
      reset() {
        this.pendingCanvasMutations.clear();
        if (this.resetObservers) {
          this.resetObservers();
        }
      }
      freeze() {
        this.frozen = true;
      }
      unfreeze() {
        this.frozen = false;
      }
      lock() {
        this.locked = true;
      }
      unlock() {
        this.locked = false;
      }
      constructor(m) {
        this.pendingCanvasMutations = new Map();
        this.rafStamps = {
          latestId: 0,
          invokeId: null
        };
        this.frozen = false;
        this.locked = false;
        this.processMutation = (m, _) => {
          let C = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
          if (C || !this.rafStamps.invokeId) {
            this.rafStamps.invokeId = this.rafStamps.latestId;
          }
          if (!this.pendingCanvasMutations.has(m)) {
            this.pendingCanvasMutations.set(m, []);
          }
          this.pendingCanvasMutations.get(m).push(_);
        };
        let {
          sampling: _ = "all",
          win: C,
          blockClass: R,
          blockSelector: L,
          recordCanvas: B,
          dataURLOptions: F
        } = m;
        this.mutationCb = m.mutationCb;
        this.mirror = m.mirror;
        if (B && _ === "all") {
          this.initCanvasMutationObserver(C, R, L);
        }
        if (B && typeof _ == "number") {
          this.initCanvasFPSObserver(_, C, R, L, {
            dataURLOptions: F
          });
        }
      }
      initCanvasFPSObserver(m, _, C, R, L) {
        let B;
        let F = initCanvasContextObserver(_, C, R, true);
        let U = new Map();
        let H = new eJ();
        H.onmessage = m => {
          let {
            id: _
          } = m.data;
          U.set(_, false);
          if (!("base64" in m.data)) {
            return;
          }
          let {
            base64: C,
            type: R,
            width: L,
            height: B
          } = m.data;
          this.mutationCb({
            id: _,
            type: eU["2D"],
            commands: [{
              property: "clearRect",
              args: [0, 0, L, B]
            }, {
              property: "drawImage",
              args: [{
                rr_type: "ImageBitmap",
                args: [{
                  rr_type: "Blob",
                  data: [{
                    rr_type: "ArrayBuffer",
                    base64: C
                  }],
                  type: R
                }]
              }, 0, 0]
            }]
          });
        };
        let q = 1000 / m;
        let V = 0;
        let getCanvas = () => {
          let m = [];
          _.document.querySelectorAll("canvas").forEach(_ => {
            if (!isBlocked(_, C, R, true)) {
              m.push(_);
            }
          });
          return m;
        };
        let takeCanvasSnapshots = m => {
          if (V && m - V < q) {
            B = requestAnimationFrame(takeCanvasSnapshots);
            return;
          }
          V = m;
          getCanvas().forEach(m => {
            var _;
            var C;
            var R;
            var B;
            _ = this;
            C = undefined;
            R = undefined;
            B = function* () {
              let C = this.mirror.getId(m);
              if (U.get(C) || m.width === 0 || m.height === 0) {
                return;
              }
              U.set(C, true);
              if (["webgl", "webgl2"].includes(m.__context)) {
                let C = m.getContext(m.__context);
                if ((C == null ? undefined : C.getContextAttributes())?.preserveDrawingBuffer === false) {
                  C.clear(C.COLOR_BUFFER_BIT);
                }
              }
              let R = yield createImageBitmap(m);
              H.postMessage({
                id: C,
                bitmap: R,
                width: m.width,
                height: m.height,
                dataURLOptions: L.dataURLOptions
              }, [R]);
            };
            return new (R ||= Promise)(function (m, L) {
              function fulfilled(m) {
                try {
                  step(B.next(m));
                } catch (m) {
                  L(m);
                }
              }
              function rejected(m) {
                try {
                  step(B.throw(m));
                } catch (m) {
                  L(m);
                }
              }
              function step(_) {
                var C;
                if (_.done) {
                  m(_.value);
                } else {
                  ((C = _.value) instanceof R ? C : new R(function (m) {
                    m(C);
                  })).then(fulfilled, rejected);
                }
              }
              step((B = B.apply(_, C || [])).next());
            });
          });
          B = requestAnimationFrame(takeCanvasSnapshots);
        };
        B = requestAnimationFrame(takeCanvasSnapshots);
        this.resetObservers = () => {
          F();
          cancelAnimationFrame(B);
        };
      }
      initCanvasMutationObserver(m, _, C) {
        this.startRAFTimestamping();
        this.startPendingCanvasMutationFlusher();
        let R = initCanvasContextObserver(m, _, C, false);
        let L = function (m, _, C, R) {
          let L = [];
          let B = Object.getOwnPropertyNames(_.CanvasRenderingContext2D.prototype);
          for (let F of B) {
            try {
              if (typeof _.CanvasRenderingContext2D.prototype[F] != "function") {
                continue;
              }
              let B = patch(_.CanvasRenderingContext2D.prototype, F, function (L) {
                return function (...B) {
                  if (!isBlocked(this.canvas, C, R, true)) {
                    setTimeout(() => {
                      let C = serializeArgs(B, _, this);
                      m(this.canvas, {
                        type: eU["2D"],
                        property: F,
                        args: C
                      });
                    }, 0);
                  }
                  return L.apply(this, B);
                };
              });
              L.push(B);
            } catch (R) {
              let C = hookSetter(_.CanvasRenderingContext2D.prototype, F, {
                set(_) {
                  m(this.canvas, {
                    type: eU["2D"],
                    property: F,
                    args: [_],
                    setter: true
                  });
                }
              });
              L.push(C);
            }
          }
          return () => {
            L.forEach(m => m());
          };
        }(this.processMutation.bind(this), m, _, C);
        let B = function (m, _, C, R, L) {
          let B = [];
          B.push(...patchGLPrototype(_.WebGLRenderingContext.prototype, eU.WebGL, m, C, R, L, _));
          if (_.WebGL2RenderingContext !== undefined) {
            B.push(...patchGLPrototype(_.WebGL2RenderingContext.prototype, eU.WebGL2, m, C, R, L, _));
          }
          return () => {
            B.forEach(m => m());
          };
        }(this.processMutation.bind(this), m, _, C, this.mirror);
        this.resetObservers = () => {
          R();
          L();
          B();
        };
      }
      startPendingCanvasMutationFlusher() {
        requestAnimationFrame(() => this.flushPendingCanvasMutations());
      }
      startRAFTimestamping() {
        let setLatestRAFTimestamp = m => {
          this.rafStamps.latestId = m;
          requestAnimationFrame(setLatestRAFTimestamp);
        };
        requestAnimationFrame(setLatestRAFTimestamp);
      }
      flushPendingCanvasMutations() {
        this.pendingCanvasMutations.forEach((m, _) => {
          let C = this.mirror.getId(_);
          this.flushPendingCanvasMutationFor(_, C);
        });
        requestAnimationFrame(() => this.flushPendingCanvasMutations());
      }
      flushPendingCanvasMutationFor(m, _) {
        if (this.frozen || this.locked) {
          return;
        }
        let C = this.pendingCanvasMutations.get(m);
        if (!C || _ === -1) {
          return;
        }
        let R = C.map(m => {
          let _ =
          /*! *****************************************************************************
          Copyright (c) Microsoft Corporation.
          Permission to use, copy, modify, and/or distribute this software for any
          purpose with or without fee is hereby granted.
          THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          PERFORMANCE OF THIS SOFTWARE.
          ***************************************************************************** */
          function (m, _) {
            var C = {};
            for (var R in m) {
              if (Object.prototype.hasOwnProperty.call(m, R) && _.indexOf(R) < 0) {
                C[R] = m[R];
              }
            }
            if (m != null && typeof Object.getOwnPropertySymbols == "function") {
              for (var L = 0, R = Object.getOwnPropertySymbols(m); L < R.length; L++) {
                if (_.indexOf(R[L]) < 0 && Object.prototype.propertyIsEnumerable.call(m, R[L])) {
                  C[R[L]] = m[R[L]];
                }
              }
            }
            return C;
          }(m, ["type"]);
          return _;
        });
        let {
          type: L
        } = C[0];
        this.mutationCb({
          id: _,
          type: L,
          commands: R
        });
        this.pendingCanvasMutations.delete(m);
      }
    };
    let StylesheetManager = class StylesheetManager {
      constructor(m) {
        this.trackedLinkElements = new WeakSet();
        this.styleMirror = new StyleSheetMirror();
        this.mutationCb = m.mutationCb;
        this.adoptedStyleSheetCb = m.adoptedStyleSheetCb;
      }
      attachLinkElement(m, _) {
        if ("_cssText" in _.attributes) {
          this.mutationCb({
            adds: [],
            removes: [],
            texts: [],
            attributes: [{
              id: _.id,
              attributes: _.attributes
            }]
          });
        }
        this.trackLinkElement(m);
      }
      trackLinkElement(m) {
        if (!this.trackedLinkElements.has(m)) {
          this.trackedLinkElements.add(m);
          this.trackStylesheetInLinkElement(m);
        }
      }
      adoptStyleSheets(m, _) {
        if (m.length === 0) {
          return;
        }
        let C = {
          id: _,
          styleIds: []
        };
        let R = [];
        for (let _ of m) {
          let m;
          if (this.styleMirror.has(_)) {
            m = this.styleMirror.getId(_);
          } else {
            m = this.styleMirror.add(_);
            R.push({
              styleId: m,
              rules: Array.from(_.rules || CSSRule, (m, _) => ({
                rule: stringifyRule(m),
                index: _
              }))
            });
          }
          C.styleIds.push(m);
        }
        if (R.length > 0) {
          C.styles = R;
        }
        this.adoptedStyleSheetCb(C);
      }
      reset() {
        this.styleMirror.reset();
        this.trackedLinkElements = new WeakSet();
      }
      trackStylesheetInLinkElement(m) {}
    };
    let ProcessedNodeManager = class ProcessedNodeManager {
      constructor() {
        this.nodeMap = new WeakMap();
        this.loop = true;
        this.periodicallyClear();
      }
      periodicallyClear() {
        requestAnimationFrame(() => {
          this.clear();
          if (this.loop) {
            this.periodicallyClear();
          }
        });
      }
      inOtherBuffer(m, _) {
        let C = this.nodeMap.get(m);
        return C && Array.from(C).some(m => m !== _);
      }
      add(m, _) {
        this.nodeMap.set(m, (this.nodeMap.get(m) || new Set()).add(_));
      }
      clear() {
        this.nodeMap = new WeakMap();
      }
      destroy() {
        this.loop = false;
      }
    };
    function wrapEvent(m) {
      return Object.assign(Object.assign({}, m), {
        timestamp: ea()
      });
    }
    let eX = false;
    let eK = new Mirror();
    function record(m = {}) {
      let _;
      let {
        emit: C,
        checkoutEveryNms: R,
        checkoutEveryNth: L,
        blockClass: q = "rr-block",
        blockSelector: V = null,
        ignoreClass: X = "rr-ignore",
        ignoreSelector: K = null,
        maskTextClass: Y = "rr-mask",
        maskTextSelector: Q = null,
        inlineStylesheet: et = true,
        maskAllInputs: er,
        maskInputOptions: en,
        slimDOMOptions: ei,
        maskInputFn: eo,
        maskTextFn: ea,
        hooks: es,
        packFn: ec,
        sampling: el = {},
        dataURLOptions: eu = {},
        mousemoveWait: ed,
        recordDOM: ep = true,
        recordCanvas: eh = false,
        recordCrossOriginIframes: ef = false,
        recordAfter: em = m.recordAfter === "DOMContentLoaded" ? m.recordAfter : "load",
        userTriggeredOnInput: eg = false,
        collectFonts: ey = false,
        inlineImages: e_ = false,
        plugins: ev,
        keepIframeSrcFn: eb = () => false,
        ignoreCSSAttributes: eS = new Set([]),
        errorHandler: ew
      } = m;
      B = ew;
      let eE = !ef || window.parent === window;
      let ek = false;
      if (!eE) {
        try {
          if (window.parent.document) {
            ek = false;
          }
        } catch (m) {
          ek = true;
        }
      }
      if (eE && !C) {
        throw Error("emit function is required");
      }
      if (ed !== undefined && el.mousemove === undefined) {
        el.mousemove = ed;
      }
      eK.reset();
      let ex = er === true ? {
        color: true,
        date: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true,
        textarea: true,
        select: true,
        password: true
      } : en !== undefined ? en : {
        password: true
      };
      let eI = ei === true || ei === "all" ? {
        script: true,
        comment: true,
        headFavicon: true,
        headWhitespace: true,
        headMetaSocial: true,
        headMetaRobots: true,
        headMetaHttpEquiv: true,
        headMetaVerification: true,
        headMetaAuthorship: ei === "all",
        headMetaDescKeywords: ei === "all"
      } : ei || {};
      (function (m = window) {
        if ("NodeList" in m && !m.NodeList.prototype.forEach) {
          m.NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if ("DOMTokenList" in m && !m.DOMTokenList.prototype.forEach) {
          m.DOMTokenList.prototype.forEach = Array.prototype.forEach;
        }
        Node.prototype.contains ||= (...m) => {
          let _ = m[0];
          if (!(0 in m)) {
            throw TypeError("1 argument is required");
          }
          do {
            if (this === _) {
              return true;
            }
          } while (_ = _ && _.parentNode);
          return false;
        };
      })();
      let eO = 0;
      let eventProcessor = m => {
        for (let _ of ev || []) {
          if (_.eventProcessor) {
            m = _.eventProcessor(m);
          }
        }
        if (ec && !ek) {
          m = ec(m);
        }
        return m;
      };
      F = (m, B) => {
        var F;
        if (((F = eH[0]) === null || F === undefined ? undefined : F.isFrozen()) && m.type !== eN.FullSnapshot && (m.type !== eN.IncrementalSnapshot || m.data.source !== eB.Mutation)) {
          eH.forEach(m => m.unfreeze());
        }
        if (eE) {
          if (C != null) {
            C(eventProcessor(m), B);
          }
        } else if (ek) {
          let _ = {
            type: "rrweb",
            event: eventProcessor(m),
            origin: window.location.origin,
            isCheckout: B
          };
          window.parent.postMessage(_, "*");
        }
        if (m.type === eN.FullSnapshot) {
          _ = m;
          eO = 0;
        } else if (m.type === eN.IncrementalSnapshot) {
          if (m.data.source === eB.Mutation && m.data.isAttachIframe) {
            return;
          }
          eO++;
          let C = L && eO >= L;
          let B = R && m.timestamp - _.timestamp > R;
          if (C || B) {
            U(true);
          }
        }
      };
      let wrappedMutationEmit = m => {
        F(wrapEvent({
          type: eN.IncrementalSnapshot,
          data: Object.assign({
            source: eB.Mutation
          }, m)
        }));
      };
      let wrappedScrollEmit = m => F(wrapEvent({
        type: eN.IncrementalSnapshot,
        data: Object.assign({
          source: eB.Scroll
        }, m)
      }));
      let wrappedCanvasMutationEmit = m => F(wrapEvent({
        type: eN.IncrementalSnapshot,
        data: Object.assign({
          source: eB.CanvasMutation
        }, m)
      }));
      let eC = new StylesheetManager({
        mutationCb: wrappedMutationEmit,
        adoptedStyleSheetCb: m => F(wrapEvent({
          type: eN.IncrementalSnapshot,
          data: Object.assign({
            source: eB.AdoptedStyleSheet
          }, m)
        }))
      });
      let eM = new IframeManager({
        mirror: eK,
        mutationCb: wrappedMutationEmit,
        stylesheetManager: eC,
        recordCrossOriginIframes: ef,
        wrappedEmit: F
      });
      for (let m of ev || []) {
        if (m.getMirror) {
          m.getMirror({
            nodeMirror: eK,
            crossOriginIframeMirror: eM.crossOriginIframeMirror,
            crossOriginIframeStyleMirror: eM.crossOriginIframeStyleMirror
          });
        }
      }
      let eT = new ProcessedNodeManager();
      H = new CanvasManager({
        recordCanvas: eh,
        mutationCb: wrappedCanvasMutationEmit,
        win: window,
        blockClass: q,
        blockSelector: V,
        mirror: eK,
        sampling: el.canvas,
        dataURLOptions: eu
      });
      let eA = new ShadowDomManager({
        mutationCb: wrappedMutationEmit,
        scrollCb: wrappedScrollEmit,
        bypassOptions: {
          blockClass: q,
          blockSelector: V,
          maskTextClass: Y,
          maskTextSelector: Q,
          inlineStylesheet: et,
          maskInputOptions: ex,
          dataURLOptions: eu,
          maskTextFn: ea,
          maskInputFn: eo,
          recordCanvas: eh,
          inlineImages: e_,
          sampling: el,
          slimDOMOptions: eI,
          iframeManager: eM,
          stylesheetManager: eC,
          canvasManager: H,
          keepIframeSrcFn: eb,
          processedNodeManager: eT
        },
        mirror: eK
      });
      U = (m = false) => {
        if (!ep) {
          return;
        }
        F(wrapEvent({
          type: eN.Meta,
          data: {
            href: window.location.href,
            width: getWindowWidth(),
            height: getWindowHeight()
          }
        }), m);
        eC.reset();
        eA.init();
        eH.forEach(m => m.lock());
        let _ = function (m, _) {
          let {
            mirror: C = new Mirror(),
            blockClass: R = "rr-block",
            blockSelector: L = null,
            maskTextClass: B = "rr-mask",
            maskTextSelector: F = null,
            inlineStylesheet: U = true,
            inlineImages: H = false,
            recordCanvas: q = false,
            maskAllInputs: V = false,
            maskTextFn: X,
            maskInputFn: K,
            slimDOM: Y = false,
            dataURLOptions: Q,
            preserveWhiteSpace: et,
            onSerialize: er,
            onIframeLoad: en,
            iframeLoadTimeout: ei,
            onStylesheetLoad: eo,
            stylesheetLoadTimeout: ea,
            keepIframeSrcFn: es = () => false
          } = _ || {};
          let ec = V === true ? {
            color: true,
            date: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true,
            textarea: true,
            select: true,
            password: true
          } : V === false ? {
            password: true
          } : V;
          let el = Y === true || Y === "all" ? {
            script: true,
            comment: true,
            headFavicon: true,
            headWhitespace: true,
            headMetaDescKeywords: Y === "all",
            headMetaSocial: true,
            headMetaRobots: true,
            headMetaHttpEquiv: true,
            headMetaAuthorship: true,
            headMetaVerification: true
          } : Y === false ? {} : Y;
          return serializeNodeWithId(m, {
            doc: m,
            mirror: C,
            blockClass: R,
            blockSelector: L,
            maskTextClass: B,
            maskTextSelector: F,
            skipChild: false,
            inlineStylesheet: U,
            maskInputOptions: ec,
            maskTextFn: X,
            maskInputFn: K,
            slimDOMOptions: el,
            dataURLOptions: Q,
            inlineImages: H,
            recordCanvas: q,
            preserveWhiteSpace: et,
            onSerialize: er,
            onIframeLoad: en,
            iframeLoadTimeout: ei,
            onStylesheetLoad: eo,
            stylesheetLoadTimeout: ea,
            keepIframeSrcFn: es,
            newlyAddedElement: false
          });
        }(document, {
          mirror: eK,
          blockClass: q,
          blockSelector: V,
          maskTextClass: Y,
          maskTextSelector: Q,
          inlineStylesheet: et,
          maskAllInputs: ex,
          maskTextFn: ea,
          slimDOM: eI,
          dataURLOptions: eu,
          recordCanvas: eh,
          inlineImages: e_,
          onSerialize: m => {
            if (isSerializedIframe(m, eK)) {
              eM.addIframe(m);
            }
            if (isSerializedStylesheet(m, eK)) {
              eC.trackLinkElement(m);
            }
            if (hasShadowRoot(m)) {
              eA.addShadowRoot(m.shadowRoot, document);
            }
          },
          onIframeLoad: (m, _) => {
            eM.attachIframe(m, _);
            eA.observeAttachShadow(m);
          },
          onStylesheetLoad: (m, _) => {
            eC.attachLinkElement(m, _);
          },
          keepIframeSrcFn: eb
        });
        if (!_) {
          return console.warn("Failed to snapshot the document");
        }
        F(wrapEvent({
          type: eN.FullSnapshot,
          data: {
            node: _,
            initialOffset: getWindowScroll(window)
          }
        }), m);
        eH.forEach(m => m.unlock());
        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) {
          eC.adoptStyleSheets(document.adoptedStyleSheets, eK.getId(document));
        }
      };
      try {
        let m = [];
        let observe = m => {
          var _;
          return callbackWrapper(initObservers)({
            mutationCb: wrappedMutationEmit,
            mousemoveCb: (m, _) => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: {
                source: _,
                positions: m
              }
            })),
            mouseInteractionCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.MouseInteraction
              }, m)
            })),
            scrollCb: wrappedScrollEmit,
            viewportResizeCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.ViewportResize
              }, m)
            })),
            inputCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.Input
              }, m)
            })),
            mediaInteractionCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.MediaInteraction
              }, m)
            })),
            styleSheetRuleCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.StyleSheetRule
              }, m)
            })),
            styleDeclarationCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.StyleDeclaration
              }, m)
            })),
            canvasMutationCb: wrappedCanvasMutationEmit,
            fontCb: m => F(wrapEvent({
              type: eN.IncrementalSnapshot,
              data: Object.assign({
                source: eB.Font
              }, m)
            })),
            selectionCb: m => {
              F(wrapEvent({
                type: eN.IncrementalSnapshot,
                data: Object.assign({
                  source: eB.Selection
                }, m)
              }));
            },
            customElementCb: m => {
              F(wrapEvent({
                type: eN.IncrementalSnapshot,
                data: Object.assign({
                  source: eB.CustomElement
                }, m)
              }));
            },
            blockClass: q,
            ignoreClass: X,
            ignoreSelector: K,
            maskTextClass: Y,
            maskTextSelector: Q,
            maskInputOptions: ex,
            inlineStylesheet: et,
            sampling: el,
            recordDOM: ep,
            recordCanvas: eh,
            inlineImages: e_,
            userTriggeredOnInput: eg,
            collectFonts: ey,
            doc: m,
            maskInputFn: eo,
            maskTextFn: ea,
            keepIframeSrcFn: eb,
            blockSelector: V,
            slimDOMOptions: eI,
            dataURLOptions: eu,
            mirror: eK,
            iframeManager: eM,
            stylesheetManager: eC,
            shadowDomManager: eA,
            processedNodeManager: eT,
            canvasManager: H,
            ignoreCSSAttributes: eS,
            plugins: ((_ = ev == null ? undefined : ev.filter(m => m.observer)) === null || _ === undefined ? undefined : _.map(m => ({
              observer: m.observer,
              options: m.options,
              callback: _ => F(wrapEvent({
                type: eN.Plugin,
                data: {
                  plugin: m.name,
                  payload: _
                }
              }))
            }))) || []
          }, es);
        };
        eM.addLoadListener(_ => {
          try {
            m.push(observe(_.contentDocument));
          } catch (m) {
            console.warn(m);
          }
        });
        let init = () => {
          U();
          m.push(observe(document));
          eX = true;
        };
        if (document.readyState === "interactive" || document.readyState === "complete") {
          init();
        } else {
          m.push(on("DOMContentLoaded", () => {
            F(wrapEvent({
              type: eN.DomContentLoaded,
              data: {}
            }));
            if (em === "DOMContentLoaded") {
              init();
            }
          }));
          m.push(on("load", () => {
            F(wrapEvent({
              type: eN.Load,
              data: {}
            }));
            if (em === "load") {
              init();
            }
          }, window));
        }
        return () => {
          m.forEach(m => m());
          eT.destroy();
          eX = false;
          B = undefined;
        };
      } catch (m) {
        console.warn(m);
      }
    }
    record.addCustomEvent = (m, _) => {
      if (!eX) {
        throw Error("please add custom event after start recording");
      }
      F(wrapEvent({
        type: eN.Custom,
        data: {
          tag: m,
          payload: _
        }
      }));
    };
    record.freezePage = () => {
      eH.forEach(m => m.freeze());
    };
    record.takeFullSnapshot = m => {
      if (!eX) {
        throw Error("please take full snapshot after start recording");
      }
      U(m);
    };
    record.mirror = eK;
    (eh = eZ || {})[eh.DomContentLoaded = 0] = "DomContentLoaded";
    eh[eh.Load = 1] = "Load";
    eh[eh.FullSnapshot = 2] = "FullSnapshot";
    eh[eh.IncrementalSnapshot = 3] = "IncrementalSnapshot";
    eh[eh.Meta = 4] = "Meta";
    eh[eh.Custom = 5] = "Custom";
    eh[eh.Plugin = 6] = "Plugin";
    var eZ = eh;
    (ef = eY || {})[ef.Mutation = 0] = "Mutation";
    ef[ef.MouseMove = 1] = "MouseMove";
    ef[ef.MouseInteraction = 2] = "MouseInteraction";
    ef[ef.Scroll = 3] = "Scroll";
    ef[ef.ViewportResize = 4] = "ViewportResize";
    ef[ef.Input = 5] = "Input";
    ef[ef.TouchMove = 6] = "TouchMove";
    ef[ef.MediaInteraction = 7] = "MediaInteraction";
    ef[ef.StyleSheetRule = 8] = "StyleSheetRule";
    ef[ef.CanvasMutation = 9] = "CanvasMutation";
    ef[ef.Font = 10] = "Font";
    ef[ef.Log = 11] = "Log";
    ef[ef.Drag = 12] = "Drag";
    ef[ef.StyleDeclaration = 13] = "StyleDeclaration";
    ef[ef.Selection = 14] = "Selection";
    ef[ef.AdoptedStyleSheet = 15] = "AdoptedStyleSheet";
    ef[ef.CustomElement = 16] = "CustomElement";
    var eY = ef;
    var eQ = {
      DEBUG: false,
      LIB_VERSION: "2.55.1"
    };
    if (typeof window == "undefined") {
      var e0 = {
        hostname: ""
      };
      eP = {
        navigator: {
          userAgent: "",
          onLine: true
        },
        document: {
          location: e0,
          referrer: ""
        },
        screen: {
          width: 0,
          height: 0
        },
        location: e0
      };
    } else {
      eP = window;
    }
    var e1 = Array.prototype;
    var e2 = Function.prototype;
    var e3 = Object.prototype;
    var e5 = e1.slice;
    var e6 = e3.toString;
    var e4 = e3.hasOwnProperty;
    var e8 = eP.console;
    var e9 = eP.navigator;
    var e7 = eP.document;
    var te = eP.opera;
    var tt = eP.screen;
    var tr = e9.userAgent;
    var tn = e2.bind;
    var ti = e1.forEach;
    var to = e1.indexOf;
    var ta = e1.map;
    var ts = Array.isArray;
    var tc = {};
    var tl = {
      trim: function (m) {
        return m.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      }
    };
    var tu = {
      log: function () {
        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) {
          try {
            e8.log.apply(e8, arguments);
          } catch (m) {
            tl.each(arguments, function (m) {
              e8.log(m);
            });
          }
        }
      },
      warn: function () {
        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) {
          var m = ["Mixpanel warning:"].concat(tl.toArray(arguments));
          try {
            e8.warn.apply(e8, m);
          } catch (_) {
            tl.each(m, function (m) {
              e8.warn(m);
            });
          }
        }
      },
      error: function () {
        if (eQ.DEBUG && !tl.isUndefined(e8) && e8) {
          var m = ["Mixpanel error:"].concat(tl.toArray(arguments));
          try {
            e8.error.apply(e8, m);
          } catch (_) {
            tl.each(m, function (m) {
              e8.error(m);
            });
          }
        }
      },
      critical: function () {
        if (!tl.isUndefined(e8) && e8) {
          var m = ["Mixpanel error:"].concat(tl.toArray(arguments));
          try {
            e8.error.apply(e8, m);
          } catch (_) {
            tl.each(m, function (m) {
              e8.error(m);
            });
          }
        }
      }
    };
    function log_func_with_prefix(m, _) {
      return function () {
        arguments[0] = "[" + _ + "] " + arguments[0];
        return m.apply(tu, arguments);
      };
    }
    function console_with_prefix(m) {
      return {
        log: log_func_with_prefix(tu.log, m),
        error: log_func_with_prefix(tu.error, m),
        critical: log_func_with_prefix(tu.critical, m)
      };
    }
    tl.bind = function (m, _) {
      var C;
      var R;
      if (tn && m.bind === tn) {
        return tn.apply(m, e5.call(arguments, 1));
      }
      if (!tl.isFunction(m)) {
        throw TypeError();
      }
      C = e5.call(arguments, 2);
      return R = function () {
        if (!(this instanceof R)) {
          return m.apply(_, C.concat(e5.call(arguments)));
        }
        var L = {
          prototype: m.prototype
        };
        var B = new L();
        L.prototype = null;
        var F = m.apply(B, C.concat(e5.call(arguments)));
        if (Object(F) === F) {
          return F;
        } else {
          return B;
        }
      };
    };
    tl.each = function (m, _, C) {
      if (m != null) {
        if (ti && m.forEach === ti) {
          m.forEach(_, C);
        } else if (m.length === +m.length) {
          for (var R = 0, L = m.length; R < L; R++) {
            if (R in m && _.call(C, m[R], R, m) === tc) {
              return;
            }
          }
        } else {
          for (var B in m) {
            if (e4.call(m, B) && _.call(C, m[B], B, m) === tc) {
              return;
            }
          }
        }
      }
    };
    tl.extend = function (m) {
      tl.each(e5.call(arguments, 1), function (_) {
        for (var C in _) {
          if (_[C] !== undefined) {
            m[C] = _[C];
          }
        }
      });
      return m;
    };
    tl.isArray = ts || function (m) {
      return e6.call(m) === "[object Array]";
    };
    tl.isFunction = function (m) {
      try {
        return /^\s*\bfunction\b/.test(m);
      } catch (m) {
        return false;
      }
    };
    tl.isArguments = function (m) {
      return !!m && !!e4.call(m, "callee");
    };
    tl.toArray = function (m) {
      if (m) {
        if (m.toArray) {
          return m.toArray();
        } else if (tl.isArray(m) || tl.isArguments(m)) {
          return e5.call(m);
        } else {
          return tl.values(m);
        }
      } else {
        return [];
      }
    };
    tl.map = function (m, _, C) {
      if (ta && m.map === ta) {
        return m.map(_, C);
      }
      var R = [];
      tl.each(m, function (m) {
        R.push(_.call(C, m));
      });
      return R;
    };
    tl.keys = function (m) {
      var _ = [];
      if (m !== null) {
        tl.each(m, function (m, C) {
          _[_.length] = C;
        });
      }
      return _;
    };
    tl.values = function (m) {
      var _ = [];
      if (m !== null) {
        tl.each(m, function (m) {
          _[_.length] = m;
        });
      }
      return _;
    };
    tl.include = function (m, _) {
      var C = false;
      if (m === null) {
        return C;
      } else if (to && m.indexOf === to) {
        return m.indexOf(_) != -1;
      } else {
        tl.each(m, function (m) {
          if (C ||= m === _) {
            return tc;
          }
        });
        return C;
      }
    };
    tl.includes = function (m, _) {
      return m.indexOf(_) !== -1;
    };
    tl.inherit = function (m, _) {
      m.prototype = new _();
      m.prototype.constructor = m;
      m.superclass = _.prototype;
      return m;
    };
    tl.isObject = function (m) {
      return m === Object(m) && !tl.isArray(m);
    };
    tl.isEmptyObject = function (m) {
      if (tl.isObject(m)) {
        for (var _ in m) {
          if (e4.call(m, _)) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    tl.isUndefined = function (m) {
      return m === undefined;
    };
    tl.isString = function (m) {
      return e6.call(m) == "[object String]";
    };
    tl.isDate = function (m) {
      return e6.call(m) == "[object Date]";
    };
    tl.isNumber = function (m) {
      return e6.call(m) == "[object Number]";
    };
    tl.isElement = function (m) {
      return !!m && m.nodeType === 1;
    };
    tl.encodeDates = function (m) {
      tl.each(m, function (_, C) {
        if (tl.isDate(_)) {
          m[C] = tl.formatDate(_);
        } else if (tl.isObject(_)) {
          m[C] = tl.encodeDates(_);
        }
      });
      return m;
    };
    tl.timestamp = function () {
      Date.now = Date.now || function () {
        return +new Date();
      };
      return Date.now();
    };
    tl.formatDate = function (m) {
      function pad(m) {
        if (m < 10) {
          return "0" + m;
        } else {
          return m;
        }
      }
      return m.getUTCFullYear() + "-" + pad(m.getUTCMonth() + 1) + "-" + pad(m.getUTCDate()) + "T" + pad(m.getUTCHours()) + ":" + pad(m.getUTCMinutes()) + ":" + pad(m.getUTCSeconds());
    };
    tl.strip_empty_properties = function (m) {
      var _ = {};
      tl.each(m, function (m, C) {
        if (tl.isString(m) && m.length > 0) {
          _[C] = m;
        }
      });
      return _;
    };
    tl.truncate = function (m, _) {
      var C;
      if (typeof m == "string") {
        C = m.slice(0, _);
      } else if (tl.isArray(m)) {
        C = [];
        tl.each(m, function (m) {
          C.push(tl.truncate(m, _));
        });
      } else if (tl.isObject(m)) {
        C = {};
        tl.each(m, function (m, R) {
          C[R] = tl.truncate(m, _);
        });
      } else {
        C = m;
      }
      return C;
    };
    tl.JSONEncode = function (m) {
      function quote(m) {
        var _ = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        var C = {
          "\b": "\\b",
          "\t": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          "\"": "\\\"",
          "\\": "\\\\"
        };
        _.lastIndex = 0;
        if (_.test(m)) {
          return "\"" + m.replace(_, function (m) {
            var _ = C[m];
            if (typeof _ == "string") {
              return _;
            } else {
              return "\\u" + ("0000" + m.charCodeAt(0).toString(16)).slice(-4);
            }
          }) + "\"";
        } else {
          return "\"" + m + "\"";
        }
      }
      function str(m, _) {
        var C = "";
        var R = 0;
        var L = "";
        var B = "";
        var F = 0;
        var U = C;
        var H = [];
        var q = _[m];
        if (q && typeof q == "object" && typeof q.toJSON == "function") {
          q = q.toJSON(m);
        }
        switch (typeof q) {
          case "string":
            return quote(q);
          case "number":
            if (isFinite(q)) {
              return String(q);
            } else {
              return "null";
            }
          case "boolean":
          case "null":
            return String(q);
          case "object":
            if (!q) {
              return "null";
            }
            C += "    ";
            H = [];
            if (e6.apply(q) === "[object Array]") {
              R = 0;
              F = q.length;
              for (; R < F; R += 1) {
                H[R] = str(R, q) || "null";
              }
              B = H.length === 0 ? "[]" : C ? "[\n" + C + H.join(",\n" + C) + "\n" + U + "]" : "[" + H.join(",") + "]";
              C = U;
              return B;
            }
            for (L in q) {
              if (e4.call(q, L) && (B = str(L, q))) {
                H.push(quote(L) + (C ? ": " : ":") + B);
              }
            }
            B = H.length === 0 ? "{}" : C ? "{" + H.join(",") + U + "}" : "{" + H.join(",") + "}";
            C = U;
            return B;
        }
      }
      return str("", {
        "": m
      });
    };
    ev = {
      "\"": "\"",
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "\t"
    };
    eb = function (m) {
      var _ = SyntaxError(m);
      _.at = em;
      _.text = ey;
      throw _;
    };
    eS = function (m) {
      if (m && m !== eg) {
        eb("Expected '" + m + "' instead of '" + eg + "'");
      }
      eg = ey.charAt(em);
      em += 1;
      return eg;
    };
    ew = function () {
      var m;
      var _ = "";
      for (eg === "-" && (_ = "-", eS("-")); eg >= "0" && eg <= "9";) {
        _ += eg;
        eS();
      }
      if (eg === ".") {
        for (_ += "."; eS() && eg >= "0" && eg <= "9";) {
          _ += eg;
        }
      }
      if (eg === "e" || eg === "E") {
        _ += eg;
        eS();
        if (eg === "-" || eg === "+") {
          _ += eg;
          eS();
        }
        while (eg >= "0" && eg <= "9") {
          _ += eg;
          eS();
        }
      }
      if (isFinite(m = +_)) {
        return m;
      }
      eb("Bad number");
    };
    eE = function () {
      var m;
      var _;
      var C;
      var R = "";
      if (eg === "\"") {
        while (eS()) {
          if (eg === "\"") {
            eS();
            return R;
          }
          if (eg === "\\") {
            eS();
            if (eg === "u") {
              _ = 0;
              C = 0;
              for (; _ < 4 && isFinite(m = parseInt(eS(), 16)); _ += 1) {
                C = C * 16 + m;
              }
              R += String.fromCharCode(C);
            } else if (typeof ev[eg] == "string") {
              R += ev[eg];
            } else {
              break;
            }
          } else {
            R += eg;
          }
        }
      }
      eb("Bad string");
    };
    ek = function () {
      while (eg && eg <= " ") {
        eS();
      }
    };
    ex = function () {
      switch (eg) {
        case "t":
          eS("t");
          eS("r");
          eS("u");
          eS("e");
          return true;
        case "f":
          eS("f");
          eS("a");
          eS("l");
          eS("s");
          eS("e");
          return false;
        case "n":
          eS("n");
          eS("u");
          eS("l");
          eS("l");
          return null;
      }
      eb("Unexpected \"" + eg + "\"");
    };
    eI = function () {
      var m = [];
      if (eg === "[") {
        eS("[");
        ek();
        if (eg === "]") {
          eS("]");
          return m;
        }
        while (eg) {
          m.push(e_());
          ek();
          if (eg === "]") {
            eS("]");
            return m;
          }
          eS(",");
          ek();
        }
      }
      eb("Bad array");
    };
    eO = function () {
      var m;
      var _ = {};
      if (eg === "{") {
        eS("{");
        ek();
        if (eg === "}") {
          eS("}");
          return _;
        }
        while (eg) {
          m = eE();
          ek();
          eS(":");
          if (Object.hasOwnProperty.call(_, m)) {
            eb("Duplicate key \"" + m + "\"");
          }
          _[m] = e_();
          ek();
          if (eg === "}") {
            eS("}");
            return _;
          }
          eS(",");
          ek();
        }
      }
      eb("Bad object");
    };
    e_ = function () {
      ek();
      switch (eg) {
        case "{":
          return eO();
        case "[":
          return eI();
        case "\"":
          return eE();
        case "-":
          return ew();
        default:
          if (eg >= "0" && eg <= "9") {
            return ew();
          } else {
            return ex();
          }
      }
    };
    tl.JSONDecode = function (m) {
      var _;
      ey = m;
      em = 0;
      eg = " ";
      _ = e_();
      ek();
      if (eg) {
        eb("Syntax error");
      }
      return _;
    };
    tl.base64Encode = function (m) {
      var _;
      var C;
      var R;
      var L;
      var B;
      var F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var U = 0;
      var H = 0;
      var q = "";
      var V = [];
      if (!m) {
        return m;
      }
      m = tl.utf8Encode(m);
      do {
        _ = (B = m.charCodeAt(U++) << 16 | m.charCodeAt(U++) << 8 | m.charCodeAt(U++)) >> 18 & 63;
        C = B >> 12 & 63;
        R = B >> 6 & 63;
        L = B & 63;
        V[H++] = F.charAt(_) + F.charAt(C) + F.charAt(R) + F.charAt(L);
      } while (U < m.length);
      q = V.join("");
      switch (m.length % 3) {
        case 1:
          q = q.slice(0, -2) + "==";
          break;
        case 2:
          q = q.slice(0, -1) + "=";
      }
      return q;
    };
    tl.utf8Encode = function (m) {
      m = (m + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      var _;
      var C;
      var R;
      var L = "";
      var B = 0;
      R = 0;
      _ = C = 0;
      B = m.length;
      for (; R < B; R++) {
        var F = m.charCodeAt(R);
        var U = null;
        if (F < 128) {
          C++;
        } else {
          U = F > 127 && F < 2048 ? String.fromCharCode(F >> 6 | 192, F & 63 | 128) : String.fromCharCode(F >> 12 | 224, F >> 6 & 63 | 128, F & 63 | 128);
        }
        if (U !== null) {
          if (C > _) {
            L += m.substring(_, C);
          }
          L += U;
          _ = C = R + 1;
        }
      }
      if (C > _) {
        L += m.substring(_, m.length);
      }
      return L;
    };
    eC = function () {
      var m;
      var _ = new Date() * 1;
      if (eP.performance && eP.performance.now) {
        m = eP.performance.now();
      } else {
        for (m = 0; _ == new Date() * 1;) {
          m++;
        }
      }
      return _.toString(16) + Math.floor(m).toString(16);
    };
    eM = function () {
      var m;
      var _;
      var C = [];
      var R = 0;
      function xor(m, _) {
        var R;
        var L = 0;
        for (R = 0; R < _.length; R++) {
          L |= C[R] << R * 8;
        }
        return m ^ L;
      }
      for (m = 0; m < tr.length; m++) {
        _ = tr.charCodeAt(m);
        C.unshift(_ & 255);
        if (C.length >= 4) {
          R = xor(R, C);
          C = [];
        }
      }
      if (C.length > 0) {
        R = xor(R, C);
      }
      return R.toString(16);
    };
    tl.UUID = function () {
      var m = (tt.height * tt.width).toString(16);
      return eC() + "-" + Math.random().toString(16).replace(".", "") + "-" + eM() + "-" + m + "-" + eC();
    };
    var td = ["ahrefsbot", "ahrefssiteaudit", "baiduspider", "bingbot", "bingpreview", "chrome-lighthouse", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
    tl.isBlockedUA = function (m) {
      var _;
      _ = 0;
      m = m.toLowerCase();
      for (; _ < td.length; _++) {
        if (m.indexOf(td[_]) !== -1) {
          return true;
        }
      }
      return false;
    };
    tl.HTTPBuildQuery = function (m, _) {
      var C;
      var R;
      var L = [];
      if (tl.isUndefined(_)) {
        _ = "&";
      }
      tl.each(m, function (m, _) {
        C = encodeURIComponent(m.toString());
        R = encodeURIComponent(_);
        L[L.length] = R + "=" + C;
      });
      return L.join(_);
    };
    tl.getQueryParam = function (m, _) {
      var C = "[\\?&]" + (_ = _.replace(/[[]/g, "\\[").replace(/[\]]/g, "\\]")) + "=([^&#]*)";
      var R = new RegExp(C).exec(m);
      if (R === null || R && typeof R[1] != "string" && R[1].length) {
        return "";
      }
      var L = R[1];
      try {
        L = decodeURIComponent(L);
      } catch (m) {
        tu.error("Skipping decoding for malformed query param: " + L);
      }
      return L.replace(/\+/g, " ");
    };
    tl.cookie = {
      get: function (m) {
        var _ = m + "=";
        for (var C = e7.cookie.split(";"), R = 0; R < C.length; R++) {
          for (var L = C[R]; L.charAt(0) == " ";) {
            L = L.substring(1, L.length);
          }
          if (L.indexOf(_) === 0) {
            return decodeURIComponent(L.substring(_.length, L.length));
          }
        }
        return null;
      },
      parse: function (m) {
        var _;
        try {
          _ = tl.JSONDecode(tl.cookie.get(m)) || {};
        } catch (m) {}
        return _;
      },
      set_seconds: function (m, _, C, R, L, B, F) {
        var U = "";
        var H = "";
        var q = "";
        if (F) {
          U = "; domain=" + F;
        } else if (R) {
          var V = extract_domain(e7.location.hostname);
          U = V ? "; domain=." + V : "";
        }
        if (C) {
          var X = new Date();
          X.setTime(X.getTime() + C * 1000);
          H = "; expires=" + X.toGMTString();
        }
        if (B) {
          L = true;
          q = "; SameSite=None";
        }
        if (L) {
          q += "; secure";
        }
        e7.cookie = m + "=" + encodeURIComponent(_) + H + "; path=/" + U + q;
      },
      set: function (m, _, C, R, L, B, F) {
        var U = "";
        var H = "";
        var q = "";
        if (F) {
          U = "; domain=" + F;
        } else if (R) {
          var V = extract_domain(e7.location.hostname);
          U = V ? "; domain=." + V : "";
        }
        if (C) {
          var X = new Date();
          X.setTime(X.getTime() + C * 86400000);
          H = "; expires=" + X.toGMTString();
        }
        if (B) {
          L = true;
          q = "; SameSite=None";
        }
        if (L) {
          q += "; secure";
        }
        var K = m + "=" + encodeURIComponent(_) + H + "; path=/" + U + q;
        e7.cookie = K;
        return K;
      },
      remove: function (m, _, C) {
        tl.cookie.set(m, "", -1, _, false, false, C);
      }
    };
    var tp = null;
    function localStorageSupported(m, _) {
      if (tp !== null && !_) {
        return tp;
      }
      var C = true;
      try {
        m = m || window.localStorage;
        var R = "__mplss_" + cheap_guid(8);
        m.setItem(R, "xyz");
        if (m.getItem(R) !== "xyz") {
          C = false;
        }
        m.removeItem(R);
      } catch (m) {
        C = false;
      }
      tp = C;
      return C;
    }
    tl.localStorage = {
      is_supported: function (m) {
        var _ = localStorageSupported(null, m);
        if (!_) {
          tu.error("localStorage unsupported; falling back to cookie store");
        }
        return _;
      },
      error: function (m) {
        tu.error("localStorage error: " + m);
      },
      get: function (m) {
        try {
          return window.localStorage.getItem(m);
        } catch (m) {
          tl.localStorage.error(m);
        }
        return null;
      },
      parse: function (m) {
        try {
          return tl.JSONDecode(tl.localStorage.get(m)) || {};
        } catch (m) {}
        return null;
      },
      set: function (m, _) {
        try {
          window.localStorage.setItem(m, _);
        } catch (m) {
          tl.localStorage.error(m);
        }
      },
      remove: function (m) {
        try {
          window.localStorage.removeItem(m);
        } catch (m) {
          tl.localStorage.error(m);
        }
      }
    };
    tl.register_event = function () {
      function fixEvent(m) {
        if (m) {
          m.preventDefault = fixEvent.preventDefault;
          m.stopPropagation = fixEvent.stopPropagation;
        }
        return m;
      }
      fixEvent.preventDefault = function () {
        this.returnValue = false;
      };
      fixEvent.stopPropagation = function () {
        this.cancelBubble = true;
      };
      return function (m, _, C, R, L) {
        if (!m) {
          tu.error("No valid element provided to register_event");
          return;
        }
        if (m.addEventListener && !R) {
          m.addEventListener(_, C, !!L);
        } else {
          var B = "on" + _;
          var F = m[B];
          m[B] = function (_) {
            if (_ = _ || fixEvent(window.event)) {
              var R;
              var L;
              var B = true;
              if (tl.isFunction(F)) {
                R = F(_);
              }
              L = C.call(m, _);
              if (R === false || L === false) {
                B = false;
              }
              return B;
            }
          };
        }
      };
    }();
    var th = RegExp("^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?\"?([^\\]\"]*)\"?\\]$");
    tl.dom_query = function () {
      function getAllChildren(m) {
        if (m.all) {
          return m.all;
        } else {
          return m.getElementsByTagName("*");
        }
      }
      var m = /[\t\r\n]/g;
      function getElementsBySelector(_) {
        if (!e7.getElementsByTagName) {
          return [];
        }
        var C = _.split(" ");
        var R = [e7];
        for (Y = 0; Y < C.length; Y++) {
          if ((H = C[Y].replace(/^\s+/, "").replace(/\s+$/, "")).indexOf("#") > -1) {
            V = (q = H.split("#"))[0];
            var L = q[1];
            var B = e7.getElementById(L);
            if (!B || V && B.nodeName.toLowerCase() != V) {
              return [];
            }
            R = [B];
            continue;
          }
          if (H.indexOf(".") > -1) {
            V = (q = H.split("."))[0];
            var F = q[1];
            V ||= "*";
            X = [];
            K = 0;
            Q = 0;
            for (; Q < R.length; Q++) {
              et = 0;
              er = V == "*" ? getAllChildren(R[Q]) : R[Q].getElementsByTagName(V);
              for (; et < er.length; et++) {
                X[K++] = er[et];
              }
            }
            Q = 0;
            R = [];
            en = 0;
            for (; Q < X.length; Q++) {
              if (X[Q].className && tl.isString(X[Q].className) && (" " + X[Q].className + " ").replace(m, " ").indexOf(" " + F + " ") >= 0) {
                R[en++] = X[Q];
              }
            }
            continue;
          }
          var U = H.match(th);
          if (U) {
            V = U[1];
            var H;
            var q;
            var V;
            var X;
            var K;
            var Y;
            var Q;
            var et;
            var er;
            var en;
            var ei;
            var eo = U[2];
            var ea = U[3];
            var es = U[4];
            V ||= "*";
            X = [];
            K = 0;
            Q = 0;
            for (; Q < R.length; Q++) {
              et = 0;
              er = V == "*" ? getAllChildren(R[Q]) : R[Q].getElementsByTagName(V);
              for (; et < er.length; et++) {
                X[K++] = er[et];
              }
            }
            R = [];
            en = 0;
            switch (ea) {
              case "=":
                ei = function (m) {
                  return m.getAttribute(eo) == es;
                };
                break;
              case "~":
                ei = function (m) {
                  return m.getAttribute(eo).match(RegExp("\\b" + es + "\\b"));
                };
                break;
              case "|":
                ei = function (m) {
                  return m.getAttribute(eo).match(RegExp("^" + es + "-?"));
                };
                break;
              case "^":
                ei = function (m) {
                  return m.getAttribute(eo).indexOf(es) === 0;
                };
                break;
              case "$":
                ei = function (m) {
                  return m.getAttribute(eo).lastIndexOf(es) == m.getAttribute(eo).length - es.length;
                };
                break;
              case "*":
                ei = function (m) {
                  return m.getAttribute(eo).indexOf(es) > -1;
                };
                break;
              default:
                ei = function (m) {
                  return m.getAttribute(eo);
                };
            }
            Q = 0;
            R = [];
            en = 0;
            for (; Q < X.length; Q++) {
              if (ei(X[Q])) {
                R[en++] = X[Q];
              }
            }
            continue;
          }
          Q = 0;
          V = H;
          X = [];
          K = 0;
          for (; Q < R.length; Q++) {
            et = 0;
            er = R[Q].getElementsByTagName(V);
            for (; et < er.length; et++) {
              X[K++] = er[et];
            }
          }
          R = X;
        }
        return R;
      }
      return function (m) {
        if (tl.isElement(m)) {
          return [m];
        } else if (tl.isObject(m) && !tl.isUndefined(m.length)) {
          return m;
        } else {
          return getElementsBySelector.call(this, m);
        }
      };
    }();
    var tf = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "utm_id", "utm_source_platform", "utm_campaign_id", "utm_creative_format", "utm_marketing_tactic"];
    var tm = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "sccid", "ttclid", "twclid", "wbraid"];
    tl.info = {
      campaignParams: function (m) {
        var _ = "";
        var C = {};
        tl.each(tf, function (R) {
          if ((_ = tl.getQueryParam(e7.URL, R)).length) {
            C[R] = _;
          } else if (m !== undefined) {
            C[R] = m;
          }
        });
        return C;
      },
      clickParams: function () {
        var m = "";
        var _ = {};
        tl.each(tm, function (C) {
          if ((m = tl.getQueryParam(e7.URL, C)).length) {
            _[C] = m;
          }
        });
        return _;
      },
      marketingParams: function () {
        return tl.extend(tl.info.campaignParams(), tl.info.clickParams());
      },
      searchEngine: function (m) {
        if (m.search("https?://(.*)google.([^/?]*)") === 0) {
          return "google";
        } else if (m.search("https?://(.*)bing.com") === 0) {
          return "bing";
        } else if (m.search("https?://(.*)yahoo.com") === 0) {
          return "yahoo";
        } else if (m.search("https?://(.*)duckduckgo.com") === 0) {
          return "duckduckgo";
        } else {
          return null;
        }
      },
      searchInfo: function (m) {
        var _ = tl.info.searchEngine(m);
        var C = {};
        if (_ !== null) {
          C.$search_engine = _;
          var R = tl.getQueryParam(m, _ != "yahoo" ? "q" : "p");
          if (R.length) {
            C.mp_keyword = R;
          }
        }
        return C;
      },
      browser: function (m, _, C) {
        _ = _ || "";
        if (C || tl.includes(m, " OPR/")) {
          if (tl.includes(m, "Mini")) {
            return "Opera Mini";
          } else {
            return "Opera";
          }
        }
        if (/(BlackBerry|PlayBook|BB10)/i.test(m)) {
          return "BlackBerry";
        }
        if (tl.includes(m, "IEMobile") || tl.includes(m, "WPDesktop")) {
          return "Internet Explorer Mobile";
        }
        if (tl.includes(m, "SamsungBrowser/")) {
          return "Samsung Internet";
        }
        if (tl.includes(m, "Edge") || tl.includes(m, "Edg/")) {
          return "Microsoft Edge";
        }
        if (tl.includes(m, "FBIOS")) {
          return "Facebook Mobile";
        }
        if (tl.includes(m, "Chrome")) {
          return "Chrome";
        } else if (tl.includes(m, "CriOS")) {
          return "Chrome iOS";
        } else if (tl.includes(m, "UCWEB") || tl.includes(m, "UCBrowser")) {
          return "UC Browser";
        } else if (tl.includes(m, "FxiOS")) {
          return "Firefox iOS";
        } else if (tl.includes(_, "Apple")) {
          if (tl.includes(m, "Mobile")) {
            return "Mobile Safari";
          } else {
            return "Safari";
          }
        } else if (tl.includes(m, "Android")) {
          return "Android Mobile";
        } else if (tl.includes(m, "Konqueror")) {
          return "Konqueror";
        } else if (tl.includes(m, "Firefox")) {
          return "Firefox";
        } else if (tl.includes(m, "MSIE") || tl.includes(m, "Trident/")) {
          return "Internet Explorer";
        } else if (tl.includes(m, "Gecko")) {
          return "Mozilla";
        } else {
          return "";
        }
      },
      browserVersion: function (m, _, C) {
        var R = {
          "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
          "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
          Chrome: /Chrome\/(\d+(\.\d+)?)/,
          "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
          "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
          Safari: /Version\/(\d+(\.\d+)?)/,
          "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
          Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
          Firefox: /Firefox\/(\d+(\.\d+)?)/,
          "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
          Konqueror: /Konqueror:(\d+(\.\d+)?)/,
          BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
          "Android Mobile": /android\s(\d+(\.\d+)?)/,
          "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
          "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
          Mozilla: /rv:(\d+(\.\d+)?)/
        }[tl.info.browser(m, _, C)];
        if (R === undefined) {
          return null;
        }
        var L = m.match(R);
        if (L) {
          return parseFloat(L[L.length - 2]);
        } else {
          return null;
        }
      },
      os: function () {
        if (/Windows/i.test(tr)) {
          if (/Phone/.test(tr) || /WPDesktop/.test(tr)) {
            return "Windows Phone";
          } else {
            return "Windows";
          }
        }
        if (/(iPhone|iPad|iPod)/.test(tr)) {
          return "iOS";
        }
        if (/Android/.test(tr)) {
          return "Android";
        }
        if (/(BlackBerry|PlayBook|BB10)/i.test(tr)) {
          return "BlackBerry";
        }
        if (/Mac/i.test(tr)) {
          return "Mac OS X";
        }
        if (/Linux/.test(tr)) {
          return "Linux";
        }
        if (/CrOS/.test(tr)) {
          return "Chrome OS";
        } else {
          return "";
        }
      },
      device: function (m) {
        if (/Windows Phone/i.test(m) || /WPDesktop/.test(m)) {
          return "Windows Phone";
        } else if (/iPad/.test(m)) {
          return "iPad";
        } else if (/iPod/.test(m)) {
          return "iPod Touch";
        } else if (/iPhone/.test(m)) {
          return "iPhone";
        } else if (/(BlackBerry|PlayBook|BB10)/i.test(m)) {
          return "BlackBerry";
        } else if (/Android/.test(m)) {
          return "Android";
        } else {
          return "";
        }
      },
      referringDomain: function (m) {
        var _ = m.split("/");
        if (_.length >= 3) {
          return _[2];
        } else {
          return "";
        }
      },
      currentUrl: function () {
        return eP.location.href;
      },
      properties: function (m) {
        if (typeof m != "object") {
          m = {};
        }
        return tl.extend(tl.strip_empty_properties({
          $os: tl.info.os(),
          $browser: tl.info.browser(tr, e9.vendor, te),
          $referrer: e7.referrer,
          $referring_domain: tl.info.referringDomain(e7.referrer),
          $device: tl.info.device(tr)
        }), {
          $current_url: tl.info.currentUrl(),
          $browser_version: tl.info.browserVersion(tr, e9.vendor, te),
          $screen_height: tt.height,
          $screen_width: tt.width,
          mp_lib: "web",
          $lib_version: eQ.LIB_VERSION,
          $insert_id: cheap_guid(),
          time: tl.timestamp() / 1000
        }, tl.strip_empty_properties(m));
      },
      people_properties: function () {
        return tl.extend(tl.strip_empty_properties({
          $os: tl.info.os(),
          $browser: tl.info.browser(tr, e9.vendor, te)
        }), {
          $browser_version: tl.info.browserVersion(tr, e9.vendor, te)
        });
      },
      mpPageViewProperties: function () {
        return tl.strip_empty_properties({
          current_page_title: e7.title,
          current_domain: eP.location.hostname,
          current_url_path: eP.location.pathname,
          current_url_protocol: eP.location.protocol,
          current_url_search: eP.location.search
        });
      }
    };
    function cheap_guid(m) {
      var _ = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
      if (m) {
        return _.substring(0, m);
      } else {
        return _;
      }
    }
    var tg = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i;
    var ty = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
    function extract_domain(m) {
      var _ = ty;
      var C = m.split(".");
      var R = C[C.length - 1];
      if (R.length > 4 || R === "com" || R === "org") {
        _ = tg;
      }
      var L = m.match(_);
      if (L) {
        return L[0];
      } else {
        return "";
      }
    }
    function isOnline() {
      var m = eP.navigator.onLine;
      return tl.isUndefined(m) || m;
    }
    var t_ = null;
    var tv = null;
    function optIn(m, _) {
      _optInOut(true, m, _);
    }
    function optOut(m, _) {
      _optInOut(false, m, _);
    }
    function hasOptedIn(m, _) {
      return _getStorageValue(m, _) === "1";
    }
    function hasOptedOut(m, _) {
      if (function (m) {
        if (m && m.ignoreDnt) {
          return false;
        }
        var _ = m && m.window || eP;
        var C = _.navigator || {};
        var R = false;
        tl.each([C.doNotTrack, C.msDoNotTrack, _.doNotTrack], function (m) {
          if (tl.includes([true, 1, "1", "yes"], m)) {
            R = true;
          }
        });
        return R;
      }(_)) {
        tu.warn("This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"");
        return true;
      }
      var C = _getStorageValue(m, _) === "0";
      if (C) {
        tu.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.");
      }
      return C;
    }
    function addOptOutCheckMixpanelLib(m) {
      return _addOptOutCheck(m, function (m) {
        return this.get_config(m);
      });
    }
    function addOptOutCheckMixpanelPeople(m) {
      return _addOptOutCheck(m, function (m) {
        return this._get_config(m);
      });
    }
    function addOptOutCheckMixpanelGroup(m) {
      return _addOptOutCheck(m, function (m) {
        return this._get_config(m);
      });
    }
    function clearOptInOut(m, _) {
      _getStorage(_ = _ || {}).remove(_getStorageKey(m, _), !!_.crossSubdomainCookie, _.cookieDomain);
    }
    function _getStorage(m) {
      if ((m = m || {}).persistenceType === "localStorage") {
        return tl.localStorage;
      } else {
        return tl.cookie;
      }
    }
    function _getStorageKey(m, _) {
      return ((_ = _ || {}).persistencePrefix || "__mp_opt_in_out_") + m;
    }
    function _getStorageValue(m, _) {
      return _getStorage(_).get(_getStorageKey(m, _));
    }
    function _optInOut(m, _, C) {
      if (!tl.isString(_) || !_.length) {
        tu.error("gdpr." + (m ? "optIn" : "optOut") + " called with an invalid token");
        return;
      }
      _getStorage(C = C || {}).set(_getStorageKey(_, C), m ? 1 : 0, tl.isNumber(C.cookieExpiration) ? C.cookieExpiration : null, !!C.crossSubdomainCookie, !!C.secureCookie, !!C.crossSiteCookie, C.cookieDomain);
      if (C.track && m) {
        C.track(C.trackEventName || "$opt_in", C.trackProperties, {
          send_immediately: true
        });
      }
    }
    function _addOptOutCheck(m, _) {
      return function () {
        var C = false;
        try {
          var R = _.call(this, "token");
          var L = _.call(this, "ignore_dnt");
          var B = _.call(this, "opt_out_tracking_persistence_type");
          var F = _.call(this, "opt_out_tracking_cookie_prefix");
          var U = _.call(this, "window");
          if (R) {
            C = hasOptedOut(R, {
              ignoreDnt: L,
              persistenceType: B,
              persistencePrefix: F,
              window: U
            });
          }
        } catch (m) {
          tu.error("Unexpected error when checking tracking opt-out status: " + m);
        }
        if (!C) {
          return m.apply(this, arguments);
        }
        var H = arguments[arguments.length - 1];
        if (typeof H == "function") {
          H(0);
        }
      };
    }
    if (typeof JSON != "undefined") {
      t_ = JSON.stringify;
      tv = JSON.parse;
    }
    t_ = t_ || tl.JSONEncode;
    tv = tv || tl.JSONDecode;
    tl.toArray = tl.toArray;
    tl.isObject = tl.isObject;
    tl.JSONEncode = tl.JSONEncode;
    tl.JSONDecode = tl.JSONDecode;
    tl.isBlockedUA = tl.isBlockedUA;
    tl.isEmptyObject = tl.isEmptyObject;
    tl.info = tl.info;
    tl.info.device = tl.info.device;
    tl.info.browser = tl.info.browser;
    tl.info.browserVersion = tl.info.browserVersion;
    tl.info.properties = tl.info.properties;
    var tb = console_with_prefix("lock");
    function SharedLock(m, _) {
      _ = _ || {};
      this.storageKey = m;
      this.storage = _.storage || window.localStorage;
      this.pollIntervalMS = _.pollIntervalMS || 100;
      this.timeoutMS = _.timeoutMS || 2000;
    }
    SharedLock.prototype.withLock = function (m, _, C) {
      if (!C && typeof _ != "function") {
        C = _;
        _ = null;
      }
      var R = C || new Date().getTime() + "|" + Math.random();
      var L = new Date().getTime();
      var B = this.storageKey;
      var F = this.pollIntervalMS;
      var U = this.timeoutMS;
      var H = this.storage;
      var q = B + ":X";
      var V = B + ":Y";
      var X = B + ":Z";
      function reportError(m) {
        if (_) {
          _(m);
        }
      }
      function delay(m) {
        if (new Date().getTime() - L > U) {
          tb.error("Timeout waiting for mutex on " + B + "; clearing lock. [" + R + "]");
          H.removeItem(X);
          H.removeItem(V);
          loop();
          return;
        }
        setTimeout(function () {
          try {
            m();
          } catch (m) {
            reportError(m);
          }
        }, F * (Math.random() + 0.1));
      }
      function waitFor(m, _) {
        if (m()) {
          _();
        } else {
          delay(function () {
            waitFor(m, _);
          });
        }
      }
      function getSetY() {
        var m = H.getItem(V);
        if (m && m !== R) {
          return false;
        }
        H.setItem(V, R);
        if (H.getItem(V) === R) {
          return true;
        }
        if (!localStorageSupported(H, true)) {
          throw Error("localStorage support dropped while acquiring lock");
        }
        return false;
      }
      function loop() {
        H.setItem(q, R);
        waitFor(getSetY, function () {
          if (H.getItem(q) === R) {
            criticalSection();
            return;
          }
          delay(function () {
            if (H.getItem(V) !== R) {
              loop();
              return;
            }
            waitFor(function () {
              return !H.getItem(X);
            }, criticalSection);
          });
        });
      }
      function criticalSection() {
        H.setItem(X, "1");
        try {
          m();
        } finally {
          H.removeItem(X);
          if (H.getItem(V) === R) {
            H.removeItem(V);
          }
          if (H.getItem(q) === R) {
            H.removeItem(q);
          }
        }
      }
      try {
        if (localStorageSupported(H, true)) {
          loop();
        } else {
          throw Error("localStorage support check failed");
        }
      } catch (m) {
        reportError(m);
      }
    };
    var tS = console_with_prefix("batch");
    function RequestQueue(m, _) {
      _ = _ || {};
      this.storageKey = m;
      this.storage = _.storage || window.localStorage;
      this.reportError = _.errorReporter || tl.bind(tS.error, tS);
      this.lock = new SharedLock(m, {
        storage: this.storage
      });
      this.usePersistence = _.usePersistence;
      this.pid = _.pid || null;
      this.memQueue = [];
    }
    RequestQueue.prototype.enqueue = function (m, _, C) {
      var R = {
        id: cheap_guid(),
        flushAfter: new Date().getTime() + _ * 2,
        payload: m
      };
      if (this.usePersistence) {
        this.lock.withLock(tl.bind(function () {
          var _;
          try {
            var L = this.readFromStorage();
            L.push(R);
            if (_ = this.saveToStorage(L)) {
              this.memQueue.push(R);
            }
          } catch (C) {
            this.reportError("Error enqueueing item", m);
            _ = false;
          }
          if (C) {
            C(_);
          }
        }, this), tl.bind(function (m) {
          this.reportError("Error acquiring storage lock", m);
          if (C) {
            C(false);
          }
        }, this), this.pid);
      } else {
        this.memQueue.push(R);
        if (C) {
          C(true);
        }
      }
    };
    RequestQueue.prototype.fillBatch = function (m) {
      var _ = this.memQueue.slice(0, m);
      if (this.usePersistence && _.length < m) {
        var C = this.readFromStorage();
        if (C.length) {
          var R = {};
          tl.each(_, function (m) {
            R[m.id] = true;
          });
          for (var L = 0; L < C.length; L++) {
            var B = C[L];
            if (new Date().getTime() > B.flushAfter && !R[B.id] && (B.orphaned = true, _.push(B), _.length >= m)) {
              break;
            }
          }
        }
      }
      return _;
    };
    function filterOutIDsAndInvalid(m, _) {
      var C = [];
      tl.each(m, function (m) {
        if (m.id && !_[m.id]) {
          C.push(m);
        }
      });
      return C;
    }
    RequestQueue.prototype.removeItemsByID = function (m, _) {
      var C = {};
      tl.each(m, function (m) {
        C[m] = true;
      });
      this.memQueue = filterOutIDsAndInvalid(this.memQueue, C);
      if (this.usePersistence) {
        var R = tl.bind(function () {
          var _;
          try {
            var R = this.readFromStorage();
            R = filterOutIDsAndInvalid(R, C);
            if (_ = this.saveToStorage(R)) {
              R = this.readFromStorage();
              for (var L = 0; L < R.length; L++) {
                var B = R[L];
                if (B.id && C[B.id]) {
                  this.reportError("Item not removed from storage");
                  return false;
                }
              }
            }
          } catch (C) {
            this.reportError("Error removing items", m);
            _ = false;
          }
          return _;
        }, this);
        this.lock.withLock(function () {
          var m = R();
          if (_) {
            _(m);
          }
        }, tl.bind(function (m) {
          var C = false;
          this.reportError("Error acquiring storage lock", m);
          if (!localStorageSupported(this.storage, true) && !(C = R())) {
            try {
              this.storage.removeItem(this.storageKey);
            } catch (m) {
              this.reportError("Error clearing queue", m);
            }
          }
          if (_) {
            _(C);
          }
        }, this), this.pid);
      } else if (_) {
        _(true);
      }
    };
    function updatePayloads(m, _) {
      var C = [];
      tl.each(m, function (m) {
        var R = m.id;
        if (R in _) {
          var L = _[R];
          if (L !== null) {
            m.payload = L;
            C.push(m);
          }
        } else {
          C.push(m);
        }
      });
      return C;
    }
    RequestQueue.prototype.updatePayloads = function (m, _) {
      this.memQueue = updatePayloads(this.memQueue, m);
      if (this.usePersistence) {
        this.lock.withLock(tl.bind(function () {
          var C;
          try {
            var R = this.readFromStorage();
            R = updatePayloads(R, m);
            C = this.saveToStorage(R);
          } catch (_) {
            this.reportError("Error updating items", m);
            C = false;
          }
          if (_) {
            _(C);
          }
        }, this), tl.bind(function (m) {
          this.reportError("Error acquiring storage lock", m);
          if (_) {
            _(false);
          }
        }, this), this.pid);
      } else if (_) {
        _(true);
      }
    };
    RequestQueue.prototype.readFromStorage = function () {
      var m;
      try {
        if (m = this.storage.getItem(this.storageKey)) {
          m = tv(m);
          if (!tl.isArray(m)) {
            this.reportError("Invalid storage entry:", m);
            m = null;
          }
        }
      } catch (_) {
        this.reportError("Error retrieving queue", _);
        m = null;
      }
      return m || [];
    };
    RequestQueue.prototype.saveToStorage = function (m) {
      try {
        this.storage.setItem(this.storageKey, t_(m));
        return true;
      } catch (m) {
        this.reportError("Error saving queue", m);
        return false;
      }
    };
    RequestQueue.prototype.clear = function () {
      this.memQueue = [];
      if (this.usePersistence) {
        this.storage.removeItem(this.storageKey);
      }
    };
    var tw = console_with_prefix("batch");
    function RequestBatcher(m, _) {
      this.errorReporter = _.errorReporter;
      this.queue = new RequestQueue(m, {
        errorReporter: tl.bind(this.reportError, this),
        storage: _.storage,
        usePersistence: _.usePersistence
      });
      this.libConfig = _.libConfig;
      this.sendRequest = _.sendRequestFunc;
      this.beforeSendHook = _.beforeSendHook;
      this.stopAllBatching = _.stopAllBatchingFunc;
      this.batchSize = this.libConfig.batch_size;
      this.flushInterval = this.libConfig.batch_flush_interval_ms;
      this.stopped = !this.libConfig.batch_autostart;
      this.consecutiveRemovalFailures = 0;
      this.itemIdsSentSuccessfully = {};
      this.flushOnlyOnInterval = _.flushOnlyOnInterval || false;
    }
    RequestBatcher.prototype.enqueue = function (m, _) {
      this.queue.enqueue(m, this.flushInterval, _);
    };
    RequestBatcher.prototype.start = function () {
      this.stopped = false;
      this.consecutiveRemovalFailures = 0;
      this.flush();
    };
    RequestBatcher.prototype.stop = function () {
      this.stopped = true;
      if (this.timeoutID) {
        clearTimeout(this.timeoutID);
        this.timeoutID = null;
      }
    };
    RequestBatcher.prototype.clear = function () {
      this.queue.clear();
    };
    RequestBatcher.prototype.resetBatchSize = function () {
      this.batchSize = this.libConfig.batch_size;
    };
    RequestBatcher.prototype.resetFlush = function () {
      this.scheduleFlush(this.libConfig.batch_flush_interval_ms);
    };
    RequestBatcher.prototype.scheduleFlush = function (m) {
      this.flushInterval = m;
      if (!this.stopped) {
        this.timeoutID = setTimeout(tl.bind(function () {
          if (!this.stopped) {
            this.flush();
          }
        }, this), this.flushInterval);
      }
    };
    RequestBatcher.prototype.flush = function (m) {
      try {
        if (this.requestInProgress) {
          tw.log("Flush: Request already in progress");
          return;
        }
        m = m || {};
        var _ = this.libConfig.batch_request_timeout_ms;
        var C = new Date().getTime();
        var R = this.batchSize;
        var L = this.queue.fillBatch(R);
        var B = L.length === R;
        var F = [];
        var U = {};
        tl.each(L, function (m) {
          var _ = m.payload;
          if (this.beforeSendHook && !m.orphaned) {
            _ = this.beforeSendHook(_);
          }
          if (_) {
            if (_.event && _.properties) {
              _.properties = tl.extend({}, _.properties, {
                mp_sent_by_lib_version: eQ.LIB_VERSION
              });
            }
            var C = true;
            var R = m.id;
            if (R) {
              if ((this.itemIdsSentSuccessfully[R] || 0) > 5) {
                this.reportError("[dupe] item ID sent too many times, not sending", {
                  item: m,
                  batchSize: L.length,
                  timesSent: this.itemIdsSentSuccessfully[R]
                });
                C = false;
              }
            } else {
              this.reportError("[dupe] found item with no ID", {
                item: m
              });
            }
            if (C) {
              F.push(_);
            }
          }
          U[m.id] = _;
        }, this);
        if (F.length < 1) {
          this.resetFlush();
          return;
        }
        this.requestInProgress = true;
        var H = tl.bind(function (F) {
          this.requestInProgress = false;
          try {
            var H = false;
            if (m.unloading) {
              this.queue.updatePayloads(U);
            } else if (tl.isObject(F) && F.error === "timeout" && new Date().getTime() - C >= _) {
              this.reportError("Network timeout; retrying");
              this.flush();
            } else if (tl.isObject(F) && (F.httpStatusCode >= 500 || F.httpStatusCode === 429 || F.httpStatusCode <= 0 && !isOnline() || F.error === "timeout")) {
              var q = this.flushInterval * 2;
              if (F.retryAfter) {
                q = parseInt(F.retryAfter, 10) * 1000 || q;
              }
              q = Math.min(600000, q);
              this.reportError("Error; retry in " + q + " ms");
              this.scheduleFlush(q);
            } else if (tl.isObject(F) && F.httpStatusCode === 413) {
              if (L.length > 1) {
                var V = Math.max(1, Math.floor(R / 2));
                this.batchSize = Math.min(this.batchSize, V, L.length - 1);
                this.reportError("413 response; reducing batch size to " + this.batchSize);
                this.resetFlush();
              } else {
                this.reportError("Single-event request too large; dropping", L);
                this.resetBatchSize();
                H = true;
              }
            } else {
              H = true;
            }
            if (H) {
              this.queue.removeItemsByID(tl.map(L, function (m) {
                return m.id;
              }), tl.bind(function (m) {
                if (m) {
                  this.consecutiveRemovalFailures = 0;
                  if (this.flushOnlyOnInterval && !B) {
                    this.resetFlush();
                  } else {
                    this.flush();
                  }
                } else {
                  this.reportError("Failed to remove items from queue");
                  if (++this.consecutiveRemovalFailures > 5) {
                    this.reportError("Too many queue failures; disabling batching system.");
                    this.stopAllBatching();
                  } else {
                    this.resetFlush();
                  }
                }
              }, this));
              tl.each(L, tl.bind(function (m) {
                var _ = m.id;
                if (_) {
                  this.itemIdsSentSuccessfully[_] = this.itemIdsSentSuccessfully[_] || 0;
                  this.itemIdsSentSuccessfully[_]++;
                  if (this.itemIdsSentSuccessfully[_] > 5) {
                    this.reportError("[dupe] item ID sent too many times", {
                      item: m,
                      batchSize: L.length,
                      timesSent: this.itemIdsSentSuccessfully[_]
                    });
                  }
                } else {
                  this.reportError("[dupe] found item with no ID while removing", {
                    item: m
                  });
                }
              }, this));
            }
          } catch (m) {
            this.reportError("Error handling API response", m);
            this.resetFlush();
          }
        }, this);
        var q = {
          method: "POST",
          verbose: true,
          ignore_json_errors: true,
          timeout_ms: _
        };
        if (m.unloading) {
          q.transport = "sendBeacon";
        }
        tw.log("MIXPANEL REQUEST:", F);
        this.sendRequest(F, q, H);
      } catch (m) {
        this.reportError("Error flushing request queue", m);
        this.resetFlush();
      }
    };
    RequestBatcher.prototype.reportError = function (m, _) {
      tw.error.apply(tw.error, arguments);
      if (this.errorReporter) {
        try {
          if (!(_ instanceof Error)) {
            _ = Error(m);
          }
          this.errorReporter(m, _);
        } catch (m) {
          tw.error(m);
        }
      }
    };
    var tE = console_with_prefix("recorder");
    var tk = eP.CompressionStream;
    var tx = {
      batch_size: 1000,
      batch_flush_interval_ms: 10000,
      batch_request_timeout_ms: 90000,
      batch_autostart: true
    };
    var tI = new Set([eY.MouseMove, eY.MouseInteraction, eY.Scroll, eY.ViewportResize, eY.Input, eY.TouchMove, eY.MediaInteraction, eY.Drag, eY.Selection]);
    function MixpanelRecorder(m) {
      this._mixpanel = m;
      this._stopRecording = null;
      this.recEvents = [];
      this.seqNo = 0;
      this.replayId = null;
      this.replayStartTime = null;
      this.sendBatchId = null;
      this.idleTimeoutId = null;
      this.maxTimeoutId = null;
      this.recordMaxMs = 86400000;
      this.recordMinMs = 0;
      this._initBatcher();
    }
    MixpanelRecorder.prototype._initBatcher = function () {
      this.batcher = new RequestBatcher("__mprec", {
        libConfig: tx,
        sendRequestFunc: tl.bind(this.flushEventsWithOptOut, this),
        errorReporter: tl.bind(this.reportError, this),
        flushOnlyOnInterval: true,
        usePersistence: false
      });
    };
    MixpanelRecorder.prototype.get_config = function (m) {
      return this._mixpanel.get_config(m);
    };
    MixpanelRecorder.prototype.startRecording = function (m) {
      if (this._stopRecording !== null) {
        tE.log("Recording already in progress, skipping startRecording.");
        return;
      }
      this.recordMaxMs = this.get_config("record_max_ms");
      if (this.recordMaxMs > 86400000) {
        this.recordMaxMs = 86400000;
        tE.critical("record_max_ms cannot be greater than 86400000ms. Capping value.");
      }
      this.recordMinMs = this.get_config("record_min_ms");
      if (this.recordMinMs > 8000) {
        this.recordMinMs = 8000;
        tE.critical("record_min_ms cannot be greater than 8000ms. Capping value.");
      }
      this.recEvents = [];
      this.seqNo = 0;
      this.replayStartTime = new Date().getTime();
      this.replayId = tl.UUID();
      if (m || this.recordMinMs > 0) {
        this.batcher.stop();
      } else {
        this.batcher.start();
      }
      var _ = tl.bind(function () {
        clearTimeout(this.idleTimeoutId);
        this.idleTimeoutId = setTimeout(tl.bind(function () {
          tE.log("Idle timeout reached, restarting recording.");
          this.resetRecording();
        }, this), this.get_config("record_idle_timeout_ms"));
      }, this);
      var C = this.get_config("record_block_selector");
      if (C === "" || C === null) {
        C = undefined;
      }
      this._stopRecording = record({
        emit: tl.bind(function (m) {
          this.batcher.enqueue(m);
          if (m.type === eZ.IncrementalSnapshot && tI.has(m.data.source)) {
            if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {
              this.batcher.start();
            }
            _();
          }
        }, this),
        blockClass: this.get_config("record_block_class"),
        blockSelector: C,
        collectFonts: this.get_config("record_collect_fonts"),
        inlineImages: this.get_config("record_inline_images"),
        maskAllInputs: true,
        maskTextClass: this.get_config("record_mask_text_class"),
        maskTextSelector: this.get_config("record_mask_text_selector")
      });
      _();
      this.maxTimeoutId = setTimeout(tl.bind(this.resetRecording, this), this.recordMaxMs);
    };
    MixpanelRecorder.prototype.resetRecording = function () {
      this.stopRecording();
      this.startRecording(true);
    };
    MixpanelRecorder.prototype.stopRecording = function () {
      if (this._stopRecording !== null) {
        this._stopRecording();
        this._stopRecording = null;
      }
      if (this.batcher.stopped) {
        this.batcher.clear();
      } else {
        this.batcher.flush();
        this.batcher.stop();
      }
      this.replayId = null;
      clearTimeout(this.idleTimeoutId);
      clearTimeout(this.maxTimeoutId);
    };
    MixpanelRecorder.prototype.flushEventsWithOptOut = function (m, _, C) {
      this._flushEvents(m, _, C, tl.bind(this._onOptOut, this));
    };
    MixpanelRecorder.prototype._onOptOut = function (m) {
      if (m === 0) {
        this.recEvents = [];
        this.stopRecording();
      }
    };
    MixpanelRecorder.prototype._sendRequest = function (m, _, C, R) {
      var L = tl.bind(function (_, C) {
        if (_.status === 200 && this.replayId === m) {
          this.seqNo++;
        }
        R({
          status: 0,
          httpStatusCode: _.status,
          responseBody: C,
          retryAfter: _.headers.get("Retry-After")
        });
      }, this);
      eP.fetch(this.get_config("api_host") + "/" + this.get_config("api_routes").record + "?" + new URLSearchParams(_), {
        method: "POST",
        headers: {
          Authorization: "Basic " + btoa(this.get_config("token") + ":"),
          "Content-Type": "application/octet-stream"
        },
        body: C
      }).then(function (m) {
        m.json().then(function (_) {
          L(m, _);
        }).catch(function (m) {
          R({
            error: m
          });
        });
      }).catch(function (m) {
        R({
          error: m,
          httpStatusCode: 0
        });
      });
    };
    MixpanelRecorder.prototype._flushEvents = addOptOutCheckMixpanelLib(function (m, _, C) {
      let R = m.length;
      if (R > 0) {
        var L = this.replayId;
        var B = m[0].timestamp;
        if (this.seqNo === 0 || !this.replayStartTime) {
          if (this.seqNo !== 0) {
            this.reportError("Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.");
          }
          this.replayStartTime = B;
        }
        var F = m[R - 1].timestamp - this.replayStartTime;
        var U = {
          distinct_id: String(this._mixpanel.get_distinct_id()),
          seq: this.seqNo,
          batch_start_time: B / 1000,
          replay_id: L,
          replay_length_ms: F,
          replay_start_time: this.replayStartTime / 1000
        };
        var H = tl.JSONEncode(m);
        var q = this._mixpanel.get_property("$device_id");
        if (q) {
          U.$device_id = q;
        }
        var V = this._mixpanel.get_property("$user_id");
        if (V) {
          U.$user_id = V;
        }
        if (tk) {
          var X = new Blob([H], {
            type: "application/json"
          }).stream().pipeThrough(new tk("gzip"));
          new Response(X).blob().then(tl.bind(function (m) {
            U.format = "gzip";
            this._sendRequest(L, U, m, C);
          }, this));
        } else {
          U.format = "body";
          this._sendRequest(L, U, H, C);
        }
      }
    });
    MixpanelRecorder.prototype.reportError = function (m, _) {
      tE.error.apply(tE.error, arguments);
      try {
        if (!_ && !(m instanceof Error)) {
          m = Error(m);
        }
        this.get_config("error_reporter")(m, _);
      } catch (m) {
        tE.error(m);
      }
    };
    eP.__mp_recorder = MixpanelRecorder;
    function DomTracker() {}
    DomTracker.prototype.create_properties = function () {};
    DomTracker.prototype.event_handler = function () {};
    DomTracker.prototype.after_track_handler = function () {};
    DomTracker.prototype.init = function (m) {
      this.mp = m;
      return this;
    };
    DomTracker.prototype.track = function (m, _, C, R) {
      var L = this;
      var B = tl.dom_query(m);
      if (B.length === 0) {
        tu.error("The DOM query (" + m + ") returned 0 elements");
        return;
      }
      tl.each(B, function (m) {
        tl.register_event(m, this.override_event, function (m) {
          var B = {};
          var F = L.create_properties(C, this);
          var U = L.mp.get_config("track_links_timeout");
          L.event_handler(m, this, B);
          window.setTimeout(L.track_callback(R, F, B, true), U);
          L.mp.track(_, F, L.track_callback(R, F, B));
        });
      }, this);
      return true;
    };
    DomTracker.prototype.track_callback = function (m, _, C, R) {
      R = R || false;
      var L = this;
      return function () {
        if (!C.callback_fired) {
          C.callback_fired = true;
          if (!m || m(R, _) !== false) {
            L.after_track_handler(_, C, R);
          }
        }
      };
    };
    DomTracker.prototype.create_properties = function (m, _) {
      if (typeof m == "function") {
        return m(_);
      } else {
        return tl.extend({}, m);
      }
    };
    function LinkTracker() {
      this.override_event = "click";
    }
    tl.inherit(LinkTracker, DomTracker);
    LinkTracker.prototype.create_properties = function (m, _) {
      var C = LinkTracker.superclass.create_properties.apply(this, arguments);
      if (_.href) {
        C.url = _.href;
      }
      return C;
    };
    LinkTracker.prototype.event_handler = function (m, _, C) {
      C.new_tab = m.which === 2 || m.metaKey || m.ctrlKey || _.target === "_blank";
      C.href = _.href;
      if (!C.new_tab) {
        m.preventDefault();
      }
    };
    LinkTracker.prototype.after_track_handler = function (m, _) {
      if (!_.new_tab) {
        setTimeout(function () {
          window.location = _.href;
        }, 0);
      }
    };
    function FormTracker() {
      this.override_event = "submit";
    }
    tl.inherit(FormTracker, DomTracker);
    FormTracker.prototype.event_handler = function (m, _, C) {
      C.element = _;
      m.preventDefault();
    };
    FormTracker.prototype.after_track_handler = function (m, _) {
      setTimeout(function () {
        _.element.submit();
      }, 0);
    };
    var tO = "$set";
    var tC = "$set_once";
    var tM = "$unset";
    var tT = "$add";
    var tA = "$append";
    var tR = "$union";
    var tP = "$remove";
    var tD = {
      set_action: function (m, _) {
        var C = {};
        var R = {};
        if (tl.isObject(m)) {
          tl.each(m, function (m, _) {
            if (!this._is_reserved_property(_)) {
              R[_] = m;
            }
          }, this);
        } else {
          R[m] = _;
        }
        C[tO] = R;
        return C;
      },
      unset_action: function (m) {
        var _ = {};
        var C = [];
        if (!tl.isArray(m)) {
          m = [m];
        }
        tl.each(m, function (m) {
          if (!this._is_reserved_property(m)) {
            C.push(m);
          }
        }, this);
        _[tM] = C;
        return _;
      },
      set_once_action: function (m, _) {
        var C = {};
        var R = {};
        if (tl.isObject(m)) {
          tl.each(m, function (m, _) {
            if (!this._is_reserved_property(_)) {
              R[_] = m;
            }
          }, this);
        } else {
          R[m] = _;
        }
        C[tC] = R;
        return C;
      },
      union_action: function (m, _) {
        var C = {};
        var R = {};
        if (tl.isObject(m)) {
          tl.each(m, function (m, _) {
            if (!this._is_reserved_property(_)) {
              R[_] = tl.isArray(m) ? m : [m];
            }
          }, this);
        } else {
          R[m] = tl.isArray(_) ? _ : [_];
        }
        C[tR] = R;
        return C;
      },
      append_action: function (m, _) {
        var C = {};
        var R = {};
        if (tl.isObject(m)) {
          tl.each(m, function (m, _) {
            if (!this._is_reserved_property(_)) {
              R[_] = m;
            }
          }, this);
        } else {
          R[m] = _;
        }
        C[tA] = R;
        return C;
      },
      remove_action: function (m, _) {
        var C = {};
        var R = {};
        if (tl.isObject(m)) {
          tl.each(m, function (m, _) {
            if (!this._is_reserved_property(_)) {
              R[_] = m;
            }
          }, this);
        } else {
          R[m] = _;
        }
        C[tP] = R;
        return C;
      },
      delete_action: function () {
        return {
          $delete: ""
        };
      }
    };
    function MixpanelGroup() {}
    tl.extend(MixpanelGroup.prototype, tD);
    MixpanelGroup.prototype._init = function (m, _, C) {
      this._mixpanel = m;
      this._group_key = _;
      this._group_id = C;
    };
    MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function (m, _, C) {
      var R = this.set_action(m, _);
      if (tl.isObject(m)) {
        C = _;
      }
      return this._send_request(R, C);
    });
    MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function (m, _, C) {
      var R = this.set_once_action(m, _);
      if (tl.isObject(m)) {
        C = _;
      }
      return this._send_request(R, C);
    });
    MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function (m, _) {
      var C = this.unset_action(m);
      return this._send_request(C, _);
    });
    MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function (m, _, C) {
      if (tl.isObject(m)) {
        C = _;
      }
      var R = this.union_action(m, _);
      return this._send_request(R, C);
    });
    MixpanelGroup.prototype.delete = addOptOutCheckMixpanelGroup(function (m) {
      var _ = this.delete_action();
      return this._send_request(_, m);
    });
    MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function (m, _, C) {
      var R = this.remove_action(m, _);
      return this._send_request(R, C);
    });
    MixpanelGroup.prototype._send_request = function (m, _) {
      m.$group_key = this._group_key;
      m.$group_id = this._group_id;
      m.$token = this._get_config("token");
      var C = tl.encodeDates(m);
      return this._mixpanel._track_or_batch({
        type: "groups",
        data: C,
        endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").groups,
        batcher: this._mixpanel.request_batchers.groups
      }, _);
    };
    MixpanelGroup.prototype._is_reserved_property = function (m) {
      return m === "$group_key" || m === "$group_id";
    };
    MixpanelGroup.prototype._get_config = function (m) {
      return this._mixpanel.get_config(m);
    };
    MixpanelGroup.prototype.toString = function () {
      return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id;
    };
    MixpanelGroup.prototype.remove = MixpanelGroup.prototype.remove;
    MixpanelGroup.prototype.set = MixpanelGroup.prototype.set;
    MixpanelGroup.prototype.set_once = MixpanelGroup.prototype.set_once;
    MixpanelGroup.prototype.union = MixpanelGroup.prototype.union;
    MixpanelGroup.prototype.unset = MixpanelGroup.prototype.unset;
    MixpanelGroup.prototype.toString = MixpanelGroup.prototype.toString;
    function MixpanelPeople() {}
    tl.extend(MixpanelPeople.prototype, tD);
    MixpanelPeople.prototype._init = function (m) {
      this._mixpanel = m;
    };
    MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function (m, _, C) {
      var R = this.set_action(m, _);
      if (tl.isObject(m)) {
        C = _;
      }
      if (this._get_config("save_referrer")) {
        this._mixpanel.persistence.update_referrer_info(document.referrer);
      }
      R[tO] = tl.extend({}, tl.info.people_properties(), R[tO]);
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function (m, _, C) {
      var R = this.set_once_action(m, _);
      if (tl.isObject(m)) {
        C = _;
      }
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function (m, _) {
      var C = this.unset_action(m);
      return this._send_request(C, _);
    });
    MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function (m, _, C) {
      var R = {};
      var L = {};
      if (tl.isObject(m)) {
        tl.each(m, function (m, _) {
          if (!this._is_reserved_property(_)) {
            if (isNaN(parseFloat(m))) {
              tu.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
              return;
            }
            L[_] = m;
          }
        }, this);
        C = _;
      } else {
        if (tl.isUndefined(_)) {
          _ = 1;
        }
        L[m] = _;
      }
      R[tT] = L;
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function (m, _, C) {
      if (tl.isObject(m)) {
        C = _;
      }
      var R = this.append_action(m, _);
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function (m, _, C) {
      if (tl.isObject(m)) {
        C = _;
      }
      var R = this.remove_action(m, _);
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function (m, _, C) {
      if (tl.isObject(m)) {
        C = _;
      }
      var R = this.union_action(m, _);
      return this._send_request(R, C);
    });
    MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function (m, _, C) {
      if (!tl.isNumber(m) && isNaN(m = parseFloat(m))) {
        tu.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
        return;
      }
      return this.append("$transactions", tl.extend({
        $amount: m
      }, _), C);
    });
    MixpanelPeople.prototype.clear_charges = function (m) {
      return this.set("$transactions", [], m);
    };
    MixpanelPeople.prototype.delete_user = function () {
      if (!this._identify_called()) {
        tu.error("mixpanel.people.delete_user() requires you to call identify() first");
        return;
      }
      var m = {
        $delete: this._mixpanel.get_distinct_id()
      };
      return this._send_request(m);
    };
    MixpanelPeople.prototype.toString = function () {
      return this._mixpanel.toString() + ".people";
    };
    MixpanelPeople.prototype._send_request = function (m, _) {
      m.$token = this._get_config("token");
      m.$distinct_id = this._mixpanel.get_distinct_id();
      var C = this._mixpanel.get_property("$device_id");
      var R = this._mixpanel.get_property("$user_id");
      var L = this._mixpanel.get_property("$had_persisted_distinct_id");
      if (C) {
        m.$device_id = C;
      }
      if (R) {
        m.$user_id = R;
      }
      if (L) {
        m.$had_persisted_distinct_id = L;
      }
      var B = tl.encodeDates(m);
      if (this._identify_called()) {
        return this._mixpanel._track_or_batch({
          type: "people",
          data: B,
          endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").engage,
          batcher: this._mixpanel.request_batchers.people
        }, _);
      } else {
        this._enqueue(m);
        if (!tl.isUndefined(_)) {
          _(this._get_config("verbose") ? {
            status: -1,
            error: null
          } : -1);
        }
        return tl.truncate(B, 255);
      }
    };
    MixpanelPeople.prototype._get_config = function (m) {
      return this._mixpanel.get_config(m);
    };
    MixpanelPeople.prototype._identify_called = function () {
      return this._mixpanel._flags.identify_called === true;
    };
    MixpanelPeople.prototype._enqueue = function (m) {
      if (tO in m) {
        this._mixpanel.persistence._add_to_people_queue(tO, m);
      } else if (tC in m) {
        this._mixpanel.persistence._add_to_people_queue(tC, m);
      } else if (tM in m) {
        this._mixpanel.persistence._add_to_people_queue(tM, m);
      } else if (tT in m) {
        this._mixpanel.persistence._add_to_people_queue(tT, m);
      } else if (tA in m) {
        this._mixpanel.persistence._add_to_people_queue(tA, m);
      } else if (tP in m) {
        this._mixpanel.persistence._add_to_people_queue(tP, m);
      } else if (tR in m) {
        this._mixpanel.persistence._add_to_people_queue(tR, m);
      } else {
        tu.error("Invalid call to _enqueue():", m);
      }
    };
    MixpanelPeople.prototype._flush_one_queue = function (m, _, C, R) {
      var L = this;
      var B = tl.extend({}, this._mixpanel.persistence.load_queue(m));
      var F = B;
      if (!tl.isUndefined(B) && tl.isObject(B) && !tl.isEmptyObject(B)) {
        L._mixpanel.persistence._pop_from_people_queue(m, B);
        L._mixpanel.persistence.save();
        if (R) {
          F = R(B);
        }
        _.call(L, F, function (_, R) {
          if (_ === 0) {
            L._mixpanel.persistence._add_to_people_queue(m, B);
          }
          if (!tl.isUndefined(C)) {
            C(_, R);
          }
        });
      }
    };
    MixpanelPeople.prototype._flush = function (m, _, C, R, L, B, F) {
      var U = this;
      this._flush_one_queue(tO, this.set, m);
      this._flush_one_queue(tC, this.set_once, R);
      this._flush_one_queue(tM, this.unset, B, function (m) {
        return tl.keys(m);
      });
      this._flush_one_queue(tT, this.increment, _);
      this._flush_one_queue(tR, this.union, L);
      var H = this._mixpanel.persistence.load_queue(tA);
      if (!tl.isUndefined(H) && tl.isArray(H) && H.length) {
        var q;
        var append_callback = function (m, _) {
          if (m === 0) {
            U._mixpanel.persistence._add_to_people_queue(tA, q);
          }
          if (!tl.isUndefined(C)) {
            C(m, _);
          }
        };
        for (var V = H.length - 1; V >= 0; V--) {
          q = (H = this._mixpanel.persistence.load_queue(tA)).pop();
          U._mixpanel.persistence.save();
          if (!tl.isEmptyObject(q)) {
            U.append(q, append_callback);
          }
        }
      }
      var X = this._mixpanel.persistence.load_queue(tP);
      if (!tl.isUndefined(X) && tl.isArray(X) && X.length) {
        var K;
        var remove_callback = function (m, _) {
          if (m === 0) {
            U._mixpanel.persistence._add_to_people_queue(tP, K);
          }
          if (!tl.isUndefined(F)) {
            F(m, _);
          }
        };
        for (var Y = X.length - 1; Y >= 0; Y--) {
          K = (X = this._mixpanel.persistence.load_queue(tP)).pop();
          U._mixpanel.persistence.save();
          if (!tl.isEmptyObject(K)) {
            U.remove(K, remove_callback);
          }
        }
      }
    };
    MixpanelPeople.prototype._is_reserved_property = function (m) {
      return m === "$distinct_id" || m === "$token" || m === "$device_id" || m === "$user_id" || m === "$had_persisted_distinct_id";
    };
    MixpanelPeople.prototype.set = MixpanelPeople.prototype.set;
    MixpanelPeople.prototype.set_once = MixpanelPeople.prototype.set_once;
    MixpanelPeople.prototype.unset = MixpanelPeople.prototype.unset;
    MixpanelPeople.prototype.increment = MixpanelPeople.prototype.increment;
    MixpanelPeople.prototype.append = MixpanelPeople.prototype.append;
    MixpanelPeople.prototype.remove = MixpanelPeople.prototype.remove;
    MixpanelPeople.prototype.union = MixpanelPeople.prototype.union;
    MixpanelPeople.prototype.track_charge = MixpanelPeople.prototype.track_charge;
    MixpanelPeople.prototype.clear_charges = MixpanelPeople.prototype.clear_charges;
    MixpanelPeople.prototype.delete_user = MixpanelPeople.prototype.delete_user;
    MixpanelPeople.prototype.toString = MixpanelPeople.prototype.toString;
    var tL = "__mps";
    var tN = "__mpso";
    var tB = "__mpus";
    var tj = "__mpa";
    var tF = "__mpap";
    var tU = "__mpr";
    var tH = "__mpu";
    var tW = "$people_distinct_id";
    var t$ = "__alias";
    var tq = "__timers";
    var tG = [tL, tN, tB, tj, tF, tU, tH, tW, t$, tq];
    function MixpanelPersistence(m) {
      this.props = {};
      this.campaign_params_saved = false;
      if (m.persistence_name) {
        this.name = "mp_" + m.persistence_name;
      } else {
        this.name = "mp_" + m.token + "_mixpanel";
      }
      var _ = m.persistence;
      if (_ !== "cookie" && _ !== "localStorage") {
        tu.critical("Unknown persistence type " + _ + "; falling back to cookie");
        _ = m.persistence = "cookie";
      }
      if (_ === "localStorage" && tl.localStorage.is_supported()) {
        this.storage = tl.localStorage;
      } else {
        this.storage = tl.cookie;
      }
      this.load();
      this.update_config(m);
      this.upgrade();
      this.save();
    }
    MixpanelPersistence.prototype.properties = function () {
      var m = {};
      this.load();
      tl.each(this.props, function (_, C) {
        if (!tl.include(tG, C)) {
          m[C] = _;
        }
      });
      return m;
    };
    MixpanelPersistence.prototype.load = function () {
      if (!this.disabled) {
        var m = this.storage.parse(this.name);
        if (m) {
          this.props = tl.extend({}, m);
        }
      }
    };
    MixpanelPersistence.prototype.upgrade = function () {
      var m;
      var _;
      if (this.storage === tl.localStorage) {
        m = tl.cookie.parse(this.name);
        tl.cookie.remove(this.name);
        tl.cookie.remove(this.name, true);
        if (m) {
          this.register_once(m);
        }
      } else if (this.storage === tl.cookie) {
        _ = tl.localStorage.parse(this.name);
        tl.localStorage.remove(this.name);
        if (_) {
          this.register_once(_);
        }
      }
    };
    MixpanelPersistence.prototype.save = function () {
      if (!this.disabled) {
        this.storage.set(this.name, tl.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain);
      }
    };
    MixpanelPersistence.prototype.load_prop = function (m) {
      this.load();
      return this.props[m];
    };
    MixpanelPersistence.prototype.remove = function () {
      this.storage.remove(this.name, false, this.cookie_domain);
      this.storage.remove(this.name, true, this.cookie_domain);
    };
    MixpanelPersistence.prototype.clear = function () {
      this.remove();
      this.props = {};
    };
    MixpanelPersistence.prototype.register_once = function (m, _, C) {
      return !!tl.isObject(m) && (_ === undefined && (_ = "None"), this.expire_days = C === undefined ? this.default_expiry : C, this.load(), tl.each(m, function (m, C) {
        if (!this.props.hasOwnProperty(C) || this.props[C] === _) {
          this.props[C] = m;
        }
      }, this), this.save(), true);
    };
    MixpanelPersistence.prototype.register = function (m, _) {
      return !!tl.isObject(m) && (this.expire_days = _ === undefined ? this.default_expiry : _, this.load(), tl.extend(this.props, m), this.save(), true);
    };
    MixpanelPersistence.prototype.unregister = function (m) {
      this.load();
      if (m in this.props) {
        delete this.props[m];
        this.save();
      }
    };
    MixpanelPersistence.prototype.update_search_keyword = function (m) {
      this.register(tl.info.searchInfo(m));
    };
    MixpanelPersistence.prototype.update_referrer_info = function (m) {
      this.register_once({
        $initial_referrer: m || "$direct",
        $initial_referring_domain: tl.info.referringDomain(m) || "$direct"
      }, "");
    };
    MixpanelPersistence.prototype.get_referrer_info = function () {
      return tl.strip_empty_properties({
        $initial_referrer: this.props.$initial_referrer,
        $initial_referring_domain: this.props.$initial_referring_domain
      });
    };
    MixpanelPersistence.prototype.update_config = function (m) {
      this.default_expiry = this.expire_days = m.cookie_expiration;
      this.set_disabled(m.disable_persistence);
      this.set_cookie_domain(m.cookie_domain);
      this.set_cross_site(m.cross_site_cookie);
      this.set_cross_subdomain(m.cross_subdomain_cookie);
      this.set_secure(m.secure_cookie);
    };
    MixpanelPersistence.prototype.set_disabled = function (m) {
      this.disabled = m;
      if (this.disabled) {
        this.remove();
      } else {
        this.save();
      }
    };
    MixpanelPersistence.prototype.set_cookie_domain = function (m) {
      if (m !== this.cookie_domain) {
        this.remove();
        this.cookie_domain = m;
        this.save();
      }
    };
    MixpanelPersistence.prototype.set_cross_site = function (m) {
      if (m !== this.cross_site) {
        this.cross_site = m;
        this.remove();
        this.save();
      }
    };
    MixpanelPersistence.prototype.set_cross_subdomain = function (m) {
      if (m !== this.cross_subdomain) {
        this.cross_subdomain = m;
        this.remove();
        this.save();
      }
    };
    MixpanelPersistence.prototype.get_cross_subdomain = function () {
      return this.cross_subdomain;
    };
    MixpanelPersistence.prototype.set_secure = function (m) {
      if (m !== this.secure) {
        this.secure = !!m;
        this.remove();
        this.save();
      }
    };
    MixpanelPersistence.prototype._add_to_people_queue = function (m, _) {
      var C = this._get_queue_key(m);
      var R = _[m];
      var L = this._get_or_create_queue(tO);
      var B = this._get_or_create_queue(tC);
      var F = this._get_or_create_queue(tM);
      var U = this._get_or_create_queue(tT);
      var H = this._get_or_create_queue(tR);
      var q = this._get_or_create_queue(tP, []);
      var V = this._get_or_create_queue(tA, []);
      if (C === tL) {
        tl.extend(L, R);
        this._pop_from_people_queue(tT, R);
        this._pop_from_people_queue(tR, R);
        this._pop_from_people_queue(tM, R);
      } else if (C === tN) {
        tl.each(R, function (m, _) {
          if (!(_ in B)) {
            B[_] = m;
          }
        });
        this._pop_from_people_queue(tM, R);
      } else if (C === tB) {
        tl.each(R, function (m) {
          tl.each([L, B, U, H], function (_) {
            if (m in _) {
              delete _[m];
            }
          });
          tl.each(V, function (_) {
            if (m in _) {
              delete _[m];
            }
          });
          F[m] = true;
        });
      } else if (C === tj) {
        tl.each(R, function (m, _) {
          if (_ in L) {
            L[_] += m;
          } else {
            if (!(_ in U)) {
              U[_] = 0;
            }
            U[_] += m;
          }
        }, this);
        this._pop_from_people_queue(tM, R);
      } else if (C === tH) {
        tl.each(R, function (m, _) {
          if (tl.isArray(m)) {
            if (!(_ in H)) {
              H[_] = [];
            }
            H[_] = H[_].concat(m);
          }
        });
        this._pop_from_people_queue(tM, R);
      } else if (C === tU) {
        q.push(R);
        this._pop_from_people_queue(tA, R);
      } else if (C === tF) {
        V.push(R);
        this._pop_from_people_queue(tM, R);
      }
      tu.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):");
      tu.log(_);
      this.save();
    };
    MixpanelPersistence.prototype._pop_from_people_queue = function (m, _) {
      var C = this.props[this._get_queue_key(m)];
      if (!tl.isUndefined(C)) {
        tl.each(_, function (_, R) {
          if (m === tA || m === tP) {
            tl.each(C, function (m) {
              if (m[R] === _) {
                delete m[R];
              }
            });
          } else {
            delete C[R];
          }
        }, this);
      }
    };
    MixpanelPersistence.prototype.load_queue = function (m) {
      return this.load_prop(this._get_queue_key(m));
    };
    MixpanelPersistence.prototype._get_queue_key = function (m) {
      if (m === tO) {
        return tL;
      } else if (m === tC) {
        return tN;
      } else if (m === tM) {
        return tB;
      } else if (m === tT) {
        return tj;
      } else if (m === tA) {
        return tF;
      } else if (m === tP) {
        return tU;
      } else if (m === tR) {
        return tH;
      } else {
        tu.error("Invalid queue:", m);
        return;
      }
    };
    MixpanelPersistence.prototype._get_or_create_queue = function (m, _) {
      var C = this._get_queue_key(m);
      _ = tl.isUndefined(_) ? {} : _;
      return this.props[C] ||= _;
    };
    MixpanelPersistence.prototype.set_event_timer = function (m, _) {
      var C = this.load_prop(tq) || {};
      C[m] = _;
      this.props[tq] = C;
      this.save();
    };
    MixpanelPersistence.prototype.remove_event_timer = function (m) {
      var _ = (this.load_prop(tq) || {})[m];
      if (!tl.isUndefined(_)) {
        delete this.props[tq][m];
        this.save();
      }
      return _;
    };
    function load_extra_bundle(m, _) {
      throw Error(m + " not available in this build.");
    }
    function IDENTITY_FUNC(m) {
      return m;
    }
    function NOOP_FUNC() {}
    var tz = "mixpanel";
    var tV = "base64";
    var tJ = "$device:";
    var tX = eP.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    var tK = !tX && tr.indexOf("MSIE") === -1 && tr.indexOf("Mozilla") === -1;
    var tZ = null;
    if (e9.sendBeacon) {
      tZ = function () {
        return e9.sendBeacon.apply(e9, arguments);
      };
    }
    var tY = {
      track: "track/",
      engage: "engage/",
      groups: "groups/",
      record: "record/"
    };
    var tQ = {
      api_host: "https://api-js.mixpanel.com",
      api_routes: tY,
      api_method: "POST",
      api_transport: "XHR",
      api_payload_format: tV,
      app_host: "https://mixpanel.com",
      cdn: "https://cdn.mxpnl.com",
      cross_site_cookie: false,
      cross_subdomain_cookie: true,
      error_reporter: NOOP_FUNC,
      persistence: "cookie",
      persistence_name: "",
      cookie_domain: "",
      cookie_name: "",
      loaded: NOOP_FUNC,
      mp_loader: null,
      track_marketing: true,
      track_pageview: false,
      skip_first_touch_marketing: false,
      store_google: true,
      stop_utm_persistence: false,
      save_referrer: true,
      test: false,
      verbose: false,
      img: false,
      debug: false,
      track_links_timeout: 300,
      cookie_expiration: 365,
      upgrade: false,
      disable_persistence: false,
      disable_cookie: false,
      secure_cookie: false,
      ip: true,
      opt_out_tracking_by_default: false,
      opt_out_persistence_by_default: false,
      opt_out_tracking_persistence_type: "localStorage",
      opt_out_tracking_cookie_prefix: null,
      property_blacklist: [],
      xhr_headers: {},
      ignore_dnt: false,
      batch_requests: true,
      batch_size: 50,
      batch_flush_interval_ms: 5000,
      batch_request_timeout_ms: 90000,
      batch_autostart: true,
      hooks: {},
      record_block_class: RegExp("^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$"),
      record_block_selector: "img, video",
      record_collect_fonts: false,
      record_idle_timeout_ms: 1800000,
      record_inline_images: false,
      record_mask_text_class: RegExp("^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$"),
      record_mask_text_selector: "*",
      record_max_ms: 86400000,
      record_min_ms: 0,
      record_sessions_percent: 0,
      recorder_src: "https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js"
    };
    var t0 = false;
    function MixpanelLib() {}
    function create_mplib(m, _, C) {
      var R;
      var L = C === tz ? eL : eL[C];
      if (L && eD === 0) {
        R = L;
      } else {
        if (L && !tl.isArray(L)) {
          tu.error("You have already initialized " + C);
          return;
        }
        R = new MixpanelLib();
      }
      R._cached_groups = {};
      R._init(m, _, C);
      R.people = new MixpanelPeople();
      R.people._init(R);
      if (!R.get_config("skip_first_touch_marketing")) {
        var B = tl.info.campaignParams(null);
        var F = {};
        var U = false;
        tl.each(B, function (m, _) {
          F["initial_" + _] = m;
          if (m) {
            U = true;
          }
        });
        if (U) {
          R.people.set_once(F);
        }
      }
      eQ.DEBUG = eQ.DEBUG || R.get_config("debug");
      if (!tl.isUndefined(L) && tl.isArray(L)) {
        R._execute_array.call(R.people, L.people);
        R._execute_array(L);
      }
      return R;
    }
    MixpanelLib.prototype.init = function (m, _, C) {
      if (tl.isUndefined(C)) {
        this.report_error("You must name your new library: init(token, config, name)");
        return;
      }
      if (C === tz) {
        this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
        return;
      }
      var R = create_mplib(m, _, C);
      eL[C] = R;
      R._loaded();
      return R;
    };
    MixpanelLib.prototype._init = function (m, _, C) {
      _ = _ || {};
      this.__loaded = true;
      this.config = {};
      var R = {};
      if (!("api_payload_format" in _) && (_.api_host || tQ.api_host).match(/\.mixpanel\.com/)) {
        R.api_payload_format = "json";
      }
      this.set_config(tl.extend({}, tQ, R, _, {
        name: C,
        token: m,
        callback_fn: (C === tz ? C : tz + "." + C) + "._jsc"
      }));
      this._jsc = NOOP_FUNC;
      this.__dom_loaded_queue = [];
      this.__request_queue = [];
      this.__disabled_events = [];
      this._flags = {
        disable_all_events: false,
        identify_called: false
      };
      this.request_batchers = {};
      this._batch_requests = this.get_config("batch_requests");
      if (this._batch_requests) {
        if (tl.localStorage.is_supported(true) && tX) {
          this.init_batchers();
          if (tZ && eP.addEventListener) {
            var L = tl.bind(function () {
              if (!this.request_batchers.events.stopped) {
                this.request_batchers.events.flush({
                  unloading: true
                });
              }
            }, this);
            eP.addEventListener("pagehide", function (m) {
              if (m.persisted) {
                L();
              }
            });
            eP.addEventListener("visibilitychange", function () {
              if (e7.visibilityState === "hidden") {
                L();
              }
            });
          }
        } else {
          this._batch_requests = false;
          tu.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
          tl.each(this.get_batcher_configs(), function (m) {
            tu.log("Clearing batch queue " + m.queue_key);
            tl.localStorage.remove(m.queue_key);
          });
        }
      }
      this.persistence = this.cookie = new MixpanelPersistence(this.config);
      this.unpersisted_superprops = {};
      this._gdpr_init();
      var B = tl.UUID();
      if (!this.get_distinct_id()) {
        this.register_once({
          distinct_id: tJ + B,
          $device_id: B
        }, "");
      }
      var F = this.get_config("track_pageview");
      if (F) {
        this._init_url_change_tracking(F);
      }
      if (this.get_config("record_sessions_percent") > 0 && Math.random() * 100 <= this.get_config("record_sessions_percent")) {
        this.start_session_recording();
      }
    };
    MixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function () {
      if (!eP.MutationObserver) {
        tu.critical("Browser does not support MutationObserver; skipping session recording");
        return;
      }
      var m = tl.bind(function () {
        this._recorder = this._recorder || new eP.__mp_recorder(this);
        this._recorder.startRecording();
      }, this);
      if (tl.isUndefined(eP.__mp_recorder)) {
        load_extra_bundle(this.get_config("recorder_src"), m);
      } else {
        m();
      }
    });
    MixpanelLib.prototype.stop_session_recording = function () {
      if (this._recorder) {
        this._recorder.stopRecording();
      } else {
        tu.critical("Session recorder module not loaded");
      }
    };
    MixpanelLib.prototype.get_session_recording_properties = function () {
      var m = {};
      if (this._recorder) {
        var _ = this._recorder.replayId;
        if (_) {
          m.$mp_replay_id = _;
        }
      }
      return m;
    };
    MixpanelLib.prototype._loaded = function () {
      this.get_config("loaded")(this);
      this._set_default_superprops();
      this.people.set_once(this.persistence.get_referrer_info());
      if (this.get_config("store_google") && this.get_config("stop_utm_persistence")) {
        var m = tl.info.campaignParams(null);
        tl.each(m, function (m, _) {
          this.unregister(_);
        }.bind(this));
      }
    };
    MixpanelLib.prototype._set_default_superprops = function () {
      this.persistence.update_search_keyword(e7.referrer);
      if (this.get_config("store_google") && !this.get_config("stop_utm_persistence")) {
        this.register(tl.info.campaignParams());
      }
      if (this.get_config("save_referrer")) {
        this.persistence.update_referrer_info(e7.referrer);
      }
    };
    MixpanelLib.prototype._dom_loaded = function () {
      tl.each(this.__dom_loaded_queue, function (m) {
        this._track_dom.apply(this, m);
      }, this);
      if (!this.has_opted_out_tracking()) {
        tl.each(this.__request_queue, function (m) {
          this._send_request.apply(this, m);
        }, this);
      }
      delete this.__dom_loaded_queue;
      delete this.__request_queue;
    };
    MixpanelLib.prototype._track_dom = function (m, _) {
      if (this.get_config("img")) {
        this.report_error("You can't use DOM tracking functions with img = true.");
        return false;
      }
      if (!t0) {
        this.__dom_loaded_queue.push([m, _]);
        return false;
      }
      var C = new m().init(this);
      return C.track.apply(C, _);
    };
    MixpanelLib.prototype._init_url_change_tracking = function (m) {
      var _ = "";
      if (this.track_pageview()) {
        _ = tl.info.currentUrl();
      }
      if (tl.include(["full-url", "url-with-path-and-query-string", "url-with-path"], m)) {
        eP.addEventListener("popstate", function () {
          eP.dispatchEvent(new Event("mp_locationchange"));
        });
        eP.addEventListener("hashchange", function () {
          eP.dispatchEvent(new Event("mp_locationchange"));
        });
        var C = eP.history.pushState;
        if (typeof C == "function") {
          eP.history.pushState = function (m, _, R) {
            C.call(eP.history, m, _, R);
            eP.dispatchEvent(new Event("mp_locationchange"));
          };
        }
        var R = eP.history.replaceState;
        if (typeof R == "function") {
          eP.history.replaceState = function (m, _, C) {
            R.call(eP.history, m, _, C);
            eP.dispatchEvent(new Event("mp_locationchange"));
          };
        }
        eP.addEventListener("mp_locationchange", function () {
          var C = tl.info.currentUrl();
          var R = false;
          if (m === "full-url") {
            R = C !== _;
          } else if (m === "url-with-path-and-query-string") {
            R = C.split("#")[0] !== _.split("#")[0];
          } else if (m === "url-with-path") {
            R = C.split("#")[0].split("?")[0] !== _.split("#")[0].split("?")[0];
          }
          if (R && this.track_pageview()) {
            _ = C;
          }
        }.bind(this));
      }
    };
    MixpanelLib.prototype._prepare_callback = function (m, _) {
      if (tl.isUndefined(m)) {
        return null;
      }
      if (tX) {
        return function (C) {
          m(C, _);
        };
      }
      var C = this._jsc;
      var R = "" + Math.floor(Math.random() * 100000000);
      var L = this.get_config("callback_fn") + "[" + R + "]";
      C[R] = function (L) {
        delete C[R];
        m(L, _);
      };
      return L;
    };
    MixpanelLib.prototype._send_request = function (m, _, C, R) {
      var L = true;
      if (tK) {
        this.__request_queue.push(arguments);
        return L;
      }
      var B = {
        method: this.get_config("api_method"),
        transport: this.get_config("api_transport"),
        verbose: this.get_config("verbose")
      };
      var F = null;
      if (!R && (tl.isFunction(C) || typeof C == "string")) {
        R = C;
        C = null;
      }
      C = tl.extend(B, C || {});
      if (!tX) {
        C.method = "GET";
      }
      var U = C.method === "POST";
      var H = tZ && U && C.transport.toLowerCase() === "sendbeacon";
      var q = C.verbose;
      if (_.verbose) {
        q = true;
      }
      if (this.get_config("test")) {
        _.test = 1;
      }
      if (q) {
        _.verbose = 1;
      }
      if (this.get_config("img")) {
        _.img = 1;
      }
      if (!tX) {
        if (R) {
          _.callback = R;
        } else if (q || this.get_config("test")) {
          _.callback = "(function(){})";
        }
      }
      _.ip = this.get_config("ip") ? 1 : 0;
      _._ = new Date().getTime().toString();
      if (U) {
        F = "data=" + encodeURIComponent(_.data);
        delete _.data;
      }
      m += "?" + tl.HTTPBuildQuery(_);
      var V = this;
      if ("img" in _) {
        var X = e7.createElement("img");
        X.src = m;
        e7.body.appendChild(X);
      } else if (H) {
        try {
          L = tZ(m, F);
        } catch (m) {
          V.report_error(m);
          L = false;
        }
        try {
          if (R) {
            R(L ? 1 : 0);
          }
        } catch (m) {
          V.report_error(m);
        }
      } else if (tX) {
        try {
          var K = new XMLHttpRequest();
          K.open(C.method, m, true);
          var Y = this.get_config("xhr_headers");
          if (U) {
            Y["Content-Type"] = "application/x-www-form-urlencoded";
          }
          tl.each(Y, function (m, _) {
            K.setRequestHeader(_, m);
          });
          if (C.timeout_ms && K.timeout !== undefined) {
            K.timeout = C.timeout_ms;
            var Q = new Date().getTime();
          }
          K.withCredentials = true;
          K.onreadystatechange = function () {
            if (K.readyState === 4) {
              if (K.status === 200) {
                if (R) {
                  if (q) {
                    try {
                      m = tl.JSONDecode(K.responseText);
                    } catch (_) {
                      V.report_error(_);
                      if (!C.ignore_json_errors) {
                        return;
                      }
                      m = K.responseText;
                    }
                    R(m);
                  } else {
                    R(Number(K.responseText));
                  }
                }
              } else {
                _ = K.timeout && !K.status && new Date().getTime() - Q >= K.timeout ? "timeout" : "Bad HTTP status: " + K.status + " " + K.statusText;
                V.report_error(_);
                if (R) {
                  if (q) {
                    var m;
                    var _;
                    var L = K.responseHeaders || {};
                    R({
                      status: 0,
                      httpStatusCode: K.status,
                      error: _,
                      retryAfter: L["Retry-After"]
                    });
                  } else {
                    R(0);
                  }
                }
              }
            }
          };
          K.send(F);
        } catch (m) {
          V.report_error(m);
          L = false;
        }
      } else {
        var et = e7.createElement("script");
        et.type = "text/javascript";
        et.async = true;
        et.defer = true;
        et.src = m;
        var er = e7.getElementsByTagName("script")[0];
        er.parentNode.insertBefore(et, er);
      }
      return L;
    };
    MixpanelLib.prototype._execute_array = function (m) {
      var _;
      var C = [];
      var R = [];
      var L = [];
      tl.each(m, function (m) {
        if (m) {
          _ = m[0];
          if (tl.isArray(_)) {
            L.push(m);
          } else if (typeof m == "function") {
            m.call(this);
          } else if (tl.isArray(m) && _ === "alias") {
            C.push(m);
          } else if (tl.isArray(m) && _.indexOf("track") !== -1 && typeof this[_] == "function") {
            L.push(m);
          } else {
            R.push(m);
          }
        }
      }, this);
      function execute(m, _) {
        tl.each(m, function (m) {
          if (tl.isArray(m[0])) {
            var C = _;
            tl.each(m, function (m) {
              C = C[m[0]].apply(C, m.slice(1));
            });
          } else {
            this[m[0]].apply(this, m.slice(1));
          }
        }, _);
      }
      execute(C, this);
      execute(R, this);
      execute(L, this);
    };
    MixpanelLib.prototype.are_batchers_initialized = function () {
      return !!this.request_batchers.events;
    };
    MixpanelLib.prototype.get_batcher_configs = function () {
      var m = "__mpq_" + this.get_config("token");
      var _ = this.get_config("api_routes");
      this._batcher_configs = this._batcher_configs || {
        events: {
          type: "events",
          endpoint: "/" + _.track,
          queue_key: m + "_ev"
        },
        people: {
          type: "people",
          endpoint: "/" + _.engage,
          queue_key: m + "_pp"
        },
        groups: {
          type: "groups",
          endpoint: "/" + _.groups,
          queue_key: m + "_gr"
        }
      };
      return this._batcher_configs;
    };
    MixpanelLib.prototype.init_batchers = function () {
      if (!this.are_batchers_initialized()) {
        var m = tl.bind(function (m) {
          return new RequestBatcher(m.queue_key, {
            libConfig: this.config,
            errorReporter: this.get_config("error_reporter"),
            sendRequestFunc: tl.bind(function (_, C, R) {
              this._send_request(this.get_config("api_host") + m.endpoint, this._encode_data_for_request(_), C, this._prepare_callback(R, _));
            }, this),
            beforeSendHook: tl.bind(function (_) {
              return this._run_hook("before_send_" + m.type, _);
            }, this),
            stopAllBatchingFunc: tl.bind(this.stop_batch_senders, this),
            usePersistence: true
          });
        }, this);
        var _ = this.get_batcher_configs();
        this.request_batchers = {
          events: m(_.events),
          people: m(_.people),
          groups: m(_.groups)
        };
      }
      if (this.get_config("batch_autostart")) {
        this.start_batch_senders();
      }
    };
    MixpanelLib.prototype.start_batch_senders = function () {
      this._batchers_were_started = true;
      if (this.are_batchers_initialized()) {
        this._batch_requests = true;
        tl.each(this.request_batchers, function (m) {
          m.start();
        });
      }
    };
    MixpanelLib.prototype.stop_batch_senders = function () {
      this._batch_requests = false;
      tl.each(this.request_batchers, function (m) {
        m.stop();
        m.clear();
      });
    };
    MixpanelLib.prototype.push = function (m) {
      this._execute_array([m]);
    };
    MixpanelLib.prototype.disable = function (m) {
      if (m === undefined) {
        this._flags.disable_all_events = true;
      } else {
        this.__disabled_events = this.__disabled_events.concat(m);
      }
    };
    MixpanelLib.prototype._encode_data_for_request = function (m) {
      var _ = tl.JSONEncode(m);
      if (this.get_config("api_payload_format") === tV) {
        _ = tl.base64Encode(_);
      }
      return {
        data: _
      };
    };
    MixpanelLib.prototype._track_or_batch = function (m, _) {
      var C = tl.truncate(m.data, 255);
      var R = m.endpoint;
      var L = m.batcher;
      var B = m.should_send_immediately;
      var F = m.send_request_options || {};
      _ = _ || NOOP_FUNC;
      var U = true;
      var H = tl.bind(function () {
        if (!F.skip_hooks) {
          C = this._run_hook("before_send_" + m.type, C);
        }
        if (C) {
          tu.log("MIXPANEL REQUEST:");
          tu.log(C);
          return this._send_request(R, this._encode_data_for_request(C), F, this._prepare_callback(_, C));
        } else {
          return null;
        }
      }, this);
      if (this._batch_requests && !B) {
        L.enqueue(C, function (m) {
          if (m) {
            _(1, C);
          } else {
            H();
          }
        });
      } else {
        U = H();
      }
      return U && C;
    };
    MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function (m, _, C, R) {
      if (!R && typeof C == "function") {
        R = C;
        C = null;
      }
      var L = (C = C || {}).transport;
      if (L) {
        C.transport = L;
      }
      var B = C.send_immediately;
      if (typeof R != "function") {
        R = NOOP_FUNC;
      }
      if (tl.isUndefined(m)) {
        this.report_error("No event name provided to mixpanel.track");
        return;
      }
      if (this._event_is_disabled(m)) {
        R(0);
        return;
      }
      (_ = tl.extend({}, _)).token = this.get_config("token");
      var F = this.persistence.remove_event_timer(m);
      if (!tl.isUndefined(F)) {
        var U = new Date().getTime() - F;
        _.$duration = parseFloat((U / 1000).toFixed(3));
      }
      this._set_default_superprops();
      var H = this.get_config("track_marketing") ? tl.info.marketingParams() : {};
      _ = tl.extend({}, tl.info.properties({
        mp_loader: this.get_config("mp_loader")
      }), H, this.persistence.properties(), this.unpersisted_superprops, this.get_session_recording_properties(), _);
      var q = this.get_config("property_blacklist");
      if (tl.isArray(q)) {
        tl.each(q, function (m) {
          delete _[m];
        });
      } else {
        this.report_error("Invalid value for property_blacklist config: " + q);
      }
      var V = {
        event: m,
        properties: _
      };
      return this._track_or_batch({
        type: "events",
        data: V,
        endpoint: this.get_config("api_host") + "/" + this.get_config("api_routes").track,
        batcher: this.request_batchers.events,
        should_send_immediately: B,
        send_request_options: C
      }, R);
    });
    MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function (m, _, C) {
      if (!tl.isArray(_)) {
        _ = [_];
      }
      var R = {
        [m]: _
      };
      this.register(R);
      return this.people.set(m, _, C);
    });
    MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function (m, _, C) {
      var R = this.get_property(m);
      var L = {};
      if (R === undefined) {
        L[m] = [_];
        this.register(L);
      } else if (R.indexOf(_) === -1) {
        R.push(_);
        L[m] = R;
        this.register(L);
      }
      return this.people.union(m, _, C);
    });
    MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function (m, _, C) {
      var R = this.get_property(m);
      if (R !== undefined) {
        var L = R.indexOf(_);
        if (L > -1) {
          R.splice(L, 1);
          this.register({
            group_key: R
          });
        }
        if (R.length === 0) {
          this.unregister(m);
        }
      }
      return this.people.remove(m, _, C);
    });
    MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function (m, _, C, R) {
      var L = tl.extend({}, _ || {});
      tl.each(C, function (m, _) {
        if (m != null) {
          L[_] = m;
        }
      });
      return this.track(m, L, R);
    });
    MixpanelLib.prototype._create_map_key = function (m, _) {
      return m + "_" + JSON.stringify(_);
    };
    MixpanelLib.prototype._remove_group_from_cache = function (m, _) {
      delete this._cached_groups[this._create_map_key(m, _)];
    };
    MixpanelLib.prototype.get_group = function (m, _) {
      var C = this._create_map_key(m, _);
      var R = this._cached_groups[C];
      if (R === undefined || R._group_key !== m || R._group_id !== _) {
        (R = new MixpanelGroup())._init(this, m, _);
        this._cached_groups[C] = R;
      }
      return R;
    };
    MixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function (m, _) {
      if (typeof m != "object") {
        m = {};
      }
      var C = (_ = _ || {}).event_name || "$mp_web_page_view";
      var R = tl.extend(tl.info.mpPageViewProperties(), tl.info.campaignParams(), tl.info.clickParams());
      var L = tl.extend({}, R, m);
      return this.track(C, L);
    });
    MixpanelLib.prototype.track_links = function () {
      return this._track_dom.call(this, LinkTracker, arguments);
    };
    MixpanelLib.prototype.track_forms = function () {
      return this._track_dom.call(this, FormTracker, arguments);
    };
    MixpanelLib.prototype.time_event = function (m) {
      if (tl.isUndefined(m)) {
        this.report_error("No event name provided to mixpanel.time_event");
        return;
      }
      if (!this._event_is_disabled(m)) {
        this.persistence.set_event_timer(m, new Date().getTime());
      }
    };
    var t1 = {
      persistent: true
    };
    function options_for_register(m) {
      var _;
      _ = tl.isObject(m) ? m : tl.isUndefined(m) ? {} : {
        days: m
      };
      return tl.extend({}, t1, _);
    }
    MixpanelLib.prototype.register = function (m, _) {
      var C = options_for_register(_);
      if (C.persistent) {
        this.persistence.register(m, C.days);
      } else {
        tl.extend(this.unpersisted_superprops, m);
      }
    };
    MixpanelLib.prototype.register_once = function (m, _, C) {
      var R = options_for_register(C);
      if (R.persistent) {
        this.persistence.register_once(m, _, R.days);
      } else {
        if (_ === undefined) {
          _ = "None";
        }
        tl.each(m, function (m, C) {
          if (!this.unpersisted_superprops.hasOwnProperty(C) || this.unpersisted_superprops[C] === _) {
            this.unpersisted_superprops[C] = m;
          }
        }, this);
      }
    };
    MixpanelLib.prototype.unregister = function (m, _) {
      if ((_ = options_for_register(_)).persistent) {
        this.persistence.unregister(m);
      } else {
        delete this.unpersisted_superprops[m];
      }
    };
    MixpanelLib.prototype._register_single = function (m, _) {
      var C = {
        [m]: _
      };
      this.register(C);
    };
    MixpanelLib.prototype.identify = function (m, _, C, R, L, B, F, U) {
      var H = this.get_distinct_id();
      if (m && H !== m) {
        if (typeof m == "string" && m.indexOf(tJ) === 0) {
          this.report_error("distinct_id cannot have $device: prefix");
          return -1;
        }
        this.register({
          $user_id: m
        });
      }
      if (!this.get_property("$device_id")) {
        this.register_once({
          $had_persisted_distinct_id: true,
          $device_id: H
        }, "");
      }
      if (m !== H && m !== this.get_property(t$)) {
        this.unregister(t$);
        this.register({
          distinct_id: m
        });
      }
      this._flags.identify_called = true;
      this.people._flush(_, C, R, L, B, F, U);
      if (m !== H) {
        this.track("$identify", {
          distinct_id: m,
          $anon_distinct_id: H
        }, {
          skip_hooks: true
        });
      }
    };
    MixpanelLib.prototype.reset = function () {
      this.persistence.clear();
      this._flags.identify_called = false;
      var m = tl.UUID();
      this.register_once({
        distinct_id: tJ + m,
        $device_id: m
      }, "");
    };
    MixpanelLib.prototype.get_distinct_id = function () {
      return this.get_property("distinct_id");
    };
    MixpanelLib.prototype.alias = function (m, _) {
      if (m === this.get_property(tW)) {
        this.report_error("Attempting to create alias for existing People user - aborting.");
        return -2;
      }
      var C = this;
      if (tl.isUndefined(_)) {
        _ = this.get_distinct_id();
      }
      if (m !== _) {
        this._register_single(t$, m);
        return this.track("$create_alias", {
          alias: m,
          distinct_id: _
        }, {
          skip_hooks: true
        }, function () {
          C.identify(m);
        });
      } else {
        this.report_error("alias matches current distinct_id - skipping api call.");
        this.identify(m);
        return -1;
      }
    };
    MixpanelLib.prototype.name_tag = function (m) {
      this._register_single("mp_name_tag", m);
    };
    MixpanelLib.prototype.set_config = function (m) {
      if (tl.isObject(m)) {
        tl.extend(this.config, m);
        if (m.batch_size) {
          tl.each(this.request_batchers, function (m) {
            m.resetBatchSize();
          });
        }
        if (!this.get_config("persistence_name")) {
          this.config.persistence_name = this.config.cookie_name;
        }
        if (!this.get_config("disable_persistence")) {
          this.config.disable_persistence = this.config.disable_cookie;
        }
        if (this.persistence) {
          this.persistence.update_config(this.config);
        }
        eQ.DEBUG = eQ.DEBUG || this.get_config("debug");
      }
    };
    MixpanelLib.prototype.get_config = function (m) {
      return this.config[m];
    };
    MixpanelLib.prototype._run_hook = function (m) {
      var _ = (this.config.hooks[m] || IDENTITY_FUNC).apply(this, e5.call(arguments, 1));
      if (_ === undefined) {
        this.report_error(m + " hook did not return a value");
        _ = null;
      }
      return _;
    };
    MixpanelLib.prototype.get_property = function (m) {
      return this.persistence.load_prop([m]);
    };
    MixpanelLib.prototype.toString = function () {
      var m = this.get_config("name");
      if (m !== tz) {
        m = tz + "." + m;
      }
      return m;
    };
    MixpanelLib.prototype._event_is_disabled = function (m) {
      return tl.isBlockedUA(tr) || this._flags.disable_all_events || tl.include(this.__disabled_events, m);
    };
    MixpanelLib.prototype._gdpr_init = function () {
      if (this.get_config("opt_out_tracking_persistence_type") === "localStorage" && tl.localStorage.is_supported()) {
        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
          persistence_type: "cookie"
        })) {
          this.opt_in_tracking({
            enable_persistence: false
          });
        }
        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({
          persistence_type: "cookie"
        })) {
          this.opt_out_tracking({
            clear_persistence: false
          });
        }
        this.clear_opt_in_out_tracking({
          persistence_type: "cookie",
          enable_persistence: false
        });
      }
      if (this.has_opted_out_tracking()) {
        this._gdpr_update_persistence({
          clear_persistence: true
        });
      } else if (!this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || tl.cookie.get("mp_optout"))) {
        tl.cookie.remove("mp_optout");
        this.opt_out_tracking({
          clear_persistence: this.get_config("opt_out_persistence_by_default")
        });
      }
    };
    MixpanelLib.prototype._gdpr_update_persistence = function (m) {
      var _;
      if (m && m.clear_persistence) {
        _ = true;
      } else {
        if (!m || !m.enable_persistence) {
          return;
        }
        _ = false;
      }
      if (!this.get_config("disable_persistence") && this.persistence.disabled !== _) {
        this.persistence.set_disabled(_);
      }
      if (_) {
        this.stop_batch_senders();
      } else if (this._batchers_were_started) {
        this.start_batch_senders();
      }
    };
    MixpanelLib.prototype._gdpr_call_func = function (m, _) {
      _ = tl.extend({
        track: tl.bind(this.track, this),
        persistence_type: this.get_config("opt_out_tracking_persistence_type"),
        cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
        cookie_expiration: this.get_config("cookie_expiration"),
        cross_site_cookie: this.get_config("cross_site_cookie"),
        cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
        cookie_domain: this.get_config("cookie_domain"),
        secure_cookie: this.get_config("secure_cookie"),
        ignore_dnt: this.get_config("ignore_dnt")
      }, _);
      if (!tl.localStorage.is_supported()) {
        _.persistence_type = "cookie";
      }
      return m(this.get_config("token"), {
        track: _.track,
        trackEventName: _.track_event_name,
        trackProperties: _.track_properties,
        persistenceType: _.persistence_type,
        persistencePrefix: _.cookie_prefix,
        cookieDomain: _.cookie_domain,
        cookieExpiration: _.cookie_expiration,
        crossSiteCookie: _.cross_site_cookie,
        crossSubdomainCookie: _.cross_subdomain_cookie,
        secureCookie: _.secure_cookie,
        ignoreDnt: _.ignore_dnt
      });
    };
    MixpanelLib.prototype.opt_in_tracking = function (m) {
      m = tl.extend({
        enable_persistence: true
      }, m);
      this._gdpr_call_func(optIn, m);
      this._gdpr_update_persistence(m);
    };
    MixpanelLib.prototype.opt_out_tracking = function (m) {
      if ((m = tl.extend({
        clear_persistence: true,
        delete_user: true
      }, m)).delete_user && this.people && this.people._identify_called()) {
        this.people.delete_user();
        this.people.clear_charges();
      }
      this._gdpr_call_func(optOut, m);
      this._gdpr_update_persistence(m);
    };
    MixpanelLib.prototype.has_opted_in_tracking = function (m) {
      return this._gdpr_call_func(hasOptedIn, m);
    };
    MixpanelLib.prototype.has_opted_out_tracking = function (m) {
      return this._gdpr_call_func(hasOptedOut, m);
    };
    MixpanelLib.prototype.clear_opt_in_out_tracking = function (m) {
      m = tl.extend({
        enable_persistence: true
      }, m);
      this._gdpr_call_func(clearOptInOut, m);
      this._gdpr_update_persistence(m);
    };
    MixpanelLib.prototype.report_error = function (m, _) {
      tu.error.apply(tu.error, arguments);
      try {
        if (!_ && !(m instanceof Error)) {
          m = Error(m);
        }
        this.get_config("error_reporter")(m, _);
      } catch (m) {
        tu.error(m);
      }
    };
    MixpanelLib.prototype.init = MixpanelLib.prototype.init;
    MixpanelLib.prototype.reset = MixpanelLib.prototype.reset;
    MixpanelLib.prototype.disable = MixpanelLib.prototype.disable;
    MixpanelLib.prototype.time_event = MixpanelLib.prototype.time_event;
    MixpanelLib.prototype.track = MixpanelLib.prototype.track;
    MixpanelLib.prototype.track_links = MixpanelLib.prototype.track_links;
    MixpanelLib.prototype.track_forms = MixpanelLib.prototype.track_forms;
    MixpanelLib.prototype.track_pageview = MixpanelLib.prototype.track_pageview;
    MixpanelLib.prototype.register = MixpanelLib.prototype.register;
    MixpanelLib.prototype.register_once = MixpanelLib.prototype.register_once;
    MixpanelLib.prototype.unregister = MixpanelLib.prototype.unregister;
    MixpanelLib.prototype.identify = MixpanelLib.prototype.identify;
    MixpanelLib.prototype.alias = MixpanelLib.prototype.alias;
    MixpanelLib.prototype.name_tag = MixpanelLib.prototype.name_tag;
    MixpanelLib.prototype.set_config = MixpanelLib.prototype.set_config;
    MixpanelLib.prototype.get_config = MixpanelLib.prototype.get_config;
    MixpanelLib.prototype.get_property = MixpanelLib.prototype.get_property;
    MixpanelLib.prototype.get_distinct_id = MixpanelLib.prototype.get_distinct_id;
    MixpanelLib.prototype.toString = MixpanelLib.prototype.toString;
    MixpanelLib.prototype.opt_out_tracking = MixpanelLib.prototype.opt_out_tracking;
    MixpanelLib.prototype.opt_in_tracking = MixpanelLib.prototype.opt_in_tracking;
    MixpanelLib.prototype.has_opted_out_tracking = MixpanelLib.prototype.has_opted_out_tracking;
    MixpanelLib.prototype.has_opted_in_tracking = MixpanelLib.prototype.has_opted_in_tracking;
    MixpanelLib.prototype.clear_opt_in_out_tracking = MixpanelLib.prototype.clear_opt_in_out_tracking;
    MixpanelLib.prototype.get_group = MixpanelLib.prototype.get_group;
    MixpanelLib.prototype.set_group = MixpanelLib.prototype.set_group;
    MixpanelLib.prototype.add_group = MixpanelLib.prototype.add_group;
    MixpanelLib.prototype.remove_group = MixpanelLib.prototype.remove_group;
    MixpanelLib.prototype.track_with_groups = MixpanelLib.prototype.track_with_groups;
    MixpanelLib.prototype.start_batch_senders = MixpanelLib.prototype.start_batch_senders;
    MixpanelLib.prototype.stop_batch_senders = MixpanelLib.prototype.stop_batch_senders;
    MixpanelLib.prototype.start_session_recording = MixpanelLib.prototype.start_session_recording;
    MixpanelLib.prototype.stop_session_recording = MixpanelLib.prototype.stop_session_recording;
    MixpanelLib.prototype.get_session_recording_properties = MixpanelLib.prototype.get_session_recording_properties;
    MixpanelLib.prototype.DEFAULT_API_ROUTES = tY;
    MixpanelPersistence.prototype.properties = MixpanelPersistence.prototype.properties;
    MixpanelPersistence.prototype.update_search_keyword = MixpanelPersistence.prototype.update_search_keyword;
    MixpanelPersistence.prototype.update_referrer_info = MixpanelPersistence.prototype.update_referrer_info;
    MixpanelPersistence.prototype.get_cross_subdomain = MixpanelPersistence.prototype.get_cross_subdomain;
    MixpanelPersistence.prototype.clear = MixpanelPersistence.prototype.clear;
    var t2 = {};
    function extend_mp() {
      tl.each(t2, function (m, _) {
        if (_ !== tz) {
          eL[_] = m;
        }
      });
      eL._ = tl;
    }
    load_extra_bundle = function (m, _) {
      _();
    };
    eD = 0;
    (eL = new MixpanelLib()).init = function (m, _, C) {
      if (C) {
        if (!eL[C]) {
          eL[C] = t2[C] = create_mplib(m, _, C);
          eL[C]._loaded();
        }
        return eL[C];
      }
      var R = eL;
      if (t2[tz]) {
        R = t2[tz];
      } else if (m) {
        (R = create_mplib(m, _, tz))._loaded();
        t2[tz] = R;
      }
      eL = R;
      if (eD === 1) {
        eP[tz] = eL;
      }
      extend_mp();
    };
    eL.init();
    (function () {
      function dom_loaded_handler() {
        if (!dom_loaded_handler.done) {
          dom_loaded_handler.done = true;
          t0 = true;
          tK = false;
          tl.each(t2, function (m) {
            m._dom_loaded();
          });
        }
      }
      if (e7.addEventListener) {
        if (e7.readyState === "complete") {
          dom_loaded_handler();
        } else {
          e7.addEventListener("DOMContentLoaded", dom_loaded_handler, false);
        }
      } else if (e7.attachEvent) {
        e7.attachEvent("onreadystatechange", dom_loaded_handler);
        var m = false;
        try {
          m = eP.frameElement === null;
        } catch (m) {}
        if (e7.documentElement.doScroll && m) {
          (function do_scroll_check() {
            try {
              e7.documentElement.doScroll("left");
            } catch (m) {
              setTimeout(do_scroll_check, 1);
              return;
            }
            dom_loaded_handler();
          })();
        }
      }
      tl.register_event(eP, "load", dom_loaded_handler, true);
    })();
    var t3 = eL;
  },
  6840: function (m, _, C) {
    (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function () {
      return C(76723);
    }]);
  },
  62961: function (m, _, C) {
    "use strict";

    C.d(_, {
      $H: function () {
        return ey;
      },
      $w: function () {
        return Y;
      },
      AF: function () {
        return e2;
      },
      BG: function () {
        return eG;
      },
      BU: function () {
        return tn;
      },
      Bb: function () {
        return ev;
      },
      By: function () {
        return eT;
      },
      CP: function () {
        return tu;
      },
      C_: function () {
        return K;
      },
      Cy: function () {
        return R;
      },
      DQ: function () {
        return ti;
      },
      Dz: function () {
        return eb;
      },
      ER: function () {
        return eI;
      },
      FW: function () {
        return tl;
      },
      Fv: function () {
        return eL;
      },
      G: function () {
        return eK;
      },
      GJ: function () {
        return eJ;
      },
      Gu: function () {
        return to;
      },
      IP: function () {
        return tf;
      },
      KV: function () {
        return U;
      },
      Kv: function () {
        return ef;
      },
      LE: function () {
        return eN;
      },
      LT: function () {
        return ek;
      },
      Lp: function () {
        return eO;
      },
      Lw: function () {
        return e3;
      },
      Mc: function () {
        return er;
      },
      Mr: function () {
        return em;
      },
      NS: function () {
        return H;
      },
      NW: function () {
        return eH;
      },
      NZ: function () {
        return tp;
      },
      Nf: function () {
        return tr;
      },
      Nq: function () {
        return eF;
      },
      Nv: function () {
        return el;
      },
      Ny: function () {
        return ea;
      },
      OS: function () {
        return e8;
      },
      OT: function () {
        return ex;
      },
      PB: function () {
        return ta;
      },
      PT: function () {
        return eh;
      },
      Ph: function () {
        return eD;
      },
      Q$: function () {
        return e_;
      },
      QU: function () {
        return ep;
      },
      Qj: function () {
        return ec;
      },
      RP: function () {
        return e6;
      },
      R_: function () {
        return eP;
      },
      Rj: function () {
        return eW;
      },
      SM: function () {
        return tc;
      },
      Sb: function () {
        return L;
      },
      Sh: function () {
        return ei;
      },
      Tk: function () {
        return eM;
      },
      U6: function () {
        return eS;
      },
      Uk: function () {
        return F;
      },
      XA: function () {
        return e0;
      },
      XP: function () {
        return es;
      },
      Yk: function () {
        return Q;
      },
      Z8: function () {
        return eA;
      },
      Zm: function () {
        return tm;
      },
      _x: function () {
        return e5;
      },
      _z: function () {
        return eB;
      },
      bN: function () {
        return eQ;
      },
      bO: function () {
        return et;
      },
      bY: function () {
        return eZ;
      },
      c9: function () {
        return X;
      },
      cp: function () {
        return e9;
      },
      eB: function () {
        return eU;
      },
      eH: function () {
        return q;
      },
      eg: function () {
        return e7;
      },
      fd: function () {
        return en;
      },
      gQ: function () {
        return eo;
      },
      gr: function () {
        return eu;
      },
      hH: function () {
        return eE;
      },
      hj: function () {
        return e1;
      },
      i8: function () {
        return ez;
      },
      jQ: function () {
        return tt;
      },
      jT: function () {
        return ej;
      },
      jf: function () {
        return V;
      },
      jg: function () {
        return eR;
      },
      lC: function () {
        return ed;
      },
      lp: function () {
        return te;
      },
      mI: function () {
        return eq;
      },
      mT: function () {
        return th;
      },
      n4: function () {
        return eX;
      },
      n9: function () {
        return tv;
      },
      nX: function () {
        return eC;
      },
      ow: function () {
        return ts;
      },
      qq: function () {
        return ty;
      },
      t_: function () {
        return td;
      },
      vB: function () {
        return ew;
      },
      vH: function () {
        return tg;
      },
      vO: function () {
        return e4;
      },
      vx: function () {
        return e$;
      },
      we: function () {
        return eY;
      },
      wl: function () {
        return t_;
      },
      xe: function () {
        return B;
      },
      xf: function () {
        return eg;
      },
      xm: function () {
        return eV;
      }
    });
    let R = "USER_LOADED";
    let L = "RACE_LOADED";
    let B = "RELOADING_USER";
    let F = "WALLET_CHANGE";
    let U = "SET_AFFILIATE";
    let H = "SET_AUTO_BET_PLINKO";
    let q = "SET_AUTO_BET_TOWER";
    let V = "SET_AUTO_BET_MINE";
    let X = "SET_BLACKJACK_TABLE";
    let K = "SET_BLACKJACK_TABLES";
    let Y = "SET_BLACKJACK_DLS";
    let Q = "SET_CURRENT_CASE_BATTLE";
    let et = "SET_FIRST_LOADED";
    let er = "SET_WHERE_CAME_FROM";
    let en = "SET_ANALYTICSID2";
    let ei = "SET_DISCOUNTS_STATE";
    let eo = "UPDATE_PRIVACTE_MODE";
    let ea = "AUTH_ERROR";
    let es = "LOGIN_SUCCESS";
    let ec = "LOGIN_FAIL";
    let el = "LOGOUT";
    let eu = "SHOW_MODAL";
    let ed = "HIDE_MODAL";
    let ep = "SET_IP_ADDRESS";
    let eh = "HIDE_TWOFACTOR_MODAL";
    let ef = "HIDE_PROVABLYCONFIG_MODAL";
    let em = "SHOW_DEPOSIT";
    let eg = "HIDE_DEPOSIT";
    let ey = "SHOW_CRYPTO_DEPOSIT";
    let e_ = "SHOW_ROBUX_DEPOSIT";
    let ev = "SHOW_LAND_DEPOSIT";
    let eb = "SHOW_TWOFACTOR_MODAL";
    let eS = "SHOW_PROVABLYCONFIG_MODAL";
    let ew = "SHOW_ITEMS_DEPOSIT";
    let eE = "SHOW_DEPSOIT_ITEMS_SEMI";
    let ek = "SHOW_GIFTCARD_DEPOSIT";
    let ex = "SHOW_MARKETPLACE_MODAL";
    let eI = "SHOW_CARDS_DEPOSIT";
    let eO = "SHOW_SELLIX_DEPOSIT";
    let eC = "HIDE_CRYPTO_DEPOSIT";
    let eM = "HIDE_ROBUX_DEPOSIT";
    let eT = "HIDE_LAND_DEPOSIT";
    let eA = "HIDE_ITEMS_DEPOSIT";
    let eR = "HIDE_GIFTCARD_DEPOSIT";
    let eP = "HIDE_DEPSOIT_ITEMS_SEMI";
    let eD = "HIDE_MARKETPLACE_MODAL";
    let eL = "HIDE_CARDS_DEPOSIT";
    let eN = "SHOW_PROVABLY";
    let eB = "HIDE_PROVABLY";
    let ej = "SHOW_PROMO_DEPOSIT";
    let eF = "HIDE_PROMO_DEPOSIT";
    let eU = "SESSION_REFRESH";
    let eH = "SHOW_SOCIAL_MEDIA_DEPOSIT";
    let eW = "HIDE_SOCIAL_MEDIA_DEPOSIT";
    let e$ = "HIDE_PROFILE";
    let eq = "SHOW_ROBUX_WITHDRAW";
    let eG = "HIDE_ROBUX_WITHDRAW";
    let ez = "SHOW_WITHDRAW";
    let eV = "HIDE_WITHDRAW";
    let eJ = "HIDE_SELLIX_DEPOSIT";
    let eX = "SHOW_CHAT_RULES";
    let eK = "HIDE_CHAT_RULES";
    let eZ = "SHOW_FAQ";
    let eY = "HIDE_FAQ";
    let eQ = "SHOW_HISTORY_MODAL";
    let e0 = "HIDE_HISTORY_MODAL";
    let e1 = "SHOW_INFO_MODAL";
    let e2 = "HIDE_INFO_MODAL";
    let e3 = "SHOW_CONFIRM_LGOUT";
    let e5 = "HIDE_CONFIRM_LOGOUT";
    let e6 = "SHOW_PAYGARDEN_DEPOSIT";
    let e4 = "HIDE_PAYGARDEN_DEPOSIT";
    let e8 = "SHOW_SWAPPED_DEPOSIT";
    let e9 = "HIDE_SWAPPED_DEPOSIT";
    let e7 = "HIDE_FREE_CASE_MODAL";
    let te = "SHOW_FREE_CASE_MODAL";
    let tt = "SHOW_HOW_U_FOUND_US";
    let tr = "SHOW_HOW_U_FOUND_US";
    let tn = "SET_FFLAGS";
    let ti = "SHOW_RETENTION_MODAL";
    let to = "SHOW_AGE_VERIFY_MODAL";
    let ta = "FORCE_AGE_VERIFY_MODAL";
    let ts = "SHOW_MUTE_MODAL";
    let tc = "HIDE_MUTE_MODAL";
    let tl = "SHOW_DELETE_MODAL";
    let tu = "HIDE_DELETE_MODAL";
    let td = "SHOW_TIP_MODAL";
    let tp = "HIDE_TIP_MODAL";
    let th = "HIDE_AGE_VERIFY_MODAL";
    let tf = "SHOW_GIVEAWAY_MODAL";
    let tm = "HIDE_RETENTION_MODAL";
    let tg = "HIDE_GIVEAWAY_MODAL";
    let ty = "ENABLE_GEOBLOCK";
    let t_ = "HIDE_TWOFACTORTRADE_MODAL";
    let tv = "SET_GAME_IDS";
  },
  54847: function (m, _, C) {
    "use strict";

    function n(m) {
      for (var _ = arguments.length, C = Array(_ > 1 ? _ - 1 : 0), R = 1; R < _; R++) {
        C[R - 1] = arguments[R];
      }
      throw Error("[Immer] minified error nr: " + m + (C.length ? " " + C.map(function (m) {
        return "'" + m + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function r(m) {
      return !!m && !!m[K];
    }
    function t(m) {
      return !!m && (function (m) {
        if (!m || typeof m != "object") {
          return false;
        }
        var _ = Object.getPrototypeOf(m);
        if (_ === null) {
          return true;
        }
        var C = Object.hasOwnProperty.call(_, "constructor") && _.constructor;
        return C === Object || typeof C == "function" && Function.toString.call(C) === Y;
      }(m) || Array.isArray(m) || !!m[X] || !!m.constructor?.[X] || s(m) || v(m));
    }
    function i(m, _, C = false) {
      if (o(m) === 0) {
        (C ? Object.keys : Q)(m).forEach(function (R) {
          if (!C || typeof R != "symbol") {
            _(R, m[R], m);
          }
        });
      } else {
        m.forEach(function (C, R) {
          return _(R, C, m);
        });
      }
    }
    function o(m) {
      var _ = m[K];
      if (_) {
        if (_.i > 3) {
          return _.i - 4;
        } else {
          return _.i;
        }
      } else if (Array.isArray(m)) {
        return 1;
      } else if (s(m)) {
        return 2;
      } else if (v(m)) {
        return 3;
      } else {
        return 0;
      }
    }
    function u(m, _) {
      if (o(m) === 2) {
        return m.has(_);
      } else {
        return Object.prototype.hasOwnProperty.call(m, _);
      }
    }
    function f(m, _, C) {
      var R = o(m);
      if (R === 2) {
        m.set(_, C);
      } else if (R === 3) {
        m.add(C);
      } else {
        m[_] = C;
      }
    }
    function c(m, _) {
      if (m === _) {
        return m !== 0 || 1 / m == 1 / _;
      } else {
        return m != m && _ != _;
      }
    }
    function s(m) {
      return U && m instanceof Map;
    }
    function v(m) {
      return H && m instanceof Set;
    }
    function p(m) {
      return m.o || m.t;
    }
    function l(m) {
      if (Array.isArray(m)) {
        return Array.prototype.slice.call(m);
      }
      var _ = et(m);
      delete _[K];
      for (var C = Q(_), R = 0; R < C.length; R++) {
        var L = C[R];
        var B = _[L];
        if (B.writable === false) {
          B.writable = true;
          B.configurable = true;
        }
        if (B.get || B.set) {
          _[L] = {
            configurable: true,
            writable: true,
            enumerable: B.enumerable,
            value: m[L]
          };
        }
      }
      return Object.create(Object.getPrototypeOf(m), _);
    }
    function d(m, _ = false) {
      if (!y(m) && !r(m) && !!t(m)) {
        if (o(m) > 1) {
          m.set = m.add = m.clear = m.delete = h;
        }
        Object.freeze(m);
        if (_) {
          i(m, function (m, _) {
            return d(_, true);
          }, true);
        }
      }
      return m;
    }
    function h() {
      n(2);
    }
    function y(m) {
      return m == null || typeof m != "object" || Object.isFrozen(m);
    }
    function b(m) {
      var _ = er[m];
      if (!_) {
        n(18, m);
      }
      return _;
    }
    function j(m, _) {
      if (_) {
        b("Patches");
        m.u = [];
        m.s = [];
        m.v = _;
      }
    }
    function g(m) {
      O(m);
      m.p.forEach(S);
      m.p = null;
    }
    function O(m) {
      if (m === B) {
        B = m.l;
      }
    }
    function w(m) {
      return B = {
        p: [],
        l: B,
        h: m,
        m: true,
        _: 0
      };
    }
    function S(m) {
      var _ = m[K];
      if (_.i === 0 || _.i === 1) {
        _.j();
      } else {
        _.g = true;
      }
    }
    function P(m, _) {
      _._ = _.p.length;
      var C = _.p[0];
      var R = m !== undefined && m !== C;
      if (!_.h.O) {
        b("ES5").S(_, m, R);
      }
      if (R) {
        if (C[K].P) {
          g(_);
          n(4);
        }
        if (t(m)) {
          m = M(_, m);
          if (!_.l) {
            x(_, m);
          }
        }
        if (_.u) {
          b("Patches").M(C[K].t, m, _.u, _.s);
        }
      } else {
        m = M(_, C, []);
      }
      g(_);
      if (_.u) {
        _.v(_.u, _.s);
      }
      if (m !== V) {
        return m;
      } else {
        return undefined;
      }
    }
    function M(m, _, C) {
      if (y(_)) {
        return _;
      }
      var R = _[K];
      if (!R) {
        i(_, function (L, B) {
          return A(m, R, _, L, B, C);
        }, true);
        return _;
      }
      if (R.A !== m) {
        return _;
      }
      if (!R.P) {
        x(m, R.t, true);
        return R.t;
      }
      if (!R.I) {
        R.I = true;
        R.A._--;
        var L = R.i === 4 || R.i === 5 ? R.o = l(R.k) : R.o;
        var B = L;
        var F = false;
        if (R.i === 3) {
          B = new Set(L);
          L.clear();
          F = true;
        }
        i(B, function (_, B) {
          return A(m, R, L, _, B, C, F);
        });
        x(m, L, false);
        if (C && m.u) {
          b("Patches").N(R, C, m.u, m.s);
        }
      }
      return R.o;
    }
    function A(m, _, C, R, L, B, F) {
      if (r(L)) {
        var U = M(m, L, B && _ && _.i !== 3 && !u(_.R, R) ? B.concat(R) : undefined);
        f(C, R, U);
        if (!r(U)) {
          return;
        }
        m.m = false;
      } else if (F) {
        C.add(L);
      }
      if (t(L) && !y(L)) {
        if (!m.h.D && m._ < 1) {
          return;
        }
        M(m, L);
        if (!_ || !_.A.l) {
          x(m, L);
        }
      }
    }
    function x(m, _, C = false) {
      if (!m.l && m.h.D && m.m) {
        d(_, C);
      }
    }
    function z(m, _) {
      var C = m[K];
      return (C ? p(C) : m)[_];
    }
    function I(m, _) {
      if (_ in m) {
        for (var C = Object.getPrototypeOf(m); C;) {
          var R = Object.getOwnPropertyDescriptor(C, _);
          if (R) {
            return R;
          }
          C = Object.getPrototypeOf(C);
        }
      }
    }
    function k(m) {
      if (!m.P) {
        m.P = true;
        if (m.l) {
          k(m.l);
        }
      }
    }
    function E(m) {
      m.o ||= l(m.t);
    }
    function N(m, _, C) {
      var R;
      var L;
      var F;
      var U;
      var H;
      var q;
      var V;
      var X = s(_) ? b("MapSet").F(_, C) : v(_) ? b("MapSet").T(_, C) : m.O ? (F = L = {
        i: (R = Array.isArray(_)) ? 1 : 0,
        A: C ? C.A : B,
        P: false,
        I: false,
        R: {},
        l: C,
        t: _,
        k: null,
        o: null,
        j: null,
        C: false
      }, U = en, R && (F = [L], U = ei), q = (H = Proxy.revocable(F, U)).revoke, V = H.proxy, L.k = V, L.j = q, V) : b("ES5").J(_, C);
      (C ? C.A : B).p.push(X);
      return X;
    }
    function D(m, _) {
      switch (_) {
        case 2:
          return new Map(m);
        case 3:
          return Array.from(m);
      }
      return l(m);
    }
    C.d(_, {
      Z: function () {
        return eM;
      }
    });
    var R;
    var L;
    var B;
    var F = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
    var U = typeof Map != "undefined";
    var H = typeof Set != "undefined";
    var q = typeof Proxy != "undefined" && Proxy.revocable !== undefined && typeof Reflect != "undefined";
    var V = F ? Symbol.for("immer-nothing") : ((L = {})["immer-nothing"] = true, L);
    var X = F ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var K = F ? Symbol.for("immer-state") : "__$immer_state";
    var Y = "" + Object.prototype.constructor;
    var Q = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== undefined ? function (m) {
      return Object.getOwnPropertyNames(m).concat(Object.getOwnPropertySymbols(m));
    } : Object.getOwnPropertyNames;
    var et = Object.getOwnPropertyDescriptors || function (m) {
      var _ = {};
      Q(m).forEach(function (C) {
        _[C] = Object.getOwnPropertyDescriptor(m, C);
      });
      return _;
    };
    var er = {};
    var en = {
      get: function (m, _) {
        if (_ === K) {
          return m;
        }
        var C;
        var R;
        var L = p(m);
        if (!u(L, _)) {
          if (R = I(L, _)) {
            if ("value" in R) {
              return R.value;
            } else if ((C = R.get) === null || C === undefined) {
              return undefined;
            } else {
              return C.call(m.k);
            }
          } else {
            return undefined;
          }
        }
        var B = L[_];
        if (m.I || !t(B)) {
          return B;
        } else if (B === z(m.t, _)) {
          E(m);
          return m.o[_] = N(m.A.h, B, m);
        } else {
          return B;
        }
      },
      has: function (m, _) {
        return _ in p(m);
      },
      ownKeys: function (m) {
        return Reflect.ownKeys(p(m));
      },
      set: function (m, _, C) {
        var R = I(p(m), _);
        if (R == null ? undefined : R.set) {
          R.set.call(m.k, C);
          return true;
        }
        if (!m.P) {
          var L = z(p(m), _);
          var B = L == null ? undefined : L[K];
          if (B && B.t === C) {
            m.o[_] = C;
            m.R[_] = false;
            return true;
          }
          if (c(C, L) && (C !== undefined || u(m.t, _))) {
            return true;
          }
          E(m);
          k(m);
        }
        if ((m.o[_] !== C || C === undefined && !(_ in m.o)) && (!Number.isNaN(C) || !Number.isNaN(m.o[_]))) {
          m.o[_] = C;
          m.R[_] = true;
        }
        return true;
      },
      deleteProperty: function (m, _) {
        if (z(m.t, _) !== undefined || _ in m.t) {
          m.R[_] = false;
          E(m);
          k(m);
        } else {
          delete m.R[_];
        }
        if (m.o) {
          delete m.o[_];
        }
        return true;
      },
      getOwnPropertyDescriptor: function (m, _) {
        var C = p(m);
        var R = Reflect.getOwnPropertyDescriptor(C, _);
        if (R) {
          return {
            writable: true,
            configurable: m.i !== 1 || _ !== "length",
            enumerable: R.enumerable,
            value: C[_]
          };
        } else {
          return R;
        }
      },
      defineProperty: function () {
        n(11);
      },
      getPrototypeOf: function (m) {
        return Object.getPrototypeOf(m.t);
      },
      setPrototypeOf: function () {
        n(12);
      }
    };
    var ei = {};
    i(en, function (m, _) {
      ei[m] = function () {
        arguments[0] = arguments[0][0];
        return _.apply(this, arguments);
      };
    });
    ei.deleteProperty = function (m, _) {
      return ei.set.call(this, m, _, undefined);
    };
    ei.set = function (m, _, C) {
      return en.set.call(this, m[0], _, C, m[0]);
    };
    var eo = new (function () {
      function e(m) {
        var _ = this;
        this.O = q;
        this.D = true;
        this.produce = function (m, C, R) {
          if (typeof m == "function" && typeof C != "function") {
            var L;
            var B = C;
            C = m;
            return function (m) {
              var R = this;
              if (m === undefined) {
                m = B;
              }
              for (var L = arguments.length, F = Array(L > 1 ? L - 1 : 0), U = 1; U < L; U++) {
                F[U - 1] = arguments[U];
              }
              return _.produce(m, function (m) {
                var _;
                return (_ = C).call.apply(_, [R, m].concat(F));
              });
            };
          }
          if (typeof C != "function") {
            n(6);
          }
          if (R !== undefined && typeof R != "function") {
            n(7);
          }
          if (t(m)) {
            var F = w(_);
            var U = N(_, m, undefined);
            var H = true;
            try {
              L = C(U);
              H = false;
            } finally {
              if (H) {
                g(F);
              } else {
                O(F);
              }
            }
            if (typeof Promise != "undefined" && L instanceof Promise) {
              return L.then(function (m) {
                j(F, R);
                return P(m, F);
              }, function (m) {
                g(F);
                throw m;
              });
            } else {
              j(F, R);
              return P(L, F);
            }
          }
          if (!m || typeof m != "object") {
            if ((L = C(m)) === undefined) {
              L = m;
            }
            if (L === V) {
              L = undefined;
            }
            if (_.D) {
              d(L, true);
            }
            if (R) {
              var q = [];
              var X = [];
              b("Patches").M(m, L, q, X);
              R(q, X);
            }
            return L;
          }
          n(21, m);
        };
        this.produceWithPatches = function (m, C) {
          if (typeof m == "function") {
            return function (C) {
              for (var R = arguments.length, L = Array(R > 1 ? R - 1 : 0), B = 1; B < R; B++) {
                L[B - 1] = arguments[B];
              }
              return _.produceWithPatches(C, function (_) {
                return m.apply(undefined, [_].concat(L));
              });
            };
          }
          var R;
          var L;
          var B = _.produce(m, C, function (m, _) {
            R = m;
            L = _;
          });
          if (typeof Promise != "undefined" && B instanceof Promise) {
            return B.then(function (m) {
              return [m, R, L];
            });
          } else {
            return [B, R, L];
          }
        };
        if (typeof (m == null ? undefined : m.useProxies) == "boolean") {
          this.setUseProxies(m.useProxies);
        }
        if (typeof (m == null ? undefined : m.autoFreeze) == "boolean") {
          this.setAutoFreeze(m.autoFreeze);
        }
      }
      var m = e.prototype;
      m.createDraft = function (m) {
        if (!t(m)) {
          n(8);
        }
        if (r(m)) {
          if (!r(_ = m)) {
            n(22, _);
          }
          m = function n(m) {
            if (!t(m)) {
              return m;
            }
            var _;
            var C = m[K];
            var R = o(m);
            if (C) {
              if (!C.P && (C.i < 4 || !b("ES5").K(C))) {
                return C.t;
              }
              C.I = true;
              _ = D(m, R);
              C.I = false;
            } else {
              _ = D(m, R);
            }
            i(_, function (m, R) {
              var L;
              if (!C || (o(L = C.t) === 2 ? L.get(m) : L[m]) !== R) {
                f(_, m, n(R));
              }
            });
            if (R === 3) {
              return new Set(_);
            } else {
              return _;
            }
          }(_);
        }
        var _;
        var C = w(this);
        var R = N(this, m, undefined);
        R[K].C = true;
        O(C);
        return R;
      };
      m.finishDraft = function (m, _) {
        var C = (m && m[K]).A;
        j(C, _);
        return P(undefined, C);
      };
      m.setAutoFreeze = function (m) {
        this.D = m;
      };
      m.setUseProxies = function (m) {
        if (m && !q) {
          n(20);
        }
        this.O = m;
      };
      m.applyPatches = function (m, _) {
        for (C = _.length - 1; C >= 0; C--) {
          var C;
          var R = _[C];
          if (R.path.length === 0 && R.op === "replace") {
            m = R.value;
            break;
          }
        }
        if (C > -1) {
          _ = _.slice(C + 1);
        }
        var L = b("Patches").$;
        if (r(m)) {
          return L(m, _);
        } else {
          return this.produce(m, function (m) {
            return L(m, _);
          });
        }
      };
      return e;
    }())();
    eo.produce;
    eo.produceWithPatches.bind(eo);
    eo.setAutoFreeze.bind(eo);
    eo.setUseProxies.bind(eo);
    eo.applyPatches.bind(eo);
    eo.createDraft.bind(eo);
    eo.finishDraft.bind(eo);
    var ea = C(1413);
    function formatProdErrorMessage(m) {
      return "Minified Redux error #" + m + "; visit https://redux.js.org/Errors?code=" + m + " for the full message or use the non-minified dev environment for full errors. ";
    }
    var es = typeof Symbol == "function" && Symbol.observable || "@@observable";
    function randomString() {
      return Math.random().toString(36).substring(7).split("").join(".");
    }
    var ec = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function () {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
    function compose() {
      for (var m = arguments.length, _ = Array(m), C = 0; C < m; C++) {
        _[C] = arguments[C];
      }
      if (_.length === 0) {
        return function (m) {
          return m;
        };
      } else if (_.length === 1) {
        return _[0];
      } else {
        return _.reduce(function (m, _) {
          return function () {
            return m(_.apply(undefined, arguments));
          };
        });
      }
    }
    function applyMiddleware() {
      for (var m = arguments.length, _ = Array(m), C = 0; C < m; C++) {
        _[C] = arguments[C];
      }
      return function (m) {
        return function () {
          var C = m.apply(undefined, arguments);
          function _dispatch() {
            throw Error(formatProdErrorMessage(15));
          }
          var R = {
            getState: C.getState,
            dispatch: function () {
              return _dispatch.apply(undefined, arguments);
            }
          };
          var L = _.map(function (m) {
            return m(R);
          });
          _dispatch = compose.apply(undefined, L)(C.dispatch);
          return (0, ea.Z)((0, ea.Z)({}, C), {}, {
            dispatch: _dispatch
          });
        };
      };
    }
    function createThunkMiddleware(m) {
      return function (_) {
        var C = _.dispatch;
        var R = _.getState;
        return function (_) {
          return function (L) {
            if (typeof L == "function") {
              return L(C, R, m);
            } else {
              return _(L);
            }
          };
        };
      };
    }
    var el = createThunkMiddleware();
    el.withExtraArgument = createThunkMiddleware;
    C(34155);
    R = function (m, _) {
      return (R = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (m, _) {
        m.__proto__ = _;
      } || function (m, _) {
        for (var C in _) {
          if (Object.prototype.hasOwnProperty.call(_, C)) {
            m[C] = _[C];
          }
        }
      })(m, _);
    };
    function eu(m, _) {
      if (typeof _ != "function" && _ !== null) {
        throw TypeError("Class extends value " + String(_) + " is not a constructor or null");
      }
      function __() {
        this.constructor = m;
      }
      R(m, _);
      m.prototype = _ === null ? Object.create(_) : (__.prototype = _.prototype, new __());
    }
    function __generator(m, _) {
      var C;
      var R;
      var L;
      var B;
      var F = {
        label: 0,
        sent: function () {
          if (L[0] & 1) {
            throw L[1];
          }
          return L[1];
        },
        trys: [],
        ops: []
      };
      B = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      };
      if (typeof Symbol == "function") {
        B[Symbol.iterator] = function () {
          return this;
        };
      }
      return B;
      function verb(B) {
        return function (U) {
          return function (B) {
            if (C) {
              throw TypeError("Generator is already executing.");
            }
            while (F) {
              try {
                C = 1;
                if (R && (L = B[0] & 2 ? R.return : B[0] ? R.throw || ((L = R.return) && L.call(R), 0) : R.next) && !(L = L.call(R, B[1])).done) {
                  return L;
                }
                R = 0;
                if (L) {
                  B = [B[0] & 2, L.value];
                }
                switch (B[0]) {
                  case 0:
                  case 1:
                    L = B;
                    break;
                  case 4:
                    F.label++;
                    return {
                      value: B[1],
                      done: false
                    };
                  case 5:
                    F.label++;
                    R = B[1];
                    B = [0];
                    continue;
                  case 7:
                    B = F.ops.pop();
                    F.trys.pop();
                    continue;
                  default:
                    if (!(L = (L = F.trys).length > 0 && L[L.length - 1]) && (B[0] === 6 || B[0] === 2)) {
                      F = 0;
                      continue;
                    }
                    if (B[0] === 3 && (!L || B[1] > L[0] && B[1] < L[3])) {
                      F.label = B[1];
                      break;
                    }
                    if (B[0] === 6 && F.label < L[1]) {
                      F.label = L[1];
                      L = B;
                      break;
                    }
                    if (L && F.label < L[2]) {
                      F.label = L[2];
                      F.ops.push(B);
                      break;
                    }
                    if (L[2]) {
                      F.ops.pop();
                    }
                    F.trys.pop();
                    continue;
                }
                B = _.call(m, F);
              } catch (m) {
                B = [6, m];
                R = 0;
              } finally {
                C = L = 0;
              }
            }
            if (B[0] & 5) {
              throw B[1];
            }
            return {
              value: B[0] ? B[1] : undefined,
              done: true
            };
          }([B, U]);
        };
      }
    }
    function __spreadArray(m, _) {
      for (var C = 0, R = _.length, L = m.length; C < R; C++, L++) {
        m[L] = _[C];
      }
      return m;
    }
    var ed = Object.defineProperty;
    var ep = Object.defineProperties;
    var eh = Object.getOwnPropertyDescriptors;
    var ef = Object.getOwnPropertySymbols;
    var em = Object.prototype.hasOwnProperty;
    var eg = Object.prototype.propertyIsEnumerable;
    function __defNormalProp(m, _, C) {
      if (_ in m) {
        return ed(m, _, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: C
        });
      } else {
        return m[_] = C;
      }
    }
    function __spreadValues(m, _) {
      for (var C in _ ||= {}) {
        if (em.call(_, C)) {
          __defNormalProp(m, C, _[C]);
        }
      }
      if (ef) {
        for (var R = 0, L = ef(_); R < L.length; R++) {
          var C = L[R];
          if (eg.call(_, C)) {
            __defNormalProp(m, C, _[C]);
          }
        }
      }
      return m;
    }
    function __spreadProps(m, _) {
      return ep(m, eh(_));
    }
    var ey = typeof window != "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
      if (arguments.length != 0) {
        if (typeof arguments[0] == "object") {
          return compose;
        } else {
          return compose.apply(null, arguments);
        }
      }
    };
    function createAction(m, _) {
      function actionCreator() {
        var C = [];
        for (var R = 0; R < arguments.length; R++) {
          C[R] = arguments[R];
        }
        if (_) {
          var L = _.apply(undefined, C);
          if (!L) {
            throw Error("prepareAction did not return an object");
          }
          return __spreadValues(__spreadValues({
            type: m,
            payload: L.payload
          }, "meta" in L && {
            meta: L.meta
          }), "error" in L && {
            error: L.error
          });
        }
        return {
          type: m,
          payload: C[0]
        };
      }
      actionCreator.toString = function () {
        return "" + m;
      };
      actionCreator.type = m;
      actionCreator.match = function (_) {
        return _.type === m;
      };
      return actionCreator;
    }
    if (typeof window != "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__) {
      window.__REDUX_DEVTOOLS_EXTENSION__;
    }
    var e_ = function (m) {
      function MiddlewareArray() {
        var _ = [];
        for (var C = 0; C < arguments.length; C++) {
          _[C] = arguments[C];
        }
        var R = m.apply(this, _) || this;
        Object.setPrototypeOf(R, MiddlewareArray.prototype);
        return R;
      }
      eu(MiddlewareArray, m);
      Object.defineProperty(MiddlewareArray, Symbol.species, {
        get: function () {
          return MiddlewareArray;
        },
        enumerable: false,
        configurable: true
      });
      MiddlewareArray.prototype.concat = function () {
        var _ = [];
        for (var C = 0; C < arguments.length; C++) {
          _[C] = arguments[C];
        }
        return m.prototype.concat.apply(this, _);
      };
      MiddlewareArray.prototype.prepend = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        if (m.length === 1 && Array.isArray(m[0])) {
          return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([undefined], m[0].concat(this))))();
        } else {
          return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([undefined], m.concat(this))))();
        }
      };
      return MiddlewareArray;
    }(Array);
    var ev = function (m) {
      function EnhancerArray() {
        var _ = [];
        for (var C = 0; C < arguments.length; C++) {
          _[C] = arguments[C];
        }
        var R = m.apply(this, _) || this;
        Object.setPrototypeOf(R, EnhancerArray.prototype);
        return R;
      }
      eu(EnhancerArray, m);
      Object.defineProperty(EnhancerArray, Symbol.species, {
        get: function () {
          return EnhancerArray;
        },
        enumerable: false,
        configurable: true
      });
      EnhancerArray.prototype.concat = function () {
        var _ = [];
        for (var C = 0; C < arguments.length; C++) {
          _[C] = arguments[C];
        }
        return m.prototype.concat.apply(this, _);
      };
      EnhancerArray.prototype.prepend = function () {
        var m = [];
        for (var _ = 0; _ < arguments.length; _++) {
          m[_] = arguments[_];
        }
        if (m.length === 1 && Array.isArray(m[0])) {
          return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([undefined], m[0].concat(this))))();
        } else {
          return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([undefined], m.concat(this))))();
        }
      };
      return EnhancerArray;
    }(Array);
    function getDefaultMiddleware(m = {}) {
      var _ = m.thunk;
      var C = _ === undefined || _;
      m.immutableCheck;
      m.serializableCheck;
      m.actionCreatorCheck;
      var R = new e_();
      if (C) {
        if (typeof C == "boolean") {
          R.push(el);
        } else {
          R.push(el.withExtraArgument(C.extraArgument));
        }
      }
      return R;
    }
    function nanoid(m = 21) {
      var _ = "";
      for (var C = m; C--;) {
        _ += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[Math.random() * 64 | 0];
      }
      return _;
    }
    var eb = ["name", "message", "stack", "code"];
    function RejectWithValue(m, _) {
      this.payload = m;
      this.meta = _;
    }
    function FulfillWithMeta(m, _) {
      this.payload = m;
      this.meta = _;
    }
    function miniSerializeError(m) {
      if (typeof m == "object" && m !== null) {
        var _ = {};
        for (var C = 0; C < eb.length; C++) {
          var R = eb[C];
          if (typeof m[R] == "string") {
            _[R] = m[R];
          }
        }
        return _;
      }
      return {
        message: String(m)
      };
    }
    function unwrapResult(m) {
      if (m.meta && m.meta.rejectedWithValue) {
        throw m.payload;
      }
      if (m.error) {
        throw m.error;
      }
      return m.payload;
    }
    (function () {
      function createAsyncThunk2(m, _, C) {
        var R = createAction(m + "/fulfilled", function (m, _, C, R) {
          return {
            payload: m,
            meta: __spreadProps(__spreadValues({}, R || {}), {
              arg: C,
              requestId: _,
              requestStatus: "fulfilled"
            })
          };
        });
        var L = createAction(m + "/pending", function (m, _, C) {
          return {
            payload: undefined,
            meta: __spreadProps(__spreadValues({}, C || {}), {
              arg: _,
              requestId: m,
              requestStatus: "pending"
            })
          };
        });
        var B = createAction(m + "/rejected", function (m, _, R, L, B) {
          return {
            payload: L,
            error: (C && C.serializeError || miniSerializeError)(m || "Rejected"),
            meta: __spreadProps(__spreadValues({}, B || {}), {
              arg: R,
              requestId: _,
              rejectedWithValue: !!L,
              requestStatus: "rejected",
              aborted: (m == null ? undefined : m.name) === "AbortError",
              condition: (m == null ? undefined : m.name) === "ConditionError"
            })
          };
        });
        var F = typeof AbortController != "undefined" ? AbortController : function () {
          function class_1() {
            this.signal = {
              aborted: false,
              addEventListener: function () {},
              dispatchEvent: function () {
                return false;
              },
              onabort: function () {},
              removeEventListener: function () {},
              reason: undefined,
              throwIfAborted: function () {}
            };
          }
          class_1.prototype.abort = function () {};
          return class_1;
        }();
        return Object.assign(function (m) {
          return function (U, H, q) {
            var V;
            var X = (C == null ? undefined : C.idGenerator) ? C.idGenerator(m) : nanoid();
            var K = new F();
            function abort(m) {
              V = m;
              K.abort();
            }
            var Y = function () {
              var F;
              var Y;
              F = this;
              Y = function () {
                var F;
                var Y;
                var Q;
                var et;
                var er;
                var en;
                return __generator(this, function (ei) {
                  switch (ei.label) {
                    case 0:
                      var eo;
                      ei.trys.push([0, 4,, 5]);
                      if ((eo = et = (F = C == null ? undefined : C.condition) == null ? undefined : F.call(C, m, {
                        getState: H,
                        extra: q
                      })) === null || typeof eo != "object" || typeof eo.then != "function") {
                        return [3, 2];
                      }
                      return [4, et];
                    case 1:
                      et = ei.sent();
                      ei.label = 2;
                    case 2:
                      if (et === false || K.signal.aborted) {
                        throw {
                          name: "ConditionError",
                          message: "Aborted due to condition callback returning false."
                        };
                      }
                      er = new Promise(function (m, _) {
                        return K.signal.addEventListener("abort", function () {
                          return _({
                            name: "AbortError",
                            message: V || "Aborted"
                          });
                        });
                      });
                      U(L(X, m, (Y = C == null ? undefined : C.getPendingMeta) == null ? undefined : Y.call(C, {
                        requestId: X,
                        arg: m
                      }, {
                        getState: H,
                        extra: q
                      })));
                      return [4, Promise.race([er, Promise.resolve(_(m, {
                        dispatch: U,
                        getState: H,
                        extra: q,
                        requestId: X,
                        signal: K.signal,
                        abort: abort,
                        rejectWithValue: function (m, _) {
                          return new RejectWithValue(m, _);
                        },
                        fulfillWithValue: function (m, _) {
                          return new FulfillWithMeta(m, _);
                        }
                      })).then(function (_) {
                        if (_ instanceof RejectWithValue) {
                          throw _;
                        }
                        if (_ instanceof FulfillWithMeta) {
                          return R(_.payload, X, m, _.meta);
                        } else {
                          return R(_, X, m);
                        }
                      })])];
                    case 3:
                      Q = ei.sent();
                      return [3, 5];
                    case 4:
                      Q = (en = ei.sent()) instanceof RejectWithValue ? B(null, X, m, en.payload, en.meta) : B(en, X, m);
                      return [3, 5];
                    case 5:
                      if (!C || !!C.dispatchConditionRejection || !B.match(Q) || !Q.meta.condition) {
                        U(Q);
                      }
                      return [2, Q];
                  }
                });
              };
              return new Promise(function (m, _) {
                function fulfilled(m) {
                  try {
                    step(Y.next(m));
                  } catch (m) {
                    _(m);
                  }
                }
                function rejected(m) {
                  try {
                    step(Y.throw(m));
                  } catch (m) {
                    _(m);
                  }
                }
                function step(_) {
                  if (_.done) {
                    return m(_.value);
                  } else {
                    return Promise.resolve(_.value).then(fulfilled, rejected);
                  }
                }
                step((Y = Y.apply(F, null)).next());
              });
            }();
            return Object.assign(Y, {
              abort: abort,
              requestId: X,
              arg: m,
              unwrap: function () {
                return Y.then(unwrapResult);
              }
            });
          };
        }, {
          pending: L,
          rejected: B,
          fulfilled: R,
          typePrefix: m
        });
      }
      createAsyncThunk2.withTypes = function () {
        return createAsyncThunk2;
      };
    })();
    var eS = "listenerMiddleware";
    createAction(eS + "/add");
    createAction(eS + "/removeAll");
    createAction(eS + "/remove");
    if (typeof queueMicrotask == "function") {
      queueMicrotask.bind(typeof window != "undefined" ? window : C.g !== undefined ? C.g : globalThis);
    }
    if (typeof window != "undefined" && window.requestAnimationFrame) {
      window.requestAnimationFrame;
    }
    (function () {
      function t(_, C) {
        var R = m[_];
        if (R) {
          R.enumerable = C;
        } else {
          m[_] = R = {
            configurable: true,
            enumerable: C,
            get: function () {
              var m = this[K];
              return en.get(m, _);
            },
            set: function (m) {
              var C = this[K];
              en.set(C, _, m);
            }
          };
        }
        return R;
      }
      function e(m) {
        for (var _ = m.length - 1; _ >= 0; _--) {
          var C = m[_][K];
          if (!C.P) {
            switch (C.i) {
              case 5:
                if (a(C)) {
                  k(C);
                }
                break;
              case 4:
                if (o(C)) {
                  k(C);
                }
            }
          }
        }
      }
      function o(m) {
        var _ = m.t;
        var C = m.k;
        var R = Q(C);
        for (var L = R.length - 1; L >= 0; L--) {
          var B = R[L];
          if (B !== K) {
            var F = _[B];
            if (F === undefined && !u(_, B)) {
              return true;
            }
            var U = C[B];
            var H = U && U[K];
            if (H ? H.t !== F : !c(U, F)) {
              return true;
            }
          }
        }
        var q = !!_[K];
        return R.length !== Q(_).length + (q ? 0 : 1);
      }
      function a(m) {
        var _ = m.k;
        if (_.length !== m.t.length) {
          return true;
        }
        var C = Object.getOwnPropertyDescriptor(_, _.length - 1);
        if (C && !C.get) {
          return true;
        }
        for (var R = 0; R < _.length; R++) {
          if (!_.hasOwnProperty(R)) {
            return true;
          }
        }
        return false;
      }
      var m = {};
      er.ES5 ||= {
        J: function (m, _) {
          var C = Array.isArray(m);
          var R = function (m, _) {
            if (m) {
              var C = Array(_.length);
              for (var R = 0; R < _.length; R++) {
                Object.defineProperty(C, "" + R, t(R, true));
              }
              return C;
            }
            var L = et(_);
            delete L[K];
            for (var B = Q(L), F = 0; F < B.length; F++) {
              var U = B[F];
              L[U] = t(U, m || !!L[U].enumerable);
            }
            return Object.create(Object.getPrototypeOf(_), L);
          }(C, m);
          var L = {
            i: C ? 5 : 4,
            A: _ ? _.A : B,
            P: false,
            I: false,
            R: {},
            l: _,
            t: m,
            k: R,
            o: null,
            g: false,
            C: false
          };
          Object.defineProperty(R, K, {
            value: L,
            writable: true
          });
          return R;
        },
        S: function (m, _, C) {
          if (C) {
            if (r(_) && _[K].A === m) {
              e(m.p);
            }
          } else {
            if (m.u) {
              (function n(m) {
                if (m && typeof m == "object") {
                  var _ = m[K];
                  if (_) {
                    var C = _.t;
                    var R = _.k;
                    var L = _.R;
                    var B = _.i;
                    if (B === 4) {
                      i(R, function (m) {
                        if (m !== K) {
                          if (C[m] !== undefined || u(C, m)) {
                            if (!L[m]) {
                              n(R[m]);
                            }
                          } else {
                            L[m] = true;
                            k(_);
                          }
                        }
                      });
                      i(C, function (m) {
                        if (R[m] === undefined && !u(R, m)) {
                          L[m] = false;
                          k(_);
                        }
                      });
                    } else if (B === 5) {
                      if (a(_)) {
                        k(_);
                        L.length = true;
                      }
                      if (R.length < C.length) {
                        for (var F = R.length; F < C.length; F++) {
                          L[F] = false;
                        }
                      } else {
                        for (var U = C.length; U < R.length; U++) {
                          L[U] = true;
                        }
                      }
                      for (var H = Math.min(R.length, C.length), q = 0; q < H; q++) {
                        if (!R.hasOwnProperty(q)) {
                          L[q] = true;
                        }
                        if (L[q] === undefined) {
                          n(R[q]);
                        }
                      }
                    }
                  }
                }
              })(m.p[0]);
            }
            e(m.p);
          }
        },
        K: function (m) {
          if (m.i === 4) {
            return o(m);
          } else {
            return a(m);
          }
        }
      };
    })();
    var ew = C(62961);
    var eE = C(49089);
    var ek = C(40400);
    var ex = C(83198);
    let eI = {};
    eI = {
      factoredTradeModal: {
        visible: false,
        tradeId: 0
      },
      token: localStorage.getItem("token"),
      firstLoaded: false,
      analyticsId2: null,
      ipAddress: null,
      fflags: {
        slots_enabled: null
      },
      cbGame: null,
      bjTables: null,
      bjTable: null,
      bjDecisions: {
        currentDecision: null,
        decisionList: []
      },
      discounts: null,
      isAuthenticated: null,
      lastSessionRefresh: 0,
      isLoading: true,
      user: null,
      affiliate: null,
      wherefromcard: false,
      autoBetPlinko: false,
      autoBetTower: false,
      autoBetMine: false,
      showLoginModal: false,
      showWithdraw: false,
      showProvably: {
        show: false,
        provablyData: null
      },
      showDeposit: null,
      showCryptoDeposit: null,
      showHowUFoundUs: null,
      showSellixDeposit: null,
      showPaygardenDeposit: null,
      showSwappedDeposit: null,
      showFreeCaseModal: null,
      showGiftcardDeposit: null,
      showRobuxDeposit: null,
      showItemsDeposit: null,
      showItemsSemiDeposit: null,
      showLandDeposit: null,
      showPromoDeposit: null,
      showSocialMediaDeposit: null,
      showMarketplaceModal: null,
      showRobuxWithdraw: null,
      showChatRules: false,
      showFaq: false,
      showConfirmLogout: false,
      showRentionModal: false,
      showAgeVerifyModal: false,
      showGiveawayModal: true,
      showInfo: {
        show: false,
        infoFor: null
      },
      showHistoryModal: {
        show: false,
        gameType: null,
        historyData: null
      },
      showMuteModal: {
        show: false,
        message: null
      },
      showDeleteModal: {
        show: false,
        message: null
      },
      showTipModal: {
        show: false,
        message: null
      }
    };
    let eO = getDefaultMiddleware({
      immutableCheck: false,
      serializableCheck: false
    });
    let eC = function (m) {
      var _;
      function curriedGetDefaultMiddleware(m) {
        return getDefaultMiddleware(m);
      }
      var C = m || {};
      var R = C.reducer;
      var L = R === undefined ? undefined : R;
      var B = C.middleware;
      var F = B === undefined ? curriedGetDefaultMiddleware() : B;
      var U = C.devTools;
      var H = U === undefined || U;
      var q = C.preloadedState;
      var V = q === undefined ? undefined : q;
      var X = C.enhancers;
      var K = X === undefined ? undefined : X;
      if (typeof L == "function") {
        _ = L;
      } else if (function (m) {
        if (typeof m != "object" || m === null) {
          return false;
        }
        var _ = Object.getPrototypeOf(m);
        if (_ === null) {
          return true;
        }
        for (var C = _; Object.getPrototypeOf(C) !== null;) {
          C = Object.getPrototypeOf(C);
        }
        return _ === C;
      }(L)) {
        _ = function (m) {
          var _;
          for (var C = Object.keys(m), R = {}, L = 0; L < C.length; L++) {
            var B = C[L];
            if (typeof m[B] == "function") {
              R[B] = m[B];
            }
          }
          var F = Object.keys(R);
          try {
            (function (m) {
              Object.keys(m).forEach(function (_) {
                var C = m[_];
                if (C(undefined, {
                  type: ec.INIT
                }) === undefined) {
                  throw Error(formatProdErrorMessage(12));
                }
                if (C(undefined, {
                  type: ec.PROBE_UNKNOWN_ACTION()
                }) === undefined) {
                  throw Error(formatProdErrorMessage(13));
                }
              });
            })(R);
          } catch (m) {
            _ = m;
          }
          return function (m = {}, C) {
            if (_) {
              throw _;
            }
            var L = false;
            var B = {};
            for (var U = 0; U < F.length; U++) {
              var H = F[U];
              var q = R[H];
              var V = m[H];
              var X = q(V, C);
              if (X === undefined) {
                if (C) {
                  C.type;
                }
                throw Error(formatProdErrorMessage(14));
              }
              B[H] = X;
              L = L || X !== V;
            }
            if (L = L || F.length !== Object.keys(m).length) {
              return B;
            } else {
              return m;
            }
          };
        }(L);
      } else {
        throw Error("\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
      }
      var Y = F;
      if (typeof Y == "function") {
        Y = Y(curriedGetDefaultMiddleware);
      }
      var Q = applyMiddleware.apply(undefined, Y);
      var et = compose;
      if (H) {
        et = ey(__spreadValues({
          trace: false
        }, typeof H == "object" && H));
      }
      var er = new ev(Q);
      var en = er;
      if (Array.isArray(K)) {
        en = __spreadArray([Q], K);
      } else if (typeof K == "function") {
        en = K(er);
      }
      return function createStore(m, _, C) {
        if (typeof _ == "function" && typeof C == "function" || typeof C == "function" && typeof arguments[3] == "function") {
          throw Error(formatProdErrorMessage(0));
        }
        if (typeof _ == "function" && C === undefined) {
          C = _;
          _ = undefined;
        }
        if (C !== undefined) {
          if (typeof C != "function") {
            throw Error(formatProdErrorMessage(1));
          }
          return C(createStore)(m, _);
        }
        if (typeof m != "function") {
          throw Error(formatProdErrorMessage(2));
        }
        var R;
        var L = m;
        var B = _;
        var F = [];
        var U = F;
        var H = false;
        function ensureCanMutateNextListeners() {
          if (U === F) {
            U = F.slice();
          }
        }
        function getState() {
          if (H) {
            throw Error(formatProdErrorMessage(3));
          }
          return B;
        }
        function subscribe(m) {
          if (typeof m != "function") {
            throw Error(formatProdErrorMessage(4));
          }
          if (H) {
            throw Error(formatProdErrorMessage(5));
          }
          var _ = true;
          ensureCanMutateNextListeners();
          U.push(m);
          return function () {
            if (_) {
              if (H) {
                throw Error(formatProdErrorMessage(6));
              }
              _ = false;
              ensureCanMutateNextListeners();
              var C = U.indexOf(m);
              U.splice(C, 1);
              F = null;
            }
          };
        }
        function dispatch(m) {
          if (!function (m) {
            if (typeof m != "object" || m === null) {
              return false;
            }
            for (var _ = m; Object.getPrototypeOf(_) !== null;) {
              _ = Object.getPrototypeOf(_);
            }
            return Object.getPrototypeOf(m) === _;
          }(m)) {
            throw Error(formatProdErrorMessage(7));
          }
          if (m.type === undefined) {
            throw Error(formatProdErrorMessage(8));
          }
          if (H) {
            throw Error(formatProdErrorMessage(9));
          }
          try {
            H = true;
            B = L(B, m);
          } finally {
            H = false;
          }
          for (var _ = F = U, C = 0; C < _.length; C++) {
            (0, _[C])();
          }
          return m;
        }
        dispatch({
          type: ec.INIT
        });
        (R = {
          dispatch: dispatch,
          subscribe: subscribe,
          getState: getState,
          replaceReducer: function (m) {
            if (typeof m != "function") {
              throw Error(formatProdErrorMessage(10));
            }
            L = m;
            dispatch({
              type: ec.REPLACE
            });
          }
        })[es] = function () {
          var m;
          (m = {
            subscribe: function (m) {
              if (typeof m != "object" || m === null) {
                throw Error(formatProdErrorMessage(11));
              }
              function observeState() {
                if (m.next) {
                  m.next(getState());
                }
              }
              observeState();
              return {
                unsubscribe: subscribe(observeState)
              };
            }
          })[es] = function () {
            return this;
          };
          return m;
        };
        return R;
      }(_, V, et.apply(undefined, en));
    }({
      reducer: {
        auth: function () {
          var m;
          let R = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eI;
          let L = arguments.length > 1 ? arguments[1] : undefined;
          let {
            type: B,
            payload: F,
            shouldSendEvent: U
          } = L;
          if (B.startsWith("SHOW_PROFILE_")) {
            return {
              ...R,
              showProfileModal: true,
              profileModalUserId: parseInt(B.substring(13))
            };
          }
          if (B.startsWith("SHOW_ACCEPT_TRADE_")) {
            return {
              ...R,
              factoredTradeModal: {
                visible: true,
                tradeId: parseInt(B.substring(18))
              }
            };
          }
          switch (B) {
            case ew.wl:
              return {
                ...R,
                factoredTradeModal: {
                  visible: false,
                  tradeId: null
                }
              };
            case ew.eB:
              return {
                ...R,
                lastSessionRefresh: Date.now()
              };
            case ew.BU:
              return {
                ...R,
                fflags: F
              };
            case ew.vH:
              return {
                ...R,
                showGiveawayModal: false
              };
            case ew.vx:
              return {
                ...R,
                showProfileModal: false
              };
            case ew.lC:
              return {
                ...R,
                showLoginModal: false
              };
            case ew.QU:
              return {
                ...R,
                ipAddress: F
              };
            case ew.IP:
              return {
                ...R,
                showGiveawayModal: true
              };
            case ew.Mr:
              if (U) {
                R.fflags.fe_posthog_enabled;
                if (R.fflags.fe_ga_enabled) {
                  eE.ZP.event({
                    action: "DEPOSIT_MODAL_OPENED",
                    category: "Auth"
                  });
                }
                if (R.fflags.fe_mixpanel_enabled) {
                  ex.Z.track("DEPOSIT_MODAL_OPENED");
                }
              }
              return {
                ...R,
                showDeposit: true
              };
            case ew.xf:
              return {
                ...R,
                showDeposit: false
              };
            case ew.PB:
              return {
                ...R,
                showAgeVerifyModal: {
                  visible: true,
                  forced: true
                },
                showDeposit: false
              };
            case ew.Gu:
              return {
                ...R,
                showAgeVerifyModal: true,
                showDeposit: false
              };
            case ew.mT:
              return {
                ...R,
                showAgeVerifyModal: false
              };
            case ew.DQ:
              return {
                ...R,
                showRentionModal: true,
                showDeposit: false
              };
            case ew.Zm:
              return {
                ...R,
                showRentionModal: false
              };
            case ew.Lp:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "CRYPTO_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("CRYPTO_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showSellixDeposit: true,
                showDeposit: false
              };
            case ew.$H:
              return {
                ...R,
                showCryptoDeposit: true,
                showDeposit: false
              };
            case ew.nX:
              return {
                ...R,
                showCryptoDeposit: false
              };
            case ew.RP:
              return {
                ...R,
                showPaygardenDeposit: true,
                showDeposit: false
              };
            case ew.vO:
              return {
                ...R,
                showPaygardenDeposit: false
              };
            case ew.OS:
              return {
                ...R,
                showSwappedDeposit: true,
                showDeposit: false
              };
            case ew.cp:
              return {
                ...R,
                showSwappedDeposit: false
              };
            case ew.lp:
              return {
                ...R,
                showFreeCaseModal: true
              };
            case ew.eg:
              return {
                ...R,
                showFreeCaseModal: false
              };
            case ew.jQ:
              return {
                ...R,
                showHowUFoundUs: true
              };
            case ew.Nf:
              return {
                ...R,
                showHowUFoundUs: false
              };
            case ew.GJ:
              return {
                ...R,
                showSellixDeposit: false
              };
            case ew.LT:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "GIFTCARD_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("GIFTCARD_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showGiftcardDeposit: true,
                showDeposit: false
              };
            case ew.jg:
              return {
                ...R,
                showGiftcardDeposit: false
              };
            case ew.vB:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "ITEMS_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("ITEMS_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showItemsDeposit: true,
                showDeposit: false
              };
            case ew.Z8:
              return {
                ...R,
                showItemsDeposit: false
              };
            case ew.hH:
              return {
                ...R,
                showItemsSemiDeposit: true,
                showDeposit: false
              };
            case ew.R_:
              return {
                ...R,
                showItemsSemiDeposit: false
              };
            case ew.Bb:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "BLOXLAND_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("BLOXLAND_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showLandDeposit: true,
                showDeposit: false
              };
            case ew.By:
              return {
                ...R,
                showLandDeposit: false
              };
            case ew.jT:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "PROMOCODE_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("PROMOCODE_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showPromoDeposit: true,
                showDeposit: false
              };
            case ew.Nq:
              return {
                ...R,
                showPromoDeposit: false
              };
            case ew.NW:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "SOCIAL_MEDIA_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("SOCIAL_MEDIA_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showSocialMediaDeposit: true,
                showDeposit: false
              };
            case ew.Rj:
              return {
                ...R,
                showSocialMediaDeposit: false
              };
            case ew.Q$:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "ROBUX_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("ROBUX_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showRobuxDeposit: true,
                showDeposit: false
              };
            case ew.mI:
              return {
                ...R,
                showRobuxWithdraw: true,
                showWithdraw: false
              };
            case ew.Tk:
              return {
                ...R,
                showRobuxDeposit: false
              };
            case ew.n4:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "CHAT_RULES_MODAL_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("CHAT_RULES_MODAL_OPENED");
              }
              return {
                ...R,
                showChatRules: true
              };
            case ew.G:
              return {
                ...R,
                showChatRules: false
              };
            case ew.bY:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "FAQ_MODAL_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("FAQ_MODAL_OPENED");
              }
              return {
                ...R,
                showFaq: true
              };
            case ew.we:
              return {
                ...R,
                showFaq: false
              };
            case ew.Lw:
              return {
                ...R,
                showConfirmLogout: true
              };
            case ew._x:
              return {
                ...R,
                showConfirmLogout: false
              };
            case ew.bN:
              return {
                ...R,
                showHistoryModal: {
                  show: true,
                  gameType: F.gameType,
                  historyData: F.historyData
                }
              };
            case ew.XA:
              return {
                ...R,
                showHistoryModal: {
                  show: false,
                  historyData: null
                }
              };
            case ew.BG:
              return {
                ...R,
                showRobuxWithdraw: false
              };
            case ew.gr:
              return {
                ...R,
                showLoginModal: true
              };
            case ew.OT:
              return {
                ...R,
                showMarketplaceModal: true
              };
            case ew.ER:
              R.fflags.fe_posthog_enabled;
              if (R.fflags.fe_ga_enabled) {
                eE.ZP.event({
                  action: "CREDIT_CARD_DEPOSIT_OPENED",
                  category: "Auth"
                });
              }
              if (R.fflags.fe_mixpanel_enabled) {
                ex.Z.track("CREDIT_CARD_DEPOSIT_OPENED");
              }
              return {
                ...R,
                showDeposit: false,
                showCardsModal: true
              };
            case ew.Ph:
              return {
                ...R,
                showMarketplaceModal: false
              };
            case ew.i8:
              return {
                ...R,
                showWithdraw: true
              };
            case ew.xm:
              return {
                ...R,
                showWithdraw: false
              };
            case ew.Fv:
              return {
                ...R,
                showCardsModal: false
              };
            case ew.Dz:
              return {
                ...R,
                showTwoFactor: true
              };
            case ew.qq:
              return {
                ...R,
                geoBlock: true
              };
            case ew.PT:
              return {
                ...R,
                showTwoFactor: false
              };
            case ew.U6:
              return {
                ...R,
                showProvablyConfig: true
              };
            case ew.Kv:
              return {
                ...R,
                showProvablyConfig: false
              };
            case ew.LE:
              return {
                ...R,
                showProvably: {
                  show: true,
                  provablyData: F
                }
              };
            case ew._z:
              return {
                ...R,
                showProvably: {
                  show: false,
                  provablyData: null
                }
              };
            case ew.hj:
              return {
                ...R,
                showInfo: {
                  show: true,
                  infoFor: F
                }
              };
            case ew.AF:
              return {
                ...R,
                showInfo: {
                  show: false,
                  infoFor: null
                }
              };
            case ew.ow:
              return {
                ...R,
                showMuteModal: {
                  show: true,
                  message: F
                }
              };
            case ew.SM:
              return {
                ...R,
                showMuteModal: {
                  show: false,
                  message: null
                }
              };
            case ew.FW:
              return {
                ...R,
                showDeleteModal: {
                  show: true,
                  message: F
                }
              };
            case ew.CP:
              return {
                ...R,
                showDeleteModal: {
                  show: false,
                  message: null
                }
              };
            case ew.t_:
              return {
                ...R,
                showTipModal: {
                  show: true,
                  message: F
                }
              };
            case ew.NZ:
              return {
                ...R,
                showTipModal: {
                  show: false,
                  message: null
                }
              };
            case ew.Cy:
              try {
                if ((m = window.$crisp) !== null && m !== undefined) {
                  m.push(["set", "user:nickname", [F.user.robloxUsername]]);
                }
              } catch (m) {
                console.error(m);
              }
              return {
                ...R,
                isAuthenticated: true,
                isLoading: false,
                user: F.user
              };
            case ew.Sb:
              return {
                ...R,
                race: F
              };
            case ew.xe:
              return {
                ...R,
                isAuthenticated: false,
                isLoading: true
              };
            case ew.Uk:
              return {
                ...R,
                user: {
                  ...R.user,
                  wallet: parseFloat((0, ek.Z)(R.user.wallet + F)),
                  wager: F < 0 ? R.user.wager + Math.abs(F) : R.user.wager
                }
              };
            case ew.XP:
              localStorage.setItem("_DO_NOT_SHARE_BLOXFLIP_TOKEN", F.token);
              return {
                ...R,
                ...F,
                isAuthenticated: true,
                isLoading: true
              };
            case ew.Qj:
            case ew.Nv:
              localStorage.removeItem("_DO_NOT_SHARE_BLOXFLIP_TOKEN");
              ex.Z.reset();
              eE.ZP.reset();
              return {
                ...R,
                token: null,
                isAuthenticated: false,
                affiliate: null,
                isLoading: false
              };
            case ew.Ny:
              return {
                ...R,
                token: null,
                isAuthenticated: false,
                isLoading: false
              };
            case ew.KV:
              return {
                ...R,
                affiliate: F
              };
            case ew.NS:
              return {
                ...R,
                autoBetPlinko: F
              };
            case ew.eH:
              return {
                ...R,
                autoBetTower: F
              };
            case ew.jf:
              return {
                ...R,
                autoBetMine: F
              };
            case ew.c9:
              return {
                ...R,
                bjTable: F ? {
                  ...R.bjTable,
                  ...F
                } : F ?? null
              };
            case ew.C_:
              return {
                ...R,
                bjTables: F || (F ?? null)
              };
            case ew.$w:
              return {
                ...R,
                bjDecisions: F ? {
                  ...R.bjDecisions,
                  ...F
                } : F ?? null
              };
            case ew.gQ:
              return {
                ...R,
                user: Object.assign({}, R.user ?? {}, R.user ? {
                  privacyEnabled: F
                } : {})
              };
            case ew.Mc:
              return {
                ...R,
                wherefromcard: F
              };
            case ew.Yk:
              return {
                ...R,
                cbGame: F ? {
                  ...(R.cbGame || {}),
                  ...F
                } : F ?? null
              };
            case ew.bO:
              return {
                ...R,
                firstLoaded: F
              };
            case ew.fd:
              return {
                ...R,
                analyticsId2: F
              };
            case ew.Sh:
              return {
                ...R,
                discounts: F ? {
                  ...(R.discounts ?? {}),
                  ...F
                } : F
              };
            case ew.n9:
              return {
                ...R,
                gameIds: F
              };
            default:
              return R;
          }
        }
      },
      middleware: eO
    });
    var eM = eC;
  },
  6428: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z: function () {
        return useWindowSize;
      }
    });
    var R = C(67294);
    function useWindowSize() {
      let [m, _] = (0, R.useState)({
        width: 0,
        height: 0
      });
      function handleResize() {
        _({
          width: window.innerWidth,
          height: window.innerHeight
        });
      }
      (0, R.useEffect)(() => {
        window.addEventListener("resize", handleResize);
        handleResize();
        return () => {
          window.removeEventListener("resize", handleResize);
        };
      }, []);
      return m;
    }
  },
  53215: function (m, _, C) {
    "use strict";

    let R;
    let L;
    let B;
    let F;
    let U;
    let H;
    let q;
    let V;
    let X;
    let K;
    let Y;
    let Q;
    let et;
    let er;
    let en;
    let ei;
    let eo;
    let ea;
    let es;
    var ec;
    var el;
    var eu;
    var ed;
    var ep;
    var eh;
    var ef;
    var em;
    var eg;
    var ey = C(42990);
    function applySdkMetadata(m, _, C = [_], R = "npm") {
      let L = m._metadata || {};
      L.sdk ||= {
        name: `sentry.javascript.${_}`,
        packages: C.map(m => ({
          name: `${R}:@sentry/${m}`,
          version: ey.J
        })),
        version: ey.J
      };
      m._metadata = L;
    }
    var e_ = C(39424);
    var ev = C(41001);
    var eb = C(41982);
    var eS = C(89163);
    var ew = C(94223);
    let eE = [];
    function afterSetupIntegrations(m, _) {
      for (let C of _) {
        if (C && C.afterAllSetup) {
          C.afterAllSetup(m);
        }
      }
    }
    function setupIntegration(m, _, C) {
      if (C[_.name]) {
        if (ew.X) {
          ev.kg.log(`Integration skipped because it was already installed: ${_.name}`);
        }
        return;
      }
      C[_.name] = _;
      if (eE.indexOf(_.name) === -1 && typeof _.setupOnce == "function") {
        _.setupOnce();
        eE.push(_.name);
      }
      if (_.setup && typeof _.setup == "function") {
        _.setup(m);
      }
      if (typeof _.preprocessEvent == "function") {
        let C = _.preprocessEvent.bind(_);
        m.on("preprocessEvent", (_, R) => C(_, R, m));
      }
      if (typeof _.processEvent == "function") {
        let C = _.processEvent.bind(_);
        let R = Object.assign((_, R) => C(_, R, m), {
          id: _.name
        });
        m.addEventProcessor(R);
      }
      if (ew.X) {
        ev.kg.log(`Integration installed: ${_.name}`);
      }
    }
    let ek = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", "can't redefine non-configurable property \"solana\"", "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"];
    let inboundFiltersIntegration = (m = {}) => ({
      name: "InboundFilters",
      processEvent(_, C, R) {
        var L;
        let B = R.getOptions();
        let F = function (m = {}, _ = {}) {
          return {
            allowUrls: [...(m.allowUrls || []), ...(_.allowUrls || [])],
            denyUrls: [...(m.denyUrls || []), ...(_.denyUrls || [])],
            ignoreErrors: [...(m.ignoreErrors || []), ...(_.ignoreErrors || []), ...(m.disableErrorDefaults ? [] : ek)],
            ignoreTransactions: [...(m.ignoreTransactions || []), ...(_.ignoreTransactions || [])],
            ignoreInternal: m.ignoreInternal === undefined || m.ignoreInternal
          };
        }(m, B);
        if (F.ignoreInternal && function (m) {
          try {
            return m.exception.values[0].type === "SentryError";
          } catch (m) {}
          return false;
        }(_) ? (ew.X && ev.kg.warn(`Event dropped due to being internal Sentry Error.
Event: ${(0, eb.jH)(_)}`), 0) : (L = F.ignoreErrors, !_.type && L && L.length && function (m) {
          let _;
          let C = [];
          if (m.message) {
            C.push(m.message);
          }
          try {
            _ = m.exception.values[m.exception.values.length - 1];
          } catch (m) {}
          if (_ && _.value) {
            C.push(_.value);
            if (_.type) {
              C.push(`${_.type}: ${_.value}`);
            }
          }
          return C;
        }(_).some(m => (0, eS.U0)(m, L))) ? (ew.X && ev.kg.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${(0, eb.jH)(_)}`), 0) : _.type || !_.exception || !_.exception.values || _.exception.values.length === 0 || _.message || _.exception.values.some(m => m.stacktrace || m.type && m.type !== "Error" || m.value) ? !function (m, _) {
          if (m.type !== "transaction" || !_ || !_.length) {
            return false;
          }
          let C = m.transaction;
          return !!C && (0, eS.U0)(C, _);
        }(_, F.ignoreTransactions) ? !function (m, _) {
          if (!_ || !_.length) {
            return false;
          }
          let C = _getEventFilterUrl(m);
          return !!C && (0, eS.U0)(C, _);
        }(_, F.denyUrls) ? function (m, _) {
          if (!_ || !_.length) {
            return true;
          }
          let C = _getEventFilterUrl(m);
          return !C || (0, eS.U0)(C, _);
        }(_, F.allowUrls) || (ew.X && ev.kg.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${(0, eb.jH)(_)}.
Url: ${_getEventFilterUrl(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${(0, eb.jH)(_)}.
Url: ${_getEventFilterUrl(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${(0, eb.jH)(_)}`), 0) : (ew.X && ev.kg.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${(0, eb.jH)(_)}`), 0)) {
          return _;
        } else {
          return null;
        }
      }
    });
    function _getEventFilterUrl(m) {
      try {
        let _;
        try {
          _ = m.exception.values[0].stacktrace.frames;
        } catch (m) {}
        if (_) {
          return function (m = []) {
            for (let _ = m.length - 1; _ >= 0; _--) {
              let C = m[_];
              if (C && C.filename !== "<anonymous>" && C.filename !== "[native code]") {
                return C.filename || null;
              }
            }
            return null;
          }(_);
        } else {
          return null;
        }
      } catch (_) {
        if (ew.X) {
          ev.kg.error(`Cannot extract url for event ${(0, eb.jH)(m)}`);
        }
        return null;
      }
    }
    var ex = C(27179);
    var eI = C(73076);
    let eO = new WeakMap();
    let functionToStringIntegration = () => ({
      name: "FunctionToString",
      setupOnce() {
        R = Function.prototype.toString;
        try {
          Function.prototype.toString = function (...m) {
            let _ = (0, ex.HK)(this);
            let C = eO.has((0, eI.s3)()) && _ !== undefined ? _ : this;
            return R.apply(C, m);
          };
        } catch (m) {}
      },
      setup(m) {
        eO.set(m, true);
      }
    });
    var eC = C(42283);
    let dedupeIntegration = () => {
      let m;
      return {
        name: "Dedupe",
        processEvent(_) {
          if (_.type) {
            return _;
          }
          try {
            var C;
            if ((C = m) && (function (m, _) {
              let C = m.message;
              let R = _.message;
              return (!!C || !!R) && (!C || !!R) && (!!C || !R) && C === R && !!_isSameFingerprint(m, _) && !!_isSameStacktrace(m, _);
            }(_, C) || function (m, _) {
              let C = _getExceptionFromEvent(_);
              let R = _getExceptionFromEvent(m);
              return !!C && !!R && C.type === R.type && C.value === R.value && !!_isSameFingerprint(m, _) && !!_isSameStacktrace(m, _);
            }(_, C))) {
              if (ew.X) {
                ev.kg.warn("Event dropped due to being a duplicate of previously captured event.");
              }
              return null;
            }
          } catch (m) {}
          return m = _;
        }
      };
    };
    function _isSameStacktrace(m, _) {
      let C = (0, eC.Fr)(m);
      let R = (0, eC.Fr)(_);
      if (!C && !R) {
        return true;
      }
      if (C && !R || !C && R || R.length !== C.length) {
        return false;
      }
      for (let m = 0; m < R.length; m++) {
        let _ = R[m];
        let L = C[m];
        if (_.filename !== L.filename || _.lineno !== L.lineno || _.colno !== L.colno || _.function !== L.function) {
          return false;
        }
      }
      return true;
    }
    function _isSameFingerprint(m, _) {
      let C = m.fingerprint;
      let R = _.fingerprint;
      if (!C && !R) {
        return true;
      }
      if (C && !R || !C && R) {
        return false;
      }
      try {
        return C.join("") === R.join("");
      } catch (m) {
        return false;
      }
    }
    function _getExceptionFromEvent(m) {
      return m.exception && m.exception.values && m.exception.values[0];
    }
    var eM = C(1525);
    var eT = C(29531);
    let eA = eT.GLOBAL_OBJ;
    function isNativeFunction(m) {
      return m && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(m.toString());
    }
    let eR = {};
    let eP = {};
    function addHandler(m, _) {
      eR[m] = eR[m] || [];
      eR[m].push(_);
    }
    function maybeInstrument(m, _) {
      if (!eP[m]) {
        _();
        eP[m] = true;
      }
    }
    function triggerHandlers(m, _) {
      let C = m && eR[m];
      if (C) {
        for (let R of C) {
          try {
            R(_);
          } catch (_) {
            if (eM.X) {
              ev.kg.error(`Error while triggering instrumentation handler.
Type: ${m}
Name: ${(0, eC.$P)(R)}
Error:`, _);
            }
          }
        }
      }
    }
    let eD = eT.GLOBAL_OBJ;
    let eL = eT.GLOBAL_OBJ;
    function addHistoryInstrumentationHandler(m) {
      let _ = "history";
      addHandler(_, m);
      maybeInstrument(_, instrumentHistory);
    }
    function instrumentHistory() {
      if (!function () {
        let m = eD.chrome;
        let _ = m && m.app && m.app.runtime;
        let C = "history" in eD && !!eD.history.pushState && !!eD.history.replaceState;
        return !_ && C;
      }()) {
        return;
      }
      let m = eL.onpopstate;
      function historyReplacementFunction(m) {
        return function (..._) {
          let C = _.length > 2 ? _[2] : undefined;
          if (C) {
            let m = L;
            let _ = String(C);
            L = _;
            triggerHandlers("history", {
              from: m,
              to: _
            });
          }
          return m.apply(this, _);
        };
      }
      eL.onpopstate = function (..._) {
        let C = eL.location.href;
        let R = L;
        L = C;
        triggerHandlers("history", {
          from: R,
          to: C
        });
        if (m) {
          try {
            return m.apply(this, _);
          } catch (m) {}
        }
      };
      (0, ex.hl)(eL.history, "pushState", historyReplacementFunction);
      (0, ex.hl)(eL.history, "replaceState", historyReplacementFunction);
    }
    var eN = C(73326);
    var eB = C(16824);
    var ej = C(80128);
    var eF = C(39432);
    let SentryError = class SentryError extends Error {
      constructor(m, _ = "warn") {
        super(m);
        this.message = m;
        this.name = new.target.prototype.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
        this.logLevel = _;
      }
    };
    var eU = C(26181);
    var eH = C(11793);
    var eW = C(10042);
    var e$ = C(72123);
    var eq = C(79769);
    var eG = C(5808);
    let ez = "Not capturing exception because it's already been captured.";
    let BaseClient = class BaseClient {
      constructor(m) {
        this._options = m;
        this._integrations = {};
        this._numProcessing = 0;
        this._outcomes = {};
        this._hooks = {};
        this._eventProcessors = [];
        if (m.dsn) {
          this._dsn = (0, eN.vK)(m.dsn);
        } else if (ew.X) {
          ev.kg.warn("No DSN provided, client will not send events.");
        }
        if (this._dsn) {
          var _;
          var C;
          var R;
          _ = this._dsn;
          C = m.tunnel;
          R = m._metadata ? m._metadata.sdk : undefined;
          let L = C || `${function (m) {
            let _ = m.protocol ? `${m.protocol}:` : "";
            let C = m.port ? `:${m.port}` : "";
            return `${_}//${m.host}${C}${m.path ? `/${m.path}` : ""}/api/`;
          }(_)}${_.projectId}/envelope/?${(0, ex._j)({
            sentry_key: _.publicKey,
            sentry_version: "7",
            ...(R && {
              sentry_client: `${R.name}/${R.version}`
            })
          })}`;
          this._transport = m.transport({
            tunnel: this._options.tunnel,
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...m.transportOptions,
            url: L
          });
        }
      }
      captureException(m, _, C) {
        let R = (0, eb.DM)();
        if ((0, eb.YO)(m)) {
          if (ew.X) {
            ev.kg.log(ez);
          }
          return R;
        }
        let L = {
          event_id: R,
          ..._
        };
        this._process(this.eventFromException(m, L).then(m => this._captureEvent(m, L, C)));
        return L.event_id;
      }
      captureMessage(m, _, C, R) {
        let L = {
          event_id: (0, eb.DM)(),
          ...C
        };
        let B = (0, eB.Le)(m) ? m : String(m);
        let F = (0, eB.pt)(m) ? this.eventFromMessage(B, _, L) : this.eventFromException(m, L);
        this._process(F.then(m => this._captureEvent(m, L, R)));
        return L.event_id;
      }
      captureEvent(m, _, C) {
        let R = (0, eb.DM)();
        if (_ && _.originalException && (0, eb.YO)(_.originalException)) {
          if (ew.X) {
            ev.kg.log(ez);
          }
          return R;
        }
        let L = {
          event_id: R,
          ..._
        };
        let B = m.sdkProcessingMetadata || {};
        let F = B.capturedSpanScope;
        this._process(this._captureEvent(m, L, F || C));
        return L.event_id;
      }
      captureSession(m) {
        if (typeof m.release != "string") {
          if (ew.X) {
            ev.kg.warn("Discarded session because of missing or non-string release");
          }
        } else {
          this.sendSession(m);
          (0, eW.CT)(m, {
            init: false
          });
        }
      }
      getDsn() {
        return this._dsn;
      }
      getOptions() {
        return this._options;
      }
      getSdkMetadata() {
        return this._options._metadata;
      }
      getTransport() {
        return this._transport;
      }
      flush(m) {
        let _ = this._transport;
        if (_) {
          this.emit("flush");
          return this._isClientDoneProcessing(m).then(C => _.flush(m).then(m => C && m));
        } else {
          return (0, ej.WD)(true);
        }
      }
      close(m) {
        return this.flush(m).then(m => {
          this.getOptions().enabled = false;
          this.emit("close");
          return m;
        });
      }
      getEventProcessors() {
        return this._eventProcessors;
      }
      addEventProcessor(m) {
        this._eventProcessors.push(m);
      }
      init() {
        if (this._isEnabled() || this._options.integrations.some(({
          name: m
        }) => m.startsWith("Spotlight"))) {
          this._setupIntegrations();
        }
      }
      getIntegrationByName(m) {
        return this._integrations[m];
      }
      addIntegration(m) {
        let _ = this._integrations[m.name];
        setupIntegration(this, m, this._integrations);
        if (!_) {
          afterSetupIntegrations(this, [m]);
        }
      }
      sendEvent(m, _ = {}) {
        this.emit("beforeSendEvent", m, _);
        let C = (0, eH.Mq)(m, this._dsn, this._options._metadata, this._options.tunnel);
        for (let m of _.attachments || []) {
          C = (0, eF.BO)(C, (0, eF.zQ)(m));
        }
        let R = this.sendEnvelope(C);
        if (R) {
          R.then(_ => this.emit("afterSendEvent", m, _), null);
        }
      }
      sendSession(m) {
        let _ = (0, eH.Q3)(m, this._dsn, this._options._metadata, this._options.tunnel);
        this.sendEnvelope(_);
      }
      recordDroppedEvent(m, _, C) {
        if (this._options.sendClientReports) {
          let R = typeof C == "number" ? C : 1;
          let L = `${m}:${_}`;
          if (ew.X) {
            ev.kg.log(`Recording outcome: "${L}"${R > 1 ? ` (${R} times)` : ""}`);
          }
          this._outcomes[L] = (this._outcomes[L] || 0) + R;
        }
      }
      on(m, _) {
        let C = this._hooks[m] = this._hooks[m] || [];
        C.push(_);
        return () => {
          let m = C.indexOf(_);
          if (m > -1) {
            C.splice(m, 1);
          }
        };
      }
      emit(m, ..._) {
        let C = this._hooks[m];
        if (C) {
          C.forEach(m => m(..._));
        }
      }
      sendEnvelope(m) {
        this.emit("beforeEnvelope", m);
        if (this._isEnabled() && this._transport) {
          return this._transport.send(m).then(null, m => {
            if (ew.X) {
              ev.kg.error("Error while sending event:", m);
            }
            return m;
          });
        } else {
          if (ew.X) {
            ev.kg.error("Transport disabled");
          }
          return (0, ej.WD)({});
        }
      }
      _setupIntegrations() {
        let {
          integrations: m
        } = this._options;
        this._integrations = function (m, _) {
          let C = {};
          _.forEach(_ => {
            if (_) {
              setupIntegration(m, _, C);
            }
          });
          return C;
        }(this, m);
        afterSetupIntegrations(this, m);
      }
      _updateSessionFromEvent(m, _) {
        let C = false;
        let R = false;
        let L = _.exception && _.exception.values;
        if (L) {
          R = true;
          for (let m of L) {
            let _ = m.mechanism;
            if (_ && _.handled === false) {
              C = true;
              break;
            }
          }
        }
        let B = m.status === "ok";
        let F = B && m.errors === 0 || B && C;
        if (F) {
          (0, eW.CT)(m, {
            ...(C && {
              status: "crashed"
            }),
            errors: m.errors || Number(R || C)
          });
          this.captureSession(m);
        }
      }
      _isClientDoneProcessing(m) {
        return new ej.cW(_ => {
          let C = 0;
          let R = setInterval(() => {
            if (this._numProcessing == 0) {
              clearInterval(R);
              _(true);
            } else {
              C += 1;
              if (m && C >= m) {
                clearInterval(R);
                _(false);
              }
            }
          }, 1);
        });
      }
      _isEnabled() {
        return this.getOptions().enabled !== false && this._transport !== undefined;
      }
      _prepareEvent(m, _, C, R = (0, eI.aF)()) {
        let L = this.getOptions();
        let B = Object.keys(this._integrations);
        if (!_.integrations && B.length > 0) {
          _.integrations = B;
        }
        this.emit("preprocessEvent", m, _);
        if (!m.type) {
          R.setLastEventId(m.event_id || _.event_id);
        }
        return (0, eG.R)(L, m, _, C, this, R).then(m => {
          if (m === null) {
            return m;
          }
          let _ = {
            ...R.getPropagationContext(),
            ...(C ? C.getPropagationContext() : undefined)
          };
          let L = m.contexts && m.contexts.trace;
          if (!L && _) {
            let {
              traceId: C,
              spanId: R,
              parentSpanId: L,
              dsc: B
            } = _;
            m.contexts = {
              trace: (0, ex.Jr)({
                trace_id: C,
                span_id: R,
                parent_span_id: L
              }),
              ...m.contexts
            };
            let F = B || (0, e$._l)(C, this);
            m.sdkProcessingMetadata = {
              dynamicSamplingContext: F,
              ...m.sdkProcessingMetadata
            };
          }
          return m;
        });
      }
      _captureEvent(m, _ = {}, C) {
        return this._processEvent(m, _, C).then(m => m.event_id, m => {
          if (ew.X) {
            if (m.logLevel === "log") {
              ev.kg.log(m.message);
            } else {
              ev.kg.warn(m);
            }
          }
        });
      }
      _processEvent(m, _, C) {
        let R = this.getOptions();
        let {
          sampleRate: L
        } = R;
        let B = isTransactionEvent(m);
        let F = isErrorEvent(m);
        let U = m.type || "error";
        let H = `before send for type \`${U}\``;
        let q = L === undefined ? undefined : (0, eq.o)(L);
        if (F && typeof q == "number" && Math.random() > q) {
          this.recordDroppedEvent("sample_rate", "error", m);
          return (0, ej.$2)(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${L})`, "log"));
        }
        let V = U === "replay_event" ? "replay" : U;
        let X = m.sdkProcessingMetadata || {};
        let K = X.capturedSpanIsolationScope;
        return this._prepareEvent(m, _, C, K).then(C => {
          if (C === null) {
            this.recordDroppedEvent("event_processor", V, m);
            throw new SentryError("An event processor returned `null`, will not send event.", "log");
          }
          let L = _.data && _.data.__sentry__ === true;
          if (L) {
            return C;
          }
          let B = function (m, _, C, R) {
            let {
              beforeSend: L,
              beforeSendTransaction: B,
              beforeSendSpan: F
            } = _;
            if (isErrorEvent(C) && L) {
              return L(C, R);
            }
            if (isTransactionEvent(C)) {
              if (C.spans && F) {
                let _ = [];
                for (let R of C.spans) {
                  let C = F(R);
                  if (C) {
                    _.push(C);
                  } else {
                    m.recordDroppedEvent("before_send", "span");
                  }
                }
                C.spans = _;
              }
              if (B) {
                if (C.spans) {
                  let m = C.spans.length;
                  C.sdkProcessingMetadata = {
                    ...C.sdkProcessingMetadata,
                    spanCountBeforeProcessing: m
                  };
                }
                return B(C, R);
              }
            }
            return C;
          }(this, R, C, _);
          return function (m, _) {
            let C = `${_} must return \`null\` or a valid event.`;
            if ((0, eB.J8)(m)) {
              return m.then(m => {
                if (!(0, eB.PO)(m) && m !== null) {
                  throw new SentryError(C);
                }
                return m;
              }, m => {
                throw new SentryError(`${_} rejected with ${m}`);
              });
            }
            if (!(0, eB.PO)(m) && m !== null) {
              throw new SentryError(C);
            }
            return m;
          }(B, H);
        }).then(R => {
          if (R === null) {
            this.recordDroppedEvent("before_send", V, m);
            if (B) {
              let _ = m.spans || [];
              let C = 1 + _.length;
              this.recordDroppedEvent("before_send", "span", C);
            }
            throw new SentryError(`${H} returned \`null\`, will not send event.`, "log");
          }
          let L = C && C.getSession();
          if (!B && L) {
            this._updateSessionFromEvent(L, R);
          }
          if (B) {
            let m = R.sdkProcessingMetadata && R.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
            let _ = R.spans ? R.spans.length : 0;
            let C = m - _;
            if (C > 0) {
              this.recordDroppedEvent("before_send", "span", C);
            }
          }
          let F = R.transaction_info;
          if (B && F && R.transaction !== m.transaction) {
            R.transaction_info = {
              ...F,
              source: "custom"
            };
          }
          this.sendEvent(R, _);
          return R;
        }).then(null, m => {
          if (m instanceof SentryError) {
            throw m;
          }
          this.captureException(m, {
            data: {
              __sentry__: true
            },
            originalException: m
          });
          throw new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${m}`);
        });
      }
      _process(m) {
        this._numProcessing++;
        m.then(m => {
          this._numProcessing--;
          return m;
        }, m => {
          this._numProcessing--;
          return m;
        });
      }
      _clearOutcomes() {
        let m = this._outcomes;
        this._outcomes = {};
        return Object.entries(m).map(([m, _]) => {
          let [C, R] = m.split(":");
          return {
            reason: C,
            category: R,
            quantity: _
          };
        });
      }
      _flushOutcomes() {
        if (ew.X) {
          ev.kg.log("Flushing outcomes...");
        }
        let m = this._clearOutcomes();
        if (m.length === 0) {
          if (ew.X) {
            ev.kg.log("No outcomes to send");
          }
          return;
        }
        if (!this._dsn) {
          if (ew.X) {
            ev.kg.log("No dsn provided, will not send outcomes");
          }
          return;
        }
        if (ew.X) {
          ev.kg.log("Sending outcomes:", m);
        }
        let _ = function (m, _, C) {
          let R = [{
            type: "client_report"
          }, {
            timestamp: (0, eU.yW)(),
            discarded_events: m
          }];
          return (0, eF.Jd)(_ ? {
            dsn: _
          } : {}, [R]);
        }(m, this._options.tunnel && (0, eN.RA)(this._dsn));
        this.sendEnvelope(_);
      }
    };
    function isErrorEvent(m) {
      return m.type === undefined;
    }
    function isTransactionEvent(m) {
      return m.type === "transaction";
    }
    var eV = C(83408);
    function exceptionFromError(m, _) {
      let C = parseStackFrames(m, _);
      let R = {
        type: function (m) {
          let _ = m && m.name;
          if (!_ && isWebAssemblyException(m)) {
            let _ = m.message && Array.isArray(m.message) && m.message.length == 2;
            if (_) {
              return m.message[0];
            } else {
              return "WebAssembly.Exception";
            }
          }
          return _;
        }(_),
        value: function (m) {
          let _ = m && m.message;
          if (_) {
            if (_.error && typeof _.error.message == "string") {
              return _.error.message;
            } else if (isWebAssemblyException(m) && Array.isArray(m.message) && m.message.length == 2) {
              return m.message[1];
            } else {
              return _;
            }
          } else {
            return "No error message";
          }
        }(_)
      };
      if (C.length) {
        R.stacktrace = {
          frames: C
        };
      }
      if (R.type === undefined && R.value === "") {
        R.value = "Unrecoverable error caught";
      }
      return R;
    }
    function eventFromError(m, _) {
      return {
        exception: {
          values: [exceptionFromError(m, _)]
        }
      };
    }
    function parseStackFrames(m, _) {
      let C = _.stacktrace || _.stack || "";
      let R = _ && eJ.test(_.message) ? 1 : 0;
      let L = typeof _.framesToPop == "number" ? _.framesToPop : 0;
      try {
        return m(C, R, L);
      } catch (m) {}
      return [];
    }
    let eJ = /Minified React error #\d+;/i;
    function isWebAssemblyException(m) {
      return typeof WebAssembly != "undefined" && WebAssembly.Exception !== undefined && m instanceof WebAssembly.Exception;
    }
    function eventFromUnknownInput(m, _, C, R, L) {
      let B;
      if ((0, eB.VW)(_) && _.error) {
        return eventFromError(m, _.error);
      }
      if ((0, eB.TX)(_) || (0, eB.fm)(_)) {
        if ("stack" in _) {
          B = eventFromError(m, _);
        } else {
          let L = _.name || ((0, eB.TX)(_) ? "DOMError" : "DOMException");
          let F = _.message ? `${L}: ${_.message}` : L;
          B = eventFromString(m, F, C, R);
          (0, eb.Db)(B, F);
        }
        if ("code" in _) {
          B.tags = {
            ...B.tags,
            "DOMException.code": `${_.code}`
          };
        }
        return B;
      }
      if ((0, eB.VZ)(_)) {
        return eventFromError(m, _);
      } else {
        if ((0, eB.PO)(_) || (0, eB.cO)(_)) {
          B = function (m, _, C, R) {
            let L = (0, eI.s3)();
            let B = L && L.getOptions().normalizeDepth;
            let F = function (m) {
              for (let _ in m) {
                if (Object.prototype.hasOwnProperty.call(m, _)) {
                  let C = m[_];
                  if (C instanceof Error) {
                    return C;
                  }
                }
              }
            }(_);
            let U = {
              __serialized__: (0, eV.Qy)(_, B)
            };
            if (F) {
              return {
                exception: {
                  values: [exceptionFromError(m, F)]
                },
                extra: U
              };
            }
            let H = {
              exception: {
                values: [{
                  type: (0, eB.cO)(_) ? _.constructor.name : R ? "UnhandledRejection" : "Error",
                  value: function (m, {
                    isUnhandledRejection: _
                  }) {
                    let C = (0, ex.zf)(m);
                    let R = _ ? "promise rejection" : "exception";
                    if ((0, eB.VW)(m)) {
                      return `Event \`ErrorEvent\` captured as ${R} with message \`${m.message}\``;
                    }
                    if ((0, eB.cO)(m)) {
                      let _ = function (m) {
                        try {
                          let _ = Object.getPrototypeOf(m);
                          if (_) {
                            return _.constructor.name;
                          } else {
                            return undefined;
                          }
                        } catch (m) {}
                      }(m);
                      return `Event \`${_}\` (type=${m.type}) captured as ${R}`;
                    }
                    return `Object captured as ${R} with keys: ${C}`;
                  }(_, {
                    isUnhandledRejection: R
                  })
                }]
              },
              extra: U
            };
            if (C) {
              let _ = parseStackFrames(m, C);
              if (_.length) {
                H.exception.values[0].stacktrace = {
                  frames: _
                };
              }
            }
            return H;
          }(m, _, C, L);
        } else {
          B = eventFromString(m, _, C, R);
          (0, eb.Db)(B, `${_}`, undefined);
        }
        (0, eb.EG)(B, {
          synthetic: true
        });
        return B;
      }
    }
    function eventFromString(m, _, C, R) {
      let L = {};
      if (R && C) {
        let R = parseStackFrames(m, C);
        if (R.length) {
          L.exception = {
            values: [{
              value: _,
              stacktrace: {
                frames: R
              }
            }]
          };
        }
      }
      if ((0, eB.Le)(_)) {
        let {
          __sentry_template_string__: m,
          __sentry_template_values__: C
        } = _;
        L.logentry = {
          message: m,
          params: C
        };
        return L;
      }
      L.message = _;
      return L;
    }
    let eX = eT.GLOBAL_OBJ;
    let eK = 0;
    function wrap(m, _ = {}, C) {
      if (typeof m != "function") {
        return m;
      }
      try {
        let _ = m.__sentry_wrapped__;
        if (_) {
          if (typeof _ == "function") {
            return _;
          }
          return m;
        }
        if ((0, ex.HK)(m)) {
          return m;
        }
      } catch (_) {
        return m;
      }
      let sentryWrapped = function () {
        let R = Array.prototype.slice.call(arguments);
        try {
          if (C && typeof C == "function") {
            C.apply(this, arguments);
          }
          let L = R.map(m => wrap(m, _));
          return m.apply(this, L);
        } catch (m) {
          eK++;
          setTimeout(() => {
            eK--;
          });
          (0, eI.$e)(C => {
            C.addEventProcessor(m => {
              if (_.mechanism) {
                (0, eb.Db)(m, undefined, undefined);
                (0, eb.EG)(m, _.mechanism);
              }
              m.extra = {
                ...m.extra,
                arguments: R
              };
              return m;
            });
            (0, e_.Tb)(m);
          });
          throw m;
        }
      };
      try {
        for (let _ in m) {
          if (Object.prototype.hasOwnProperty.call(m, _)) {
            sentryWrapped[_] = m[_];
          }
        }
      } catch (m) {}
      (0, ex.$Q)(sentryWrapped, m);
      (0, ex.xp)(m, "__sentry_wrapped__", sentryWrapped);
      try {
        let _ = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
        if (_.configurable) {
          Object.defineProperty(sentryWrapped, "name", {
            get: () => m.name
          });
        }
      } catch (m) {}
      return sentryWrapped;
    }
    let BrowserClient = class BrowserClient extends BaseClient {
      constructor(m) {
        let _ = {
          parentSpanIsAlwaysRootSpan: true,
          ...m
        };
        let C = eX.SENTRY_SDK_SOURCE || "npm";
        applySdkMetadata(_, "browser", ["browser"], C);
        super(_);
        if (_.sendClientReports && eX.document) {
          eX.document.addEventListener("visibilitychange", () => {
            if (eX.document.visibilityState === "hidden") {
              this._flushOutcomes();
            }
          });
        }
      }
      eventFromException(m, _) {
        return function (m, _, C, R) {
          let L = C && C.syntheticException || undefined;
          let B = eventFromUnknownInput(m, _, L, R);
          (0, eb.EG)(B);
          B.level = "error";
          if (C && C.event_id) {
            B.event_id = C.event_id;
          }
          return (0, ej.WD)(B);
        }(this._options.stackParser, m, _, this._options.attachStacktrace);
      }
      eventFromMessage(m, _ = "info", C) {
        return function (m, _, C = "info", R, L) {
          let B = R && R.syntheticException || undefined;
          let F = eventFromString(m, _, B, L);
          F.level = C;
          if (R && R.event_id) {
            F.event_id = R.event_id;
          }
          return (0, ej.WD)(F);
        }(this._options.stackParser, m, _, C, this._options.attachStacktrace);
      }
      captureUserFeedback(m) {
        if (!this._isEnabled()) {
          return;
        }
        let _ = function (m, {
          metadata: _,
          tunnel: C,
          dsn: R
        }) {
          let L = {
            event_id: m.event_id,
            sent_at: new Date().toISOString(),
            ...(_ && _.sdk && {
              sdk: {
                name: _.sdk.name,
                version: _.sdk.version
              }
            }),
            ...(!!C && !!R && {
              dsn: (0, eN.RA)(R)
            })
          };
          let B = [{
            type: "user_report"
          }, m];
          return (0, eF.Jd)(L, [B]);
        }(m, {
          metadata: this.getSdkMetadata(),
          dsn: this.getDsn(),
          tunnel: this.getOptions().tunnel
        });
        this.sendEnvelope(_);
      }
      _prepareEvent(m, _, C) {
        m.platform = m.platform || "javascript";
        return super._prepareEvent(m, _, C);
      }
    };
    function addClickKeypressInstrumentationHandler(m) {
      addHandler("dom", m);
      maybeInstrument("dom", instrumentDOM);
    }
    function instrumentDOM() {
      if (!eL.document) {
        return;
      }
      let m = triggerHandlers.bind(null, "dom");
      let _ = makeDOMEventHandler(m, true);
      eL.document.addEventListener("click", _, false);
      eL.document.addEventListener("keypress", _, false);
      ["EventTarget", "Node"].forEach(_ => {
        let C = eL[_] && eL[_].prototype;
        if (C && C.hasOwnProperty && C.hasOwnProperty("addEventListener")) {
          (0, ex.hl)(C, "addEventListener", function (_) {
            return function (C, R, L) {
              if (C === "click" || C == "keypress") {
                try {
                  let R = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {};
                  let B = R[C] = R[C] || {
                    refCount: 0
                  };
                  if (!B.handler) {
                    let R = makeDOMEventHandler(m);
                    B.handler = R;
                    _.call(this, C, R, L);
                  }
                  B.refCount++;
                } catch (m) {}
              }
              return _.call(this, C, R, L);
            };
          });
          (0, ex.hl)(C, "removeEventListener", function (m) {
            return function (_, C, R) {
              if (_ === "click" || _ == "keypress") {
                try {
                  let C = this.__sentry_instrumentation_handlers__ || {};
                  let L = C[_];
                  if (L) {
                    L.refCount--;
                    if (L.refCount <= 0) {
                      m.call(this, _, L.handler, R);
                      L.handler = undefined;
                      delete C[_];
                    }
                    if (Object.keys(C).length === 0) {
                      delete this.__sentry_instrumentation_handlers__;
                    }
                  }
                } catch (m) {}
              }
              return m.call(this, _, C, R);
            };
          });
        }
      });
    }
    function makeDOMEventHandler(m, _ = false) {
      return C => {
        if (!C || C._sentryCaptured) {
          return;
        }
        let R = function (m) {
          try {
            return m.target;
          } catch (m) {
            return null;
          }
        }(C);
        if (C.type === "keypress" && (!R || !R.tagName || R.tagName !== "INPUT" && R.tagName !== "TEXTAREA" && !R.isContentEditable)) {
          return;
        }
        (0, ex.xp)(C, "_sentryCaptured", true);
        if (R && !R._sentryId) {
          (0, ex.xp)(R, "_sentryId", (0, eb.DM)());
        }
        let L = C.type === "keypress" ? "input" : C.type;
        if (!function (m) {
          if (m.type !== F) {
            return false;
          }
          try {
            if (!m.target || m.target._sentryId !== U) {
              return false;
            }
          } catch (m) {}
          return true;
        }(C)) {
          m({
            event: C,
            name: L,
            global: _
          });
          F = C.type;
          U = R ? R._sentryId : undefined;
        }
        clearTimeout(B);
        B = eL.setTimeout(() => {
          U = undefined;
          F = undefined;
        }, 1000);
      };
    }
    let eZ = "__sentry_xhr_v3__";
    function addXhrInstrumentationHandler(m) {
      addHandler("xhr", m);
      maybeInstrument("xhr", instrumentXHR);
    }
    function instrumentXHR() {
      if (!eL.XMLHttpRequest) {
        return;
      }
      let m = XMLHttpRequest.prototype;
      m.open = new Proxy(m.open, {
        apply(m, _, C) {
          let R = (0, eU.ph)() * 1000;
          let L = (0, eB.HD)(C[0]) ? C[0].toUpperCase() : undefined;
          let B = function (m) {
            if ((0, eB.HD)(m)) {
              return m;
            }
            try {
              return m.toString();
            } catch (m) {}
          }(C[1]);
          if (!L || !B) {
            return m.apply(_, C);
          }
          _[eZ] = {
            method: L,
            url: B,
            request_headers: {}
          };
          if (L === "POST" && B.match(/sentry_key/)) {
            _.__sentry_own_request__ = true;
          }
          let onreadystatechangeHandler = () => {
            let m = _[eZ];
            if (m && _.readyState === 4) {
              try {
                m.status_code = _.status;
              } catch (m) {}
              let C = {
                endTimestamp: (0, eU.ph)() * 1000,
                startTimestamp: R,
                xhr: _
              };
              triggerHandlers("xhr", C);
            }
          };
          if ("onreadystatechange" in _ && typeof _.onreadystatechange == "function") {
            _.onreadystatechange = new Proxy(_.onreadystatechange, {
              apply: (m, _, C) => {
                onreadystatechangeHandler();
                return m.apply(_, C);
              }
            });
          } else {
            _.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          _.setRequestHeader = new Proxy(_.setRequestHeader, {
            apply(m, _, C) {
              let [R, L] = C;
              let B = _[eZ];
              if (B && (0, eB.HD)(R) && (0, eB.HD)(L)) {
                B.request_headers[R.toLowerCase()] = L;
              }
              return m.apply(_, C);
            }
          });
          return m.apply(_, C);
        }
      });
      m.send = new Proxy(m.send, {
        apply(m, _, C) {
          let R = _[eZ];
          if (!R) {
            return m.apply(_, C);
          }
          if (C[0] !== undefined) {
            R.body = C[0];
          }
          let L = {
            startTimestamp: (0, eU.ph)() * 1000,
            xhr: _
          };
          triggerHandlers("xhr", L);
          return m.apply(_, C);
        }
      });
    }
    function addBreadcrumb(m, _) {
      let C = (0, eI.s3)();
      let R = (0, eI.aF)();
      if (!C) {
        return;
      }
      let {
        beforeBreadcrumb: L = null,
        maxBreadcrumbs: B = 100
      } = C.getOptions();
      if (B <= 0) {
        return;
      }
      let F = (0, eU.yW)();
      let U = {
        timestamp: F,
        ...m
      };
      let H = L ? (0, ev.Cf)(() => L(U, _)) : U;
      if (H !== null) {
        if (C.emit) {
          C.emit("beforeAddBreadcrumb", H, _);
        }
        R.addBreadcrumb(H, B);
      }
    }
    function instrumentConsole() {
      if ("console" in eT.GLOBAL_OBJ) {
        ev.RU.forEach(function (m) {
          if (m in eT.GLOBAL_OBJ.console) {
            (0, ex.hl)(eT.GLOBAL_OBJ.console, m, function (_) {
              ev.LD[m] = _;
              return function (..._) {
                triggerHandlers("console", {
                  args: _,
                  level: m
                });
                let C = ev.LD[m];
                if (C) {
                  C.apply(eT.GLOBAL_OBJ.console, _);
                }
              };
            });
          }
        });
      }
    }
    function addFetchInstrumentationHandler(m, _) {
      let C = "fetch";
      addHandler(C, m);
      maybeInstrument(C, () => instrumentFetch(undefined, _));
    }
    function instrumentFetch(m, _ = false) {
      if (!_ || function () {
        if (typeof EdgeRuntime == "string") {
          return true;
        }
        if (!function () {
          if (!("fetch" in eA)) {
            return false;
          }
          try {
            new Headers();
            new Request("http://www.example.com");
            new Response();
            return true;
          } catch (m) {
            return false;
          }
        }()) {
          return false;
        }
        if (isNativeFunction(eA.fetch)) {
          return true;
        }
        let m = false;
        let _ = eA.document;
        if (_ && typeof _.createElement == "function") {
          try {
            let C = _.createElement("iframe");
            C.hidden = true;
            _.head.appendChild(C);
            if (C.contentWindow && C.contentWindow.fetch) {
              m = isNativeFunction(C.contentWindow.fetch);
            }
            _.head.removeChild(C);
          } catch (m) {
            if (eM.X) {
              ev.kg.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", m);
            }
          }
        }
        return m;
      }()) {
        (0, ex.hl)(eT.GLOBAL_OBJ, "fetch", function (_) {
          return function (...C) {
            let {
              method: R,
              url: L
            } = function (m) {
              if (m.length === 0) {
                return {
                  method: "GET",
                  url: ""
                };
              }
              if (m.length === 2) {
                let [_, C] = m;
                return {
                  url: getUrlFromResource(_),
                  method: hasProp(C, "method") ? String(C.method).toUpperCase() : "GET"
                };
              }
              let _ = m[0];
              return {
                url: getUrlFromResource(_),
                method: hasProp(_, "method") ? String(_.method).toUpperCase() : "GET"
              };
            }(C);
            let B = {
              args: C,
              fetchData: {
                method: R,
                url: L
              },
              startTimestamp: (0, eU.ph)() * 1000
            };
            if (!m) {
              triggerHandlers("fetch", {
                ...B
              });
            }
            let F = Error().stack;
            return _.apply(eT.GLOBAL_OBJ, C).then(async _ => {
              if (m) {
                m(_);
              } else {
                triggerHandlers("fetch", {
                  ...B,
                  endTimestamp: (0, eU.ph)() * 1000,
                  response: _
                });
              }
              return _;
            }, m => {
              triggerHandlers("fetch", {
                ...B,
                endTimestamp: (0, eU.ph)() * 1000,
                error: m
              });
              if ((0, eB.VZ)(m) && m.stack === undefined) {
                m.stack = F;
                (0, ex.xp)(m, "framesToPop", 1);
              }
              throw m;
            });
          };
        });
      }
    }
    async function resolveResponse(m, _) {
      if (m && m.body) {
        let C = m.body;
        let R = C.getReader();
        let L = setTimeout(() => {
          C.cancel().then(null, () => {});
        }, 90000);
        let B = true;
        while (B) {
          let m;
          try {
            m = setTimeout(() => {
              C.cancel().then(null, () => {});
            }, 5000);
            let {
              done: L
            } = await R.read();
            clearTimeout(m);
            if (L) {
              _();
              B = false;
            }
          } catch (m) {
            B = false;
          } finally {
            clearTimeout(m);
          }
        }
        clearTimeout(L);
        R.releaseLock();
        C.cancel().then(null, () => {});
      }
    }
    function streamHandler(m) {
      let _;
      try {
        _ = m.clone();
      } catch (m) {
        return;
      }
      resolveResponse(_, () => {
        triggerHandlers("fetch-body-resolved", {
          endTimestamp: (0, eU.ph)() * 1000,
          response: m
        });
      });
    }
    function hasProp(m, _) {
      return !!m && typeof m == "object" && !!m[_];
    }
    function getUrlFromResource(m) {
      if (typeof m == "string") {
        return m;
      } else if (m) {
        if (hasProp(m, "url")) {
          return m.url;
        } else if (m.toString) {
          return m.toString();
        } else {
          return "";
        }
      } else {
        return "";
      }
    }
    var eY = C(1869);
    let eQ = ["fatal", "error", "warning", "log", "info", "debug"];
    function getBreadcrumbLogLevelFromHttpStatusCode(m) {
      if (m !== undefined) {
        if (m >= 400 && m < 500) {
          return "warning";
        } else if (m >= 500) {
          return "error";
        } else {
          return undefined;
        }
      }
    }
    function url_parseUrl(m) {
      if (!m) {
        return {};
      }
      let _ = m.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!_) {
        return {};
      }
      let C = _[6] || "";
      let R = _[8] || "";
      return {
        host: _[4],
        path: _[5],
        protocol: _[2],
        search: C,
        hash: R,
        relative: _[5] + C + R
      };
    }
    let breadcrumbsIntegration = (m = {}) => {
      let _ = {
        console: true,
        dom: true,
        fetch: true,
        history: true,
        sentry: true,
        xhr: true,
        ...m
      };
      return {
        name: "Breadcrumbs",
        setup(m) {
          var C;
          if (_.console) {
            (function (m) {
              let _ = "console";
              addHandler(_, m);
              maybeInstrument(_, instrumentConsole);
            })(function (_) {
              var C;
              if ((0, eI.s3)() !== m) {
                return;
              }
              let R = {
                category: "console",
                data: {
                  arguments: _.args,
                  logger: "console"
                },
                level: (C = _.level) === "warn" ? "warning" : eQ.includes(C) ? C : "log",
                message: (0, eS.nK)(_.args, " ")
              };
              if (_.level === "assert") {
                if (_.args[0] !== false) {
                  return;
                }
                R.message = `Assertion failed: ${(0, eS.nK)(_.args.slice(1), " ") || "console.assert"}`;
                R.data.arguments = _.args.slice(1);
              }
              addBreadcrumb(R, {
                input: _.args,
                level: _.level
              });
            });
          }
          if (_.dom) {
            addClickKeypressInstrumentationHandler((C = _.dom, function (_) {
              let R;
              let L;
              if ((0, eI.s3)() !== m) {
                return;
              }
              let B = typeof C == "object" ? C.serializeAttribute : undefined;
              let F = typeof C == "object" && typeof C.maxStringLength == "number" ? C.maxStringLength : undefined;
              if (F && F > 1024) {
                F = 1024;
              }
              if (typeof B == "string") {
                B = [B];
              }
              try {
                let m = _.event;
                let C = m && m.target ? m.target : m;
                R = (0, eY.Rt)(C, {
                  keyAttrs: B,
                  maxStringLength: F
                });
                L = (0, eY.iY)(C);
              } catch (m) {
                R = "<unknown>";
              }
              if (R.length === 0) {
                return;
              }
              let U = {
                category: `ui.${_.name}`,
                message: R
              };
              if (L) {
                U.data = {
                  "ui.component_name": L
                };
              }
              addBreadcrumb(U, {
                event: _.event,
                name: _.name,
                global: _.global
              });
            }));
          }
          if (_.xhr) {
            addXhrInstrumentationHandler(function (_) {
              if ((0, eI.s3)() !== m) {
                return;
              }
              let {
                startTimestamp: C,
                endTimestamp: R
              } = _;
              let L = _.xhr[eZ];
              if (!C || !R || !L) {
                return;
              }
              let {
                method: B,
                url: F,
                status_code: U,
                body: H
              } = L;
              let q = {
                xhr: _.xhr,
                input: H,
                startTimestamp: C,
                endTimestamp: R
              };
              let V = getBreadcrumbLogLevelFromHttpStatusCode(U);
              addBreadcrumb({
                category: "xhr",
                data: {
                  method: B,
                  url: F,
                  status_code: U
                },
                type: "http",
                level: V
              }, q);
            });
          }
          if (_.fetch) {
            addFetchInstrumentationHandler(function (_) {
              if ((0, eI.s3)() !== m) {
                return;
              }
              let {
                startTimestamp: C,
                endTimestamp: R
              } = _;
              if (!!R && (!_.fetchData.url.match(/sentry_key/) || _.fetchData.method !== "POST")) {
                if (_.error) {
                  let m = _.fetchData;
                  let L = {
                    data: _.error,
                    input: _.args,
                    startTimestamp: C,
                    endTimestamp: R
                  };
                  addBreadcrumb({
                    category: "fetch",
                    data: m,
                    level: "error",
                    type: "http"
                  }, L);
                } else {
                  let m = _.response;
                  let L = {
                    ..._.fetchData,
                    status_code: m && m.status
                  };
                  let B = {
                    input: _.args,
                    response: m,
                    startTimestamp: C,
                    endTimestamp: R
                  };
                  let F = getBreadcrumbLogLevelFromHttpStatusCode(L.status_code);
                  addBreadcrumb({
                    category: "fetch",
                    data: L,
                    type: "http",
                    level: F
                  }, B);
                }
              }
            });
          }
          if (_.history) {
            addHistoryInstrumentationHandler(function (_) {
              if ((0, eI.s3)() !== m) {
                return;
              }
              let C = _.from;
              let R = _.to;
              let L = url_parseUrl(eX.location.href);
              let B = C ? url_parseUrl(C) : undefined;
              let F = url_parseUrl(R);
              if (!B || !B.path) {
                B = L;
              }
              if (L.protocol === F.protocol && L.host === F.host) {
                R = F.relative;
              }
              if (L.protocol === B.protocol && L.host === B.host) {
                C = B.relative;
              }
              addBreadcrumb({
                category: "navigation",
                data: {
                  from: C,
                  to: R
                }
              });
            });
          }
          if (_.sentry) {
            m.on("beforeSendEvent", function (_) {
              if ((0, eI.s3)() === m) {
                addBreadcrumb({
                  category: `sentry.${_.type === "transaction" ? "transaction" : "event"}`,
                  event_id: _.event_id,
                  level: _.level,
                  message: (0, eb.jH)(_)
                }, {
                  event: _
                });
              }
            });
          }
        }
      };
    };
    let e0 = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
    let browserApiErrorsIntegration = (m = {}) => {
      let _ = {
        XMLHttpRequest: true,
        eventTarget: true,
        requestAnimationFrame: true,
        setInterval: true,
        setTimeout: true,
        ...m
      };
      return {
        name: "BrowserApiErrors",
        setupOnce() {
          if (_.setTimeout) {
            (0, ex.hl)(eX, "setTimeout", _wrapTimeFunction);
          }
          if (_.setInterval) {
            (0, ex.hl)(eX, "setInterval", _wrapTimeFunction);
          }
          if (_.requestAnimationFrame) {
            (0, ex.hl)(eX, "requestAnimationFrame", _wrapRAF);
          }
          if (_.XMLHttpRequest && "XMLHttpRequest" in eX) {
            (0, ex.hl)(XMLHttpRequest.prototype, "send", _wrapXHR);
          }
          let m = _.eventTarget;
          if (m) {
            let _ = Array.isArray(m) ? m : e0;
            _.forEach(_wrapEventTarget);
          }
        }
      };
    };
    function _wrapTimeFunction(m) {
      return function (..._) {
        let C = _[0];
        _[0] = wrap(C, {
          mechanism: {
            data: {
              function: (0, eC.$P)(m)
            },
            handled: false,
            type: "instrument"
          }
        });
        return m.apply(this, _);
      };
    }
    function _wrapRAF(m) {
      return function (_) {
        return m.apply(this, [wrap(_, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: (0, eC.$P)(m)
            },
            handled: false,
            type: "instrument"
          }
        })]);
      };
    }
    function _wrapXHR(m) {
      return function (..._) {
        let C = this;
        ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(m => {
          if (m in C && typeof C[m] == "function") {
            (0, ex.hl)(C, m, function (_) {
              let C = {
                mechanism: {
                  data: {
                    function: m,
                    handler: (0, eC.$P)(_)
                  },
                  handled: false,
                  type: "instrument"
                }
              };
              let R = (0, ex.HK)(_);
              if (R) {
                C.mechanism.data.handler = (0, eC.$P)(R);
              }
              return wrap(_, C);
            });
          }
        });
        return m.apply(this, _);
      };
    }
    function _wrapEventTarget(m) {
      let _ = eX[m] && eX[m].prototype;
      if (_ && _.hasOwnProperty && _.hasOwnProperty("addEventListener")) {
        (0, ex.hl)(_, "addEventListener", function (_) {
          return function (C, R, L) {
            try {
              if (typeof R.handleEvent == "function") {
                R.handleEvent = wrap(R.handleEvent, {
                  mechanism: {
                    data: {
                      function: "handleEvent",
                      handler: (0, eC.$P)(R),
                      target: m
                    },
                    handled: false,
                    type: "instrument"
                  }
                });
              }
            } catch (m) {}
            return _.apply(this, [C, wrap(R, {
              mechanism: {
                data: {
                  function: "addEventListener",
                  handler: (0, eC.$P)(R),
                  target: m
                },
                handled: false,
                type: "instrument"
              }
            }), L]);
          };
        });
        (0, ex.hl)(_, "removeEventListener", function (m) {
          return function (_, C, R) {
            try {
              let L = C && C.__sentry_wrapped__;
              if (L) {
                m.call(this, _, L, R);
              }
            } catch (m) {}
            return m.call(this, _, C, R);
          };
        });
      }
    }
    let e1 = null;
    function addGlobalErrorInstrumentationHandler(m) {
      let _ = "error";
      addHandler(_, m);
      maybeInstrument(_, instrumentError);
    }
    function instrumentError() {
      e1 = eT.GLOBAL_OBJ.onerror;
      eT.GLOBAL_OBJ.onerror = function (m, _, C, R, L) {
        triggerHandlers("error", {
          column: R,
          error: L,
          line: C,
          msg: m,
          url: _
        });
        return !!e1 && !e1.__SENTRY_LOADER__ && e1.apply(this, arguments);
      };
      eT.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
    }
    let e2 = null;
    function addGlobalUnhandledRejectionInstrumentationHandler(m) {
      let _ = "unhandledrejection";
      addHandler(_, m);
      maybeInstrument(_, instrumentUnhandledRejection);
    }
    function instrumentUnhandledRejection() {
      e2 = eT.GLOBAL_OBJ.onunhandledrejection;
      eT.GLOBAL_OBJ.onunhandledrejection = function (m) {
        triggerHandlers("unhandledrejection", m);
        return !e2 || !!e2.__SENTRY_LOADER__ || e2.apply(this, arguments);
      };
      eT.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
    }
    let globalHandlersIntegration = (m = {}) => {
      let _ = {
        onerror: true,
        onunhandledrejection: true,
        ...m
      };
      return {
        name: "GlobalHandlers",
        setupOnce() {
          Error.stackTraceLimit = 50;
        },
        setup(m) {
          if (_.onerror) {
            addGlobalErrorInstrumentationHandler(_ => {
              let {
                stackParser: C,
                attachStacktrace: R
              } = getOptions();
              if ((0, eI.s3)() !== m || eK > 0) {
                return;
              }
              let {
                msg: L,
                url: B,
                line: F,
                column: U,
                error: H
              } = _;
              let q = function (m, _, C, R) {
                let L = m.exception = m.exception || {};
                let B = L.values = L.values || [];
                let F = B[0] = B[0] || {};
                let U = F.stacktrace = F.stacktrace || {};
                let H = U.frames = U.frames || [];
                let q = isNaN(parseInt(R, 10)) ? undefined : R;
                let V = isNaN(parseInt(C, 10)) ? undefined : C;
                let X = (0, eB.HD)(_) && _.length > 0 ? _ : (0, eY.l4)();
                if (H.length === 0) {
                  H.push({
                    colno: q,
                    filename: X,
                    function: eC.Fi,
                    in_app: true,
                    lineno: V
                  });
                }
                return m;
              }(eventFromUnknownInput(C, H || L, undefined, R, false), B, F, U);
              q.level = "error";
              (0, e_.eN)(q, {
                originalException: H,
                mechanism: {
                  handled: false,
                  type: "onerror"
                }
              });
            });
          }
          if (_.onunhandledrejection) {
            addGlobalUnhandledRejectionInstrumentationHandler(_ => {
              let {
                stackParser: C,
                attachStacktrace: R
              } = getOptions();
              if ((0, eI.s3)() !== m || eK > 0) {
                return;
              }
              let L = function (m) {
                if ((0, eB.pt)(m)) {
                  return m;
                }
                try {
                  if ("reason" in m) {
                    return m.reason;
                  }
                  if ("detail" in m && "reason" in m.detail) {
                    return m.detail.reason;
                  }
                } catch (m) {}
                return m;
              }(_);
              let B = (0, eB.pt)(L) ? {
                exception: {
                  values: [{
                    type: "UnhandledRejection",
                    value: `Non-Error promise rejection captured with value: ${String(L)}`
                  }]
                }
              } : eventFromUnknownInput(C, L, undefined, R, true);
              B.level = "error";
              (0, e_.eN)(B, {
                originalException: L,
                mechanism: {
                  handled: false,
                  type: "onunhandledrejection"
                }
              });
            });
          }
        }
      };
    };
    function getOptions() {
      let m = (0, eI.s3)();
      let _ = m && m.getOptions() || {
        stackParser: () => [],
        attachStacktrace: false
      };
      return _;
    }
    let httpContextIntegration = () => ({
      name: "HttpContext",
      preprocessEvent(m) {
        if (!eX.navigator && !eX.location && !eX.document) {
          return;
        }
        let _ = m.request && m.request.url || eX.location && eX.location.href;
        let {
          referrer: C
        } = eX.document || {};
        let {
          userAgent: R
        } = eX.navigator || {};
        let L = {
          ...(m.request && m.request.headers),
          ...(C && {
            Referer: C
          }),
          ...(R && {
            "User-Agent": R
          })
        };
        let B = {
          ...m.request,
          ...(_ && {
            url: _
          }),
          headers: L
        };
        m.request = B;
      }
    });
    function applyExceptionGroupFieldsForParentException(m, _) {
      m.mechanism = m.mechanism || {
        type: "generic",
        handled: true
      };
      m.mechanism = {
        ...m.mechanism,
        ...(m.type === "AggregateError" && {
          is_exception_group: true
        }),
        exception_id: _
      };
    }
    function applyExceptionGroupFieldsForChildException(m, _, C, R) {
      m.mechanism = m.mechanism || {
        type: "generic",
        handled: true
      };
      m.mechanism = {
        ...m.mechanism,
        type: "chained",
        source: _,
        exception_id: C,
        parent_id: R
      };
    }
    let linkedErrorsIntegration = (m = {}) => {
      let _ = m.limit || 5;
      let C = m.key || "cause";
      return {
        name: "LinkedErrors",
        preprocessEvent(m, R, L) {
          let B = L.getOptions();
          (function (m, _, C = 250, R, L, B, F) {
            if (!B.exception || !B.exception.values || !F || !(0, eB.V9)(F.originalException, Error)) {
              return;
            }
            let U = B.exception.values.length > 0 ? B.exception.values[B.exception.values.length - 1] : undefined;
            if (U) {
              B.exception.values = function aggregateExceptionsFromError(m, _, C, R, L, B, F, U) {
                if (B.length >= C + 1) {
                  return B;
                }
                let H = [...B];
                if ((0, eB.V9)(R[L], Error)) {
                  applyExceptionGroupFieldsForParentException(F, U);
                  let B = m(_, R[L]);
                  let q = H.length;
                  applyExceptionGroupFieldsForChildException(B, L, q, U);
                  H = aggregateExceptionsFromError(m, _, C, R[L], L, [B, ...H], B, q);
                }
                if (Array.isArray(R.errors)) {
                  R.errors.forEach((R, B) => {
                    if ((0, eB.V9)(R, Error)) {
                      applyExceptionGroupFieldsForParentException(F, U);
                      let q = m(_, R);
                      let V = H.length;
                      applyExceptionGroupFieldsForChildException(q, `errors[${B}]`, V, U);
                      H = aggregateExceptionsFromError(m, _, C, R, L, [q, ...H], q, V);
                    }
                  });
                }
                return H;
              }(m, _, L, F.originalException, R, B.exception.values, U, 0).map(m => {
                m.value &&= (0, eS.$G)(m.value, C);
                return m;
              });
            }
          })(exceptionFromError, B.stackParser, B.maxValueLength, C, _, m, R);
        }
      };
    };
    function createFrame(m, _, C, R) {
      let L = {
        filename: m,
        function: _ === "<anonymous>" ? eC.Fi : _,
        in_app: true
      };
      if (C !== undefined) {
        L.lineno = C;
      }
      if (R !== undefined) {
        L.colno = R;
      }
      return L;
    }
    let e3 = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
    let e5 = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    let e6 = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    let e4 = [30, m => {
      let _ = e3.exec(m);
      if (_) {
        let [, m, C, R] = _;
        return createFrame(m, eC.Fi, +C, +R);
      }
      let C = e5.exec(m);
      if (C) {
        let m = C[2] && C[2].indexOf("eval") === 0;
        if (m) {
          let m = e6.exec(C[2]);
          if (m) {
            C[2] = m[1];
            C[3] = m[2];
            C[4] = m[3];
          }
        }
        let [_, R] = extractSafariExtensionDetails(C[1] || eC.Fi, C[2]);
        return createFrame(R, _, C[3] ? +C[3] : undefined, C[4] ? +C[4] : undefined);
      }
    }];
    let e8 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    let e9 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    let e7 = [50, m => {
      let _ = e8.exec(m);
      if (_) {
        let m = _[3] && _[3].indexOf(" > eval") > -1;
        if (m) {
          let m = e9.exec(_[3]);
          if (m) {
            _[1] = _[1] || "eval";
            _[3] = m[1];
            _[4] = m[2];
            _[5] = "";
          }
        }
        let C = _[3];
        let R = _[1] || eC.Fi;
        [R, C] = extractSafariExtensionDetails(R, C);
        return createFrame(C, R, _[4] ? +_[4] : undefined, _[5] ? +_[5] : undefined);
      }
    }];
    let te = (0, eC.pE)(...[e4, e7]);
    let extractSafariExtensionDetails = (m, _) => {
      let C = m.indexOf("safari-extension") !== -1;
      let R = m.indexOf("safari-web-extension") !== -1;
      if (C || R) {
        return [m.indexOf("@") !== -1 ? m.split("@")[0] : eC.Fi, C ? `safari-extension:${_}` : `safari-web-extension:${_}`];
      } else {
        return [m, _];
      }
    };
    let tt = {};
    function getNativeImplementation(m) {
      let _ = tt[m];
      if (_) {
        return _;
      }
      let C = eL[m];
      if (isNativeFunction(C)) {
        return tt[m] = C.bind(eL);
      }
      let R = eL.document;
      if (R && typeof R.createElement == "function") {
        try {
          let _ = R.createElement("iframe");
          _.hidden = true;
          R.head.appendChild(_);
          let L = _.contentWindow;
          if (L && L[m]) {
            C = L[m];
          }
          R.head.removeChild(_);
        } catch (m) {}
      }
      if (C) {
        return tt[m] = C.bind(eL);
      } else {
        return C;
      }
    }
    function getNativeImplementation_setTimeout(...m) {
      return getNativeImplementation("setTimeout")(...m);
    }
    function isRateLimited(m, _, C = Date.now()) {
      return (m[_] || m.all || 0) > C;
    }
    function updateRateLimits(m, {
      statusCode: _,
      headers: C
    }, R = Date.now()) {
      let L = {
        ...m
      };
      let B = C && C["x-sentry-rate-limits"];
      let F = C && C["retry-after"];
      if (B) {
        for (let m of B.trim().split(",")) {
          let [_, C,,, B] = m.split(":", 5);
          let F = parseInt(_, 10);
          let U = (isNaN(F) ? 60 : F) * 1000;
          if (C) {
            for (let m of C.split(";")) {
              if (m === "metric_bucket") {
                if (!B || B.split(";").includes("custom")) {
                  L[m] = R + U;
                }
              } else {
                L[m] = R + U;
              }
            }
          } else {
            L.all = R + U;
          }
        }
      } else if (F) {
        L.all = R + function (m, _ = Date.now()) {
          let C = parseInt(`${m}`, 10);
          if (!isNaN(C)) {
            return C * 1000;
          }
          let R = Date.parse(`${m}`);
          if (isNaN(R)) {
            return 60000;
          } else {
            return R - _;
          }
        }(F, R);
      } else if (_ === 429) {
        L.all = R + 60000;
      }
      return L;
    }
    function getEventForEnvelopeItem(m, _) {
      if (_ === "event" || _ === "transaction") {
        if (Array.isArray(m)) {
          return m[1];
        } else {
          return undefined;
        }
      }
    }
    function makeFetchTransport(m, _ = getNativeImplementation("fetch")) {
      let C = 0;
      let R = 0;
      return function (m, _, C = function (m) {
        let _ = [];
        function remove(m) {
          return _.splice(_.indexOf(m), 1)[0] || Promise.resolve(undefined);
        }
        return {
          $: _,
          add: function (C) {
            if (m !== undefined && !(_.length < m)) {
              return (0, ej.$2)(new SentryError("Not adding Promise because buffer limit was reached."));
            }
            let R = C();
            if (_.indexOf(R) === -1) {
              _.push(R);
            }
            R.then(() => remove(R)).then(null, () => remove(R).then(null, () => {}));
            return R;
          },
          drain: function (m) {
            return new ej.cW((C, R) => {
              let L = _.length;
              if (!L) {
                return C(true);
              }
              let B = setTimeout(() => {
                if (m && m > 0) {
                  C(false);
                }
              }, m);
              _.forEach(m => {
                (0, ej.WD)(m).then(() => {
                  if (! --L) {
                    clearTimeout(B);
                    C(true);
                  }
                }, R);
              });
            });
          }
        };
      }(m.bufferSize || 64)) {
        let R = {};
        return {
          send: function (L) {
            let B = [];
            (0, eF.gv)(L, (_, C) => {
              let L = (0, eF.mL)(C);
              if (isRateLimited(R, L)) {
                let R = getEventForEnvelopeItem(_, C);
                m.recordDroppedEvent("ratelimit_backoff", L, R);
              } else {
                B.push(_);
              }
            });
            if (B.length === 0) {
              return (0, ej.WD)({});
            }
            let F = (0, eF.Jd)(L[0], B);
            let recordEnvelopeLoss = _ => {
              (0, eF.gv)(F, (C, R) => {
                let L = getEventForEnvelopeItem(C, R);
                m.recordDroppedEvent(_, (0, eF.mL)(R), L);
              });
            };
            return C.add(() => _({
              body: (0, eF.V$)(F)
            }).then(m => {
              if (m.statusCode !== undefined && (m.statusCode < 200 || m.statusCode >= 300) && ew.X) {
                ev.kg.warn(`Sentry responded with status code ${m.statusCode} to sent event.`);
              }
              R = updateRateLimits(R, m);
              return m;
            }, m => {
              recordEnvelopeLoss("network_error");
              throw m;
            })).then(m => m, m => {
              if (m instanceof SentryError) {
                if (ew.X) {
                  ev.kg.error("Skipped sending event because buffer is full.");
                }
                recordEnvelopeLoss("queue_overflow");
                return (0, ej.WD)({});
              }
              throw m;
            });
          },
          flush: m => C.drain(m)
        };
      }(m, function (L) {
        let B = L.body.length;
        C += B;
        R++;
        let F = {
          body: L.body,
          method: "POST",
          referrerPolicy: "origin",
          headers: m.headers,
          keepalive: C <= 60000 && R < 15,
          ...m.fetchOptions
        };
        if (!_) {
          tt.fetch = undefined;
          return (0, ej.$2)("No fetch implementation available");
        }
        try {
          return _(m.url, F).then(m => {
            C -= B;
            R--;
            return {
              statusCode: m.status,
              headers: {
                "x-sentry-rate-limits": m.headers.get("X-Sentry-Rate-Limits"),
                "retry-after": m.headers.get("Retry-After")
              }
            };
          });
        } catch (m) {
          tt.fetch = undefined;
          C -= B;
          R--;
          return (0, ej.$2)(m);
        }
      });
    }
    function getDefaultIntegrations(m) {
      return [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()];
    }
    var tr = C(67294);
    var tn = C(34155);
    var ti = C(81585);
    var to = C(99450);
    var ta = C(31218);
    var ts = C(72441);
    function _optionalChain(m) {
      let _;
      let C = m[0];
      let R = 1;
      while (R < m.length) {
        let L = m[R];
        let B = m[R + 1];
        R += 2;
        if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
          return;
        }
        if (L === "access" || L === "optionalAccess") {
          _ = C;
          C = B(C);
        } else if (L === "call" || L === "optionalCall") {
          C = B((...m) => C.call(_, ...m));
          _ = undefined;
        }
      }
      return C;
    }
    let getRating = (m, _) => m > _[1] ? "poor" : m > _[0] ? "needs-improvement" : "good";
    let bindReporter = (m, _, C, R) => {
      let L;
      let B;
      return F => {
        if (_.value >= 0 && (F || R) && ((B = _.value - (L || 0)) || L === undefined)) {
          L = _.value;
          _.delta = B;
          _.rating = getRating(_.value, C);
          m(_);
        }
      };
    };
    let generateUniqueID = () => `v3-${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1000000000000}`;
    let getNavigationEntry = () => eL.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
    let getActivationStart = () => {
      let m = getNavigationEntry();
      return m && m.activationStart || 0;
    };
    let initMetric = (m, _) => {
      let C = getNavigationEntry();
      let R = "navigate";
      if (C) {
        if (eL.document && eL.document.prerendering || getActivationStart() > 0) {
          R = "prerender";
        } else if (eL.document && eL.document.wasDiscarded) {
          R = "restore";
        } else if (C.type) {
          R = C.type.replace(/_/g, "-");
        }
      }
      return {
        name: m,
        value: _ === undefined ? -1 : _,
        rating: "good",
        delta: 0,
        entries: [],
        id: generateUniqueID(),
        navigationType: R
      };
    };
    let observe = (m, _, C) => {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(m)) {
          let R = new PerformanceObserver(m => {
            Promise.resolve().then(() => {
              _(m.getEntries());
            });
          });
          R.observe(Object.assign({
            type: m,
            buffered: true
          }, C || {}));
          return R;
        }
      } catch (m) {}
    };
    let onHidden = m => {
      let onHiddenOrPageHide = _ => {
        if (_.type === "pagehide" || eL.document && eL.document.visibilityState === "hidden") {
          m(_);
        }
      };
      if (eL.document) {
        addEventListener("visibilitychange", onHiddenOrPageHide, true);
        addEventListener("pagehide", onHiddenOrPageHide, true);
      }
    };
    let runOnce = m => {
      let _ = false;
      return C => {
        if (!_) {
          m(C);
          _ = true;
        }
      };
    };
    let tc = -1;
    let initHiddenTime = () => {
      tc = eL.document.visibilityState !== "hidden" || eL.document.prerendering ? Infinity : 0;
    };
    let onVisibilityUpdate = m => {
      if (eL.document.visibilityState === "hidden" && tc > -1) {
        tc = m.type === "visibilitychange" ? m.timeStamp : 0;
        removeEventListener("visibilitychange", onVisibilityUpdate, true);
        removeEventListener("prerenderingchange", onVisibilityUpdate, true);
      }
    };
    let addChangeListeners = () => {
      addEventListener("visibilitychange", onVisibilityUpdate, true);
      addEventListener("prerenderingchange", onVisibilityUpdate, true);
    };
    let getVisibilityWatcher = () => {
      if (eL.document && tc < 0) {
        initHiddenTime();
        addChangeListeners();
      }
      return {
        get firstHiddenTime() {
          return tc;
        }
      };
    };
    let whenActivated = m => {
      if (eL.document && eL.document.prerendering) {
        addEventListener("prerenderingchange", () => m(), true);
      } else {
        m();
      }
    };
    let tl = [1800, 3000];
    let onFCP = (m, _ = {}) => {
      whenActivated(() => {
        let C;
        let R = getVisibilityWatcher();
        let L = initMetric("FCP");
        let B = observe("paint", m => {
          m.forEach(m => {
            if (m.name === "first-contentful-paint") {
              B.disconnect();
              if (m.startTime < R.firstHiddenTime) {
                L.value = Math.max(m.startTime - getActivationStart(), 0);
                L.entries.push(m);
                C(true);
              }
            }
          });
        });
        if (B) {
          C = bindReporter(m, L, tl, _.reportAllChanges);
        }
      });
    };
    let tu = [0.1, 0.25];
    let onCLS = (m, _ = {}) => {
      onFCP(runOnce(() => {
        let C;
        let R = initMetric("CLS", 0);
        let L = 0;
        let B = [];
        let handleEntries = m => {
          m.forEach(m => {
            if (!m.hadRecentInput) {
              let _ = B[0];
              let C = B[B.length - 1];
              if (L && _ && C && m.startTime - C.startTime < 1000 && m.startTime - _.startTime < 5000) {
                L += m.value;
                B.push(m);
              } else {
                L = m.value;
                B = [m];
              }
            }
          });
          if (L > R.value) {
            R.value = L;
            R.entries = B;
            C();
          }
        };
        let F = observe("layout-shift", handleEntries);
        if (F) {
          C = bindReporter(m, R, tu, _.reportAllChanges);
          onHidden(() => {
            handleEntries(F.takeRecords());
            C(true);
          });
          setTimeout(C, 0);
        }
      }));
    };
    let td = [100, 300];
    let onFID = (m, _ = {}) => {
      whenActivated(() => {
        let C;
        let R = getVisibilityWatcher();
        let L = initMetric("FID");
        let handleEntry = m => {
          if (m.startTime < R.firstHiddenTime) {
            L.value = m.processingStart - m.startTime;
            L.entries.push(m);
            C(true);
          }
        };
        let handleEntries = m => {
          m.forEach(handleEntry);
        };
        let B = observe("first-input", handleEntries);
        C = bindReporter(m, L, td, _.reportAllChanges);
        if (B) {
          onHidden(runOnce(() => {
            handleEntries(B.takeRecords());
            B.disconnect();
          }));
        }
      });
    };
    let tp = 0;
    let th = Infinity;
    let tf = 0;
    let updateEstimate = m => {
      m.forEach(m => {
        if (m.interactionId) {
          th = Math.min(th, m.interactionId);
          tp = (tf = Math.max(tf, m.interactionId)) ? (tf - th) / 7 + 1 : 0;
        }
      });
    };
    let getInteractionCount = () => H ? tp : performance.interactionCount || 0;
    let initInteractionCountPolyfill = () => {
      if (!("interactionCount" in performance) && !H) {
        H = observe("event", updateEstimate, {
          type: "event",
          buffered: true,
          durationThreshold: 0
        });
      }
    };
    let tm = [200, 500];
    let getInteractionCountForNavigation = () => getInteractionCount() - 0;
    let tg = [];
    let ty = {};
    let processEntry = m => {
      let _ = tg[tg.length - 1];
      let C = ty[m.interactionId];
      if (C || tg.length < 10 || _ && m.duration > _.latency) {
        if (C) {
          C.entries.push(m);
          C.latency = Math.max(C.latency, m.duration);
        } else {
          let _ = {
            id: m.interactionId,
            latency: m.duration,
            entries: [m]
          };
          ty[_.id] = _;
          tg.push(_);
        }
        tg.sort((m, _) => _.latency - m.latency);
        tg.splice(10).forEach(m => {
          delete ty[m.id];
        });
      }
    };
    let estimateP98LongestInteraction = () => {
      let m = Math.min(tg.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
      return tg[m];
    };
    let onINP = (m, _ = {}) => {
      whenActivated(() => {
        let C;
        initInteractionCountPolyfill();
        let R = initMetric("INP");
        let handleEntries = m => {
          m.forEach(m => {
            if (m.interactionId) {
              processEntry(m);
            }
            if (m.entryType === "first-input") {
              let _ = !tg.some(_ => _.entries.some(_ => m.duration === _.duration && m.startTime === _.startTime));
              if (_) {
                processEntry(m);
              }
            }
          });
          let _ = estimateP98LongestInteraction();
          if (_ && _.latency !== R.value) {
            R.value = _.latency;
            R.entries = _.entries;
            C();
          }
        };
        let L = observe("event", handleEntries, {
          durationThreshold: _.durationThreshold ?? 40
        });
        C = bindReporter(m, R, tm, _.reportAllChanges);
        if (L) {
          if ("PerformanceEventTiming" in eL && "interactionId" in PerformanceEventTiming.prototype) {
            L.observe({
              type: "first-input",
              buffered: true
            });
          }
          onHidden(() => {
            handleEntries(L.takeRecords());
            if (R.value < 0 && getInteractionCountForNavigation() > 0) {
              R.value = 0;
              R.entries = [];
            }
            C(true);
          });
        }
      });
    };
    let t_ = [2500, 4000];
    let tv = {};
    let onLCP = (m, _ = {}) => {
      whenActivated(() => {
        let C;
        let R = getVisibilityWatcher();
        let L = initMetric("LCP");
        let handleEntries = m => {
          let _ = m[m.length - 1];
          if (_ && _.startTime < R.firstHiddenTime) {
            L.value = Math.max(_.startTime - getActivationStart(), 0);
            L.entries = [_];
            C();
          }
        };
        let B = observe("largest-contentful-paint", handleEntries);
        if (B) {
          C = bindReporter(m, L, t_, _.reportAllChanges);
          let R = runOnce(() => {
            if (!tv[L.id]) {
              handleEntries(B.takeRecords());
              B.disconnect();
              tv[L.id] = true;
              C(true);
            }
          });
          ["keydown", "click"].forEach(m => {
            if (eL.document) {
              addEventListener(m, () => setTimeout(R, 0), true);
            }
          });
          onHidden(R);
        }
      });
    };
    let tb = [800, 1800];
    let whenReady = m => {
      if (eL.document && eL.document.prerendering) {
        whenActivated(() => whenReady(m));
      } else if (eL.document && eL.document.readyState !== "complete") {
        addEventListener("load", () => whenReady(m), true);
      } else {
        setTimeout(m, 0);
      }
    };
    let onTTFB = (m, _ = {}) => {
      let C = initMetric("TTFB");
      let R = bindReporter(m, C, tb, _.reportAllChanges);
      whenReady(() => {
        let m = getNavigationEntry();
        if (m) {
          let _ = m.responseStart;
          if (_ <= 0 || _ > performance.now()) {
            return;
          }
          C.value = Math.max(_ - getActivationStart(), 0);
          C.entries = [m];
          R(true);
        }
      });
    };
    let tS = {};
    let tw = {};
    function addClsInstrumentationHandler(m, _ = false) {
      return addMetricObserver("cls", m, instrumentCls, q, _);
    }
    function addLcpInstrumentationHandler(m, _ = false) {
      return addMetricObserver("lcp", m, instrumentLcp, X, _);
    }
    function addFidInstrumentationHandler(m) {
      return addMetricObserver("fid", m, instrumentFid, V);
    }
    function addInpInstrumentationHandler(m) {
      return addMetricObserver("inp", m, instrumentInp, Y);
    }
    function addPerformanceInstrumentationHandler(m, _) {
      instrument_addHandler(m, _);
      if (!tw[m]) {
        (function (m) {
          let _ = {};
          if (m === "event") {
            _.durationThreshold = 0;
          }
          observe(m, _ => {
            instrument_triggerHandlers(m, {
              entries: _
            });
          }, _);
        })(m);
        tw[m] = true;
      }
      return getCleanupCallback(m, _);
    }
    function instrument_triggerHandlers(m, _) {
      let C = tS[m];
      if (C && C.length) {
        for (let m of C) {
          try {
            m(_);
          } catch (m) {}
        }
      }
    }
    function instrumentCls() {
      return onCLS(m => {
        instrument_triggerHandlers("cls", {
          metric: m
        });
        q = m;
      }, {
        reportAllChanges: true
      });
    }
    function instrumentFid() {
      return onFID(m => {
        instrument_triggerHandlers("fid", {
          metric: m
        });
        V = m;
      });
    }
    function instrumentLcp() {
      return onLCP(m => {
        instrument_triggerHandlers("lcp", {
          metric: m
        });
        X = m;
      }, {
        reportAllChanges: true
      });
    }
    function instrumentTtfb() {
      return onTTFB(m => {
        instrument_triggerHandlers("ttfb", {
          metric: m
        });
        K = m;
      });
    }
    function instrumentInp() {
      return onINP(m => {
        instrument_triggerHandlers("inp", {
          metric: m
        });
        Y = m;
      });
    }
    function addMetricObserver(m, _, C, R, L = false) {
      let B;
      instrument_addHandler(m, _);
      if (!tw[m]) {
        B = C();
        tw[m] = true;
      }
      if (R) {
        _({
          metric: R
        });
      }
      return getCleanupCallback(m, _, L ? B : undefined);
    }
    function instrument_addHandler(m, _) {
      tS[m] = tS[m] || [];
      tS[m].push(_);
    }
    function getCleanupCallback(m, _, C) {
      return () => {
        if (C) {
          C();
        }
        let R = tS[m];
        if (!R) {
          return;
        }
        let L = R.indexOf(_);
        if (L !== -1) {
          R.splice(L, 1);
        }
      };
    }
    function isMeasurementValue(m) {
      return typeof m == "number" && isFinite(m);
    }
    function startAndEndSpan(m, _, C, {
      ...R
    }) {
      let L = (0, ti.XU)(m).start_timestamp;
      if (L && L > _ && typeof m.updateStartTime == "function") {
        m.updateStartTime(_);
      }
      return (0, to._d)(m, () => {
        let m = (0, to.qp)({
          startTime: _,
          ...R
        });
        if (m) {
          m.end(C);
        }
        return m;
      });
    }
    function startStandaloneWebVitalSpan(m) {
      let _;
      let C = (0, eI.s3)();
      if (!C) {
        return;
      }
      let {
        name: R,
        transaction: L,
        attributes: B,
        startTime: F
      } = m;
      let {
        release: U,
        environment: H
      } = C.getOptions();
      let q = C.getIntegrationByName("Replay");
      let V = q && q.getReplayId();
      let X = (0, eI.nZ)();
      let K = X.getUser();
      let Y = K !== undefined ? K.email || K.id || K.ip_address : undefined;
      try {
        _ = X.getScopeData().contexts.profile.profile_id;
      } catch (m) {}
      let Q = {
        release: U,
        environment: H,
        user: Y || undefined,
        profile_id: _ || undefined,
        replay_id: V || undefined,
        transaction: L,
        "user_agent.original": eL.navigator && eL.navigator.userAgent,
        ...B
      };
      return (0, to.qp)({
        name: R,
        attributes: Q,
        startTime: F,
        experimental: {
          standalone: true
        }
      });
    }
    function getBrowserPerformanceAPI() {
      return eL && eL.addEventListener && eL.performance;
    }
    function msToSec(m) {
      return m / 1000;
    }
    let tE = 0;
    let tk = {};
    function _addPerformanceNavigationTiming(m, _, C, R, L, B) {
      let F = B ? _[B] : _[`${C}End`];
      let U = _[`${C}Start`];
      if (U && F) {
        startAndEndSpan(m, R + msToSec(U), R + msToSec(F), {
          op: `browser.${L || C}`,
          name: _.name,
          attributes: {
            [ta.S3]: "auto.ui.browser.metrics"
          }
        });
      }
    }
    function setResourceEntrySizeData(m, _, C, R) {
      let L = _[C];
      if (L != null && L < 2147483647) {
        m[R] = L;
      }
    }
    let tx = [];
    let tI = new Map();
    let tO = {
      click: "click",
      pointerdown: "click",
      pointerup: "click",
      mousedown: "click",
      mouseup: "click",
      touchstart: "click",
      touchend: "click",
      mouseover: "hover",
      mouseout: "hover",
      mouseenter: "hover",
      mouseleave: "hover",
      pointerover: "hover",
      pointerout: "hover",
      pointerenter: "hover",
      pointerleave: "hover",
      dragstart: "drag",
      dragend: "drag",
      drag: "drag",
      dragenter: "drag",
      dragleave: "drag",
      dragover: "drag",
      drop: "drag",
      keydown: "press",
      keyup: "press",
      keypress: "press",
      input: "press"
    };
    var tC = C(67973);
    var tM = C(89366);
    var tT = C(58915);
    var tA = C(69737);
    let tR = {
      idleTimeout: 1000,
      finalTimeout: 30000,
      childSpanTimeout: 15000
    };
    function startIdleSpan(m, _ = {}) {
      let C;
      let R = new Map();
      let L = false;
      let B = "externalFinish";
      let F = !_.disableAutoFinish;
      let U = [];
      let {
        idleTimeout: H = tR.idleTimeout,
        finalTimeout: q = tR.finalTimeout,
        childSpanTimeout: V = tR.childSpanTimeout,
        beforeSpanEnd: X
      } = _;
      let K = (0, eI.s3)();
      if (!K || !(0, tC.z)()) {
        return new tT.b();
      }
      let Y = (0, eI.nZ)();
      let Q = (0, ti.HN)();
      let et = function (m) {
        let _ = (0, to.qp)(m);
        (0, tM.D)((0, eI.nZ)(), _);
        if (ew.X) {
          ev.kg.log("[Tracing] Started span is an idle span");
        }
        return _;
      }(m);
      function _cancelIdleTimeout() {
        if (C) {
          clearTimeout(C);
          C = undefined;
        }
      }
      function _restartIdleTimeout(m) {
        _cancelIdleTimeout();
        C = setTimeout(() => {
          if (!L && R.size === 0 && F) {
            B = "idleTimeout";
            et.end(m);
          }
        }, H);
      }
      function _restartChildSpanTimeout(m) {
        C = setTimeout(() => {
          if (!L && F) {
            B = "heartbeatFailed";
            et.end(m);
          }
        }, V);
      }
      function onIdleSpanEnded(m) {
        L = true;
        R.clear();
        U.forEach(m => m());
        (0, tM.D)(Y, Q);
        let _ = (0, ti.XU)(et);
        let {
          start_timestamp: C
        } = _;
        if (!C) {
          return;
        }
        let F = _.data || {};
        if (!F[ta.ju]) {
          et.setAttribute(ta.ju, B);
        }
        ev.kg.log(`[Tracing] Idle span "${_.op}" finished`);
        let V = (0, ti.Dp)(et).filter(m => m !== et);
        let X = 0;
        V.forEach(_ => {
          if (_.isRecording()) {
            _.setStatus({
              code: tA.jt,
              message: "cancelled"
            });
            _.end(m);
            if (ew.X) {
              ev.kg.log("[Tracing] Cancelling span since span ended early", JSON.stringify(_, undefined, 2));
            }
          }
          let C = (0, ti.XU)(_);
          let {
            timestamp: R = 0,
            start_timestamp: L = 0
          } = C;
          let B = L <= m;
          let F = (q + H) / 1000;
          let U = R - L <= F;
          if (ew.X) {
            let m = JSON.stringify(_, undefined, 2);
            if (B) {
              if (!U) {
                ev.kg.log("[Tracing] Discarding span since it finished after idle span final timeout", m);
              }
            } else {
              ev.kg.log("[Tracing] Discarding span since it happened after idle span was finished", m);
            }
          }
          if (!U || !B) {
            (0, ti.ed)(et, _);
            X++;
          }
        });
        if (X > 0) {
          et.setAttribute("sentry.idle_span_discarded_spans", X);
        }
      }
      et.end = new Proxy(et.end, {
        apply(m, _, C) {
          if (X) {
            X(et);
          }
          let [R, ...L] = C;
          let B = R || (0, eU.ph)();
          let F = (0, ti.$k)(B);
          let U = (0, ti.Dp)(et).filter(m => m !== et);
          if (!U.length) {
            onIdleSpanEnded(F);
            return Reflect.apply(m, _, [F, ...L]);
          }
          let H = U.map(m => (0, ti.XU)(m).timestamp).filter(m => !!m);
          let V = H.length ? Math.max(...H) : undefined;
          let K = (0, ti.XU)(et).start_timestamp;
          let Y = Math.min(K ? K + q / 1000 : Infinity, Math.max(K || -Infinity, Math.min(F, V || Infinity)));
          onIdleSpanEnded(Y);
          return Reflect.apply(m, _, [Y, ...L]);
        }
      });
      U.push(K.on("spanStart", m => {
        if (L || m === et || (0, ti.XU)(m).timestamp) {
          return;
        }
        let _ = (0, ti.Dp)(et);
        if (_.includes(m)) {
          (function (m) {
            _cancelIdleTimeout();
            R.set(m, true);
            let _ = (0, eU.ph)();
            _restartChildSpanTimeout(_ + V / 1000);
          })(m.spanContext().spanId);
        }
      }));
      U.push(K.on("spanEnd", m => {
        if (!L) {
          (function (m) {
            if (R.has(m)) {
              R.delete(m);
            }
            if (R.size === 0) {
              let m = (0, eU.ph)();
              _restartIdleTimeout(m + H / 1000);
            }
          })(m.spanContext().spanId);
        }
      }));
      U.push(K.on("idleSpanEnableAutoFinish", m => {
        if (m === et) {
          F = true;
          _restartIdleTimeout();
          if (R.size) {
            _restartChildSpanTimeout();
          }
        }
      }));
      if (!_.disableAutoFinish) {
        _restartIdleTimeout();
      }
      setTimeout(() => {
        if (!L) {
          et.setStatus({
            code: tA.jt,
            message: "deadline_exceeded"
          });
          B = "finalTimeout";
          et.end();
        }
      }, q);
      return et;
    }
    let tP = false;
    function errorCallback() {
      let m = (0, ti.HN)();
      let _ = m && (0, ti.Gx)(m);
      if (_) {
        let m = "internal_error";
        if (ew.X) {
          ev.kg.log(`[Tracing] Root span: ${m} -> Global error occured`);
        }
        _.setStatus({
          code: tA.jt,
          message: m
        });
      }
    }
    errorCallback.tag = "sentry_tracingErrorCallback";
    var tD = C(85712);
    var tL = C(19548);
    var tN = C(60859);
    let tB = new WeakMap();
    let tj = new Map();
    let tF = {
      traceFetch: true,
      traceXHR: true,
      enableHTTPTimings: true
    };
    function addHTTPTimings(m) {
      let {
        url: _
      } = (0, ti.XU)(m).data || {};
      if (!_ || typeof _ != "string") {
        return;
      }
      let C = addPerformanceInstrumentationHandler("resource", ({
        entries: R
      }) => {
        R.forEach(R => {
          if (R.entryType === "resource" && "initiatorType" in R && typeof R.nextHopProtocol == "string" && (R.initiatorType === "fetch" || R.initiatorType === "xmlhttprequest") && R.name.endsWith(_)) {
            let _ = function (m) {
              let {
                name: _,
                version: C
              } = function (m) {
                let _ = "unknown";
                let C = "unknown";
                let R = "";
                for (let L of m) {
                  if (L === "/") {
                    [_, C] = m.split("/");
                    break;
                  }
                  if (!isNaN(Number(L))) {
                    _ = R === "h" ? "http" : R;
                    C = m.split(R)[1];
                    break;
                  }
                  R += L;
                }
                if (R === m) {
                  _ = R;
                }
                return {
                  name: _,
                  version: C
                };
              }(m.nextHopProtocol);
              let R = [];
              R.push(["network.protocol.version", C], ["network.protocol.name", _]);
              if (eU.Z1) {
                return [...R, ["http.request.redirect_start", getAbsoluteTime(m.redirectStart)], ["http.request.fetch_start", getAbsoluteTime(m.fetchStart)], ["http.request.domain_lookup_start", getAbsoluteTime(m.domainLookupStart)], ["http.request.domain_lookup_end", getAbsoluteTime(m.domainLookupEnd)], ["http.request.connect_start", getAbsoluteTime(m.connectStart)], ["http.request.secure_connection_start", getAbsoluteTime(m.secureConnectionStart)], ["http.request.connection_end", getAbsoluteTime(m.connectEnd)], ["http.request.request_start", getAbsoluteTime(m.requestStart)], ["http.request.response_start", getAbsoluteTime(m.responseStart)], ["http.request.response_end", getAbsoluteTime(m.responseEnd)]];
              } else {
                return R;
              }
            }(R);
            _.forEach(_ => m.setAttribute(..._));
            setTimeout(C);
          }
        });
      });
    }
    function getAbsoluteTime(m = 0) {
      return ((eU.Z1 || performance.timeOrigin) + m) / 1000;
    }
    function request_getFullURL(m) {
      try {
        let _ = new URL(m, eX.location.origin);
        return _.href;
      } catch (m) {
        return;
      }
    }
    let tU = {
      ...tR,
      instrumentNavigation: true,
      instrumentPageLoad: true,
      markBackgroundSpan: true,
      enableLongTask: true,
      enableLongAnimationFrame: true,
      enableInp: true,
      _experiments: {},
      ...tF
    };
    let browserTracingIntegration = (m = {}) => {
      if (!tP) {
        tP = true;
        addGlobalErrorInstrumentationHandler(errorCallback);
        addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
      }
      let {
        enableInp: _,
        enableLongTask: C,
        enableLongAnimationFrame: R,
        _experiments: {
          enableInteractions: L,
          enableStandaloneClsSpans: B
        },
        beforeStartSpan: F,
        idleTimeout: U,
        finalTimeout: H,
        childSpanTimeout: q,
        markBackgroundSpan: V,
        traceFetch: X,
        traceXHR: Y,
        shouldCreateSpanForRequest: er,
        enableHTTPTimings: en,
        instrumentPageLoad: ei,
        instrumentNavigation: eo
      } = {
        ...tU,
        ...m
      };
      let ea = function ({
        recordClsStandaloneSpans: m
      }) {
        let _ = getBrowserPerformanceAPI();
        if (_ && eU.Z1) {
          if (_.mark) {
            eL.performance.mark("sentry-tracing-init");
          }
          let C = addFidInstrumentationHandler(({
            metric: m
          }) => {
            let _ = m.entries[m.entries.length - 1];
            if (!_) {
              return;
            }
            let C = msToSec(eU.Z1);
            let R = msToSec(_.startTime);
            tk.fid = {
              value: m.value,
              unit: "millisecond"
            };
            tk["mark.fid"] = {
              value: C + R,
              unit: "second"
            };
          });
          let R = addLcpInstrumentationHandler(({
            metric: m
          }) => {
            let _ = m.entries[m.entries.length - 1];
            if (_) {
              tk.lcp = {
                value: m.value,
                unit: "millisecond"
              };
              Q = _;
            }
          }, true);
          let L = addMetricObserver("ttfb", ({
            metric: m
          }) => {
            let _ = m.entries[m.entries.length - 1];
            if (_) {
              tk.ttfb = {
                value: m.value,
                unit: "millisecond"
              };
            }
          }, instrumentTtfb, K);
          let B = m ? function () {
            let m;
            let _;
            let C = 0;
            if (!function () {
              try {
                return _optionalChain([PerformanceObserver, "access", m => m.supportedEntryTypes, "optionalAccess", m => m.includes, "call", m => m("layout-shift")]);
              } catch (m) {
                return false;
              }
            }()) {
              return;
            }
            let R = false;
            function _collectClsOnce() {
              if (!R) {
                R = true;
                if (_) {
                  (function (m, _, C) {
                    let R = msToSec((eU.Z1 || 0) + (_optionalChain([_, "optionalAccess", m => m.startTime]) || 0));
                    let L = (0, eI.nZ)().getScopeData().transactionName;
                    let B = _ ? (0, eY.Rt)(_optionalChain([_, "access", m => m.sources, "access", m => m[0], "optionalAccess", m => m.node])) : "Layout shift";
                    let F = (0, ex.Jr)({
                      [ta.S3]: "auto.http.browser.cls",
                      [ta.$J]: "ui.webvital.cls",
                      [ta.JQ]: _optionalChain([_, "optionalAccess", m => m.duration]) || 0,
                      "sentry.pageload.span_id": C
                    });
                    let U = startStandaloneWebVitalSpan({
                      name: B,
                      transaction: L,
                      attributes: F,
                      startTime: R
                    });
                    _optionalChain([U, "optionalAccess", m => m.addEvent, "call", _ => _("cls", {
                      [ta.E1]: "",
                      [ta.Wb]: m
                    })]);
                    _optionalChain([U, "optionalAccess", m => m.end, "call", m => m(R)]);
                  })(C, m, _);
                }
                L();
              }
            }
            let L = addClsInstrumentationHandler(({
              metric: _
            }) => {
              let R = _.entries[_.entries.length - 1];
              if (R) {
                C = _.value;
                m = R;
              }
            }, true);
            onHidden(() => {
              _collectClsOnce();
            });
            setTimeout(() => {
              let m = (0, eI.s3)();
              let C = _optionalChain([m, "optionalAccess", m => m.on, "call", m => m("startNavigationSpan", () => {
                _collectClsOnce();
                if (C) {
                  C();
                }
              })]);
              let R = (0, ti.HN)();
              let L = R && (0, ti.Gx)(R);
              let B = L && (0, ti.XU)(L);
              if (B && B.op === "pageload") {
                _ = L.spanContext().spanId;
              }
            }, 0);
          }() : addClsInstrumentationHandler(({
            metric: m
          }) => {
            let _ = m.entries[m.entries.length - 1];
            if (_) {
              tk.cls = {
                value: m.value,
                unit: ""
              };
              et = _;
            }
          }, true);
          return () => {
            C();
            R();
            L();
            if (B) {
              B();
            }
          };
        }
        return () => undefined;
      }({
        recordClsStandaloneSpans: B || false
      });
      if (_) {
        (function () {
          let m = getBrowserPerformanceAPI();
          if (m && eU.Z1) {
            let m = addInpInstrumentationHandler(({
              metric: m
            }) => {
              if (m.value == undefined) {
                return;
              }
              let _ = m.entries.find(_ => _.duration === m.value && tO[_.name]);
              if (!_) {
                return;
              }
              let {
                interactionId: C
              } = _;
              let R = tO[_.name];
              let L = msToSec(eU.Z1 + _.startTime);
              let B = msToSec(m.value);
              let F = (0, ti.HN)();
              let U = F ? (0, ti.Gx)(F) : undefined;
              let H = C != null ? tI.get(C) : undefined;
              let q = H || U;
              let V = q ? (0, ti.XU)(q).description : (0, eI.nZ)().getScopeData().transactionName;
              let X = (0, eY.Rt)(_.target);
              let K = (0, ex.Jr)({
                [ta.S3]: "auto.http.browser.inp",
                [ta.$J]: `ui.interaction.${R}`,
                [ta.JQ]: _.duration
              });
              let Y = startStandaloneWebVitalSpan({
                name: X,
                transaction: V,
                attributes: K,
                startTime: L
              });
              _optionalChain([Y, "optionalAccess", m => m.addEvent, "call", _ => _("inp", {
                [ta.E1]: "millisecond",
                [ta.Wb]: m.value
              })]);
              _optionalChain([Y, "optionalAccess", m => m.end, "call", m => m(L + B)]);
            });
          }
        })();
      }
      if (R && eT.GLOBAL_OBJ.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame")) {
        (function () {
          let m = new PerformanceObserver(m => {
            if ((0, ti.HN)()) {
              for (let _ of m.getEntries()) {
                if (!_.scripts[0]) {
                  continue;
                }
                let m = msToSec(eU.Z1 + _.startTime);
                let C = msToSec(_.duration);
                let R = {
                  [ta.S3]: "auto.ui.browser.metrics"
                };
                let L = _.scripts[0];
                let {
                  invoker: B,
                  invokerType: F,
                  sourceURL: U,
                  sourceFunctionName: H,
                  sourceCharPosition: q
                } = L;
                R["browser.script.invoker"] = B;
                R["browser.script.invoker_type"] = F;
                if (U) {
                  R["code.filepath"] = U;
                }
                if (H) {
                  R["code.function"] = H;
                }
                if (q !== -1) {
                  R["browser.script.source_char_position"] = q;
                }
                let V = (0, to.qp)({
                  name: "Main UI thread blocked",
                  op: "ui.long-animation-frame",
                  startTime: m,
                  attributes: R
                });
                if (V) {
                  V.end(m + C);
                }
              }
            }
          });
          m.observe({
            type: "long-animation-frame",
            buffered: true
          });
        })();
      } else if (C) {
        addPerformanceInstrumentationHandler("longtask", ({
          entries: m
        }) => {
          if ((0, ti.HN)()) {
            for (let _ of m) {
              let m = msToSec(eU.Z1 + _.startTime);
              let C = msToSec(_.duration);
              let R = (0, to.qp)({
                name: "Main UI thread blocked",
                op: "ui.long-task",
                startTime: m,
                attributes: {
                  [ta.S3]: "auto.ui.browser.metrics"
                }
              });
              if (R) {
                R.end(m + C);
              }
            }
          }
        });
      }
      if (L) {
        addPerformanceInstrumentationHandler("event", ({
          entries: m
        }) => {
          if ((0, ti.HN)()) {
            for (let _ of m) {
              if (_.name === "click") {
                let m = msToSec(eU.Z1 + _.startTime);
                let C = msToSec(_.duration);
                let R = {
                  name: (0, eY.Rt)(_.target),
                  op: `ui.interaction.${_.name}`,
                  startTime: m,
                  attributes: {
                    [ta.S3]: "auto.ui.browser.metrics"
                  }
                };
                let L = (0, eY.iY)(_.target);
                if (L) {
                  R.attributes["ui.component_name"] = L;
                }
                let B = (0, to.qp)(R);
                if (B) {
                  B.end(m + C);
                }
              }
            }
          }
        });
      }
      let es = {
        name: undefined,
        source: undefined
      };
      function _createRouteSpan(m, _) {
        let C = _.op === "pageload";
        let R = F ? F(_) : _;
        let L = R.attributes || {};
        if (_.name !== R.name) {
          L[ta.Zj] = "custom";
          R.attributes = L;
        }
        es.name = R.name;
        es.source = L[ta.Zj];
        let V = startIdleSpan(R, {
          idleTimeout: U,
          finalTimeout: H,
          childSpanTimeout: q,
          disableAutoFinish: C,
          beforeSpanEnd: m => {
            ea();
            (function (m, _) {
              let C = getBrowserPerformanceAPI();
              if (!C || !eL.performance.getEntries || !eU.Z1) {
                return;
              }
              let R = msToSec(eU.Z1);
              let L = C.getEntries();
              let {
                op: B,
                start_timestamp: F
              } = (0, ti.XU)(m);
              L.slice(tE).forEach(_ => {
                let C = msToSec(_.startTime);
                let L = msToSec(Math.max(0, _.duration));
                if (B !== "navigation" || !F || !(R + C < F)) {
                  switch (_.entryType) {
                    case "navigation":
                      ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(C => {
                        _addPerformanceNavigationTiming(m, _, C, R);
                      });
                      _addPerformanceNavigationTiming(m, _, "secureConnection", R, "TLS/SSL", "connectEnd");
                      _addPerformanceNavigationTiming(m, _, "fetch", R, "cache", "domainLookupStart");
                      _addPerformanceNavigationTiming(m, _, "domainLookup", R, "DNS");
                      (function (m, _, C) {
                        let R = C + msToSec(_.requestStart);
                        let L = C + msToSec(_.responseEnd);
                        let B = C + msToSec(_.responseStart);
                        if (_.responseEnd) {
                          startAndEndSpan(m, R, L, {
                            op: "browser.request",
                            name: _.name,
                            attributes: {
                              [ta.S3]: "auto.ui.browser.metrics"
                            }
                          });
                          startAndEndSpan(m, B, L, {
                            op: "browser.response",
                            name: _.name,
                            attributes: {
                              [ta.S3]: "auto.ui.browser.metrics"
                            }
                          });
                        }
                      })(m, _, R);
                      break;
                    case "mark":
                    case "paint":
                    case "measure":
                      {
                        (function (m, _, C, R, L) {
                          let B = getNavigationEntry();
                          let F = msToSec(B ? B.requestStart : 0);
                          let U = L + Math.max(C, F);
                          let H = L + C;
                          let q = {
                            [ta.S3]: "auto.resource.browser.metrics"
                          };
                          if (U !== H) {
                            q["sentry.browser.measure_happened_before_request"] = true;
                            q["sentry.browser.measure_start_time"] = U;
                          }
                          startAndEndSpan(m, U, H + R, {
                            name: _.name,
                            op: _.entryType,
                            attributes: q
                          });
                        })(m, _, C, L, R);
                        let B = getVisibilityWatcher();
                        let F = _.startTime < B.firstHiddenTime;
                        if (_.name === "first-paint" && F) {
                          tk.fp = {
                            value: _.startTime,
                            unit: "millisecond"
                          };
                        }
                        if (_.name === "first-contentful-paint" && F) {
                          tk.fcp = {
                            value: _.startTime,
                            unit: "millisecond"
                          };
                        }
                        break;
                      }
                    case "resource":
                      (function (m, _, C, R, L, B) {
                        if (_.initiatorType === "xmlhttprequest" || _.initiatorType === "fetch") {
                          return;
                        }
                        let F = url_parseUrl(C);
                        let U = {
                          [ta.S3]: "auto.resource.browser.metrics"
                        };
                        setResourceEntrySizeData(U, _, "transferSize", "http.response_transfer_size");
                        setResourceEntrySizeData(U, _, "encodedBodySize", "http.response_content_length");
                        setResourceEntrySizeData(U, _, "decodedBodySize", "http.decoded_response_content_length");
                        if ("renderBlockingStatus" in _) {
                          U["resource.render_blocking_status"] = _.renderBlockingStatus;
                        }
                        if (F.protocol) {
                          U["url.scheme"] = F.protocol.split(":").pop();
                        }
                        if (F.host) {
                          U["server.address"] = F.host;
                        }
                        U["url.same_origin"] = C.includes(eL.location.origin);
                        let H = B + R;
                        let q = H + L;
                        startAndEndSpan(m, H, q, {
                          name: C.replace(eL.location.origin, ""),
                          op: _.initiatorType ? `resource.${_.initiatorType}` : "resource.other",
                          attributes: U
                        });
                      })(m, _, _.name, C, L, R);
                  }
                }
              });
              tE = Math.max(L.length - 1, 0);
              (function (m) {
                let _ = eL.navigator;
                if (!_) {
                  return;
                }
                let C = _.connection;
                if (C) {
                  if (C.effectiveType) {
                    m.setAttribute("effectiveConnectionType", C.effectiveType);
                  }
                  if (C.type) {
                    m.setAttribute("connectionType", C.type);
                  }
                  if (isMeasurementValue(C.rtt)) {
                    tk["connection.rtt"] = {
                      value: C.rtt,
                      unit: "millisecond"
                    };
                  }
                }
                if (isMeasurementValue(_.deviceMemory)) {
                  m.setAttribute("deviceMemory", `${_.deviceMemory} GB`);
                }
                if (isMeasurementValue(_.hardwareConcurrency)) {
                  m.setAttribute("hardwareConcurrency", String(_.hardwareConcurrency));
                }
              })(m);
              if (B === "pageload") {
                (function (m) {
                  let _ = getNavigationEntry();
                  if (!_) {
                    return;
                  }
                  let {
                    responseStart: C,
                    requestStart: R
                  } = _;
                  if (R <= C) {
                    m["ttfb.requestTime"] = {
                      value: C - R,
                      unit: "millisecond"
                    };
                  }
                })(tk);
                let C = tk["mark.fid"];
                if (C && tk.fid) {
                  startAndEndSpan(m, C.value, C.value + msToSec(tk.fid.value), {
                    name: "first input delay",
                    op: "ui.action",
                    attributes: {
                      [ta.S3]: "auto.ui.browser.metrics"
                    }
                  });
                  delete tk["mark.fid"];
                }
                if (!("fcp" in tk) || !_.recordClsOnPageloadSpan) {
                  delete tk.cls;
                }
                Object.entries(tk).forEach(([m, _]) => {
                  (0, ts.o)(m, _.value, _.unit);
                });
                m.setAttribute("performance.timeOrigin", R);
                m.setAttribute("performance.activationStart", getActivationStart());
                if (Q) {
                  if (Q.element) {
                    m.setAttribute("lcp.element", (0, eY.Rt)(Q.element));
                  }
                  if (Q.id) {
                    m.setAttribute("lcp.id", Q.id);
                  }
                  if (Q.url) {
                    m.setAttribute("lcp.url", Q.url.trim().slice(0, 200));
                  }
                  m.setAttribute("lcp.size", Q.size);
                }
                if (et && et.sources) {
                  et.sources.forEach((_, C) => m.setAttribute(`cls.source.${C + 1}`, (0, eY.Rt)(_.node)));
                }
              }
              Q = undefined;
              et = undefined;
              tk = {};
            })(m, {
              recordClsOnPageloadSpan: !B
            });
          }
        });
        function emitFinish() {
          if (["interactive", "complete"].includes(eX.document.readyState)) {
            m.emit("idleSpanEnableAutoFinish", V);
          }
        }
        if (C && eX.document) {
          eX.document.addEventListener("readystatechange", () => {
            emitFinish();
          });
          emitFinish();
        }
        return V;
      }
      return {
        name: "BrowserTracing",
        afterAllSetup(m) {
          let C;
          let R;
          let B = eX.location && eX.location.href;
          m.on("startNavigationSpan", _ => {
            if ((0, eI.s3)() === m) {
              if (C && !(0, ti.XU)(C).timestamp) {
                C.end();
              }
              C = _createRouteSpan(m, {
                op: "navigation",
                ..._
              });
            }
          });
          m.on("startPageLoadSpan", (_, R = {}) => {
            if ((0, eI.s3)() !== m) {
              return;
            }
            if (C && !(0, ti.XU)(C).timestamp) {
              C.end();
            }
            let L = R.sentryTrace || getMetaContent("sentry-trace");
            let B = R.baggage || getMetaContent("baggage");
            let F = (0, tD.pT)(L, B);
            (0, eI.nZ)().setPropagationContext(F);
            C = _createRouteSpan(m, {
              op: "pageload",
              ..._
            });
          });
          m.on("spanEnd", m => {
            let _ = (0, ti.XU)(m).op;
            if (m !== (0, ti.Gx)(m) || _ !== "navigation" && _ !== "pageload") {
              return;
            }
            let C = (0, eI.nZ)();
            let R = C.getPropagationContext();
            C.setPropagationContext({
              ...R,
              sampled: R.sampled !== undefined ? R.sampled : (0, ti.Tt)(m),
              dsc: R.dsc || (0, e$.jC)(m)
            });
          });
          if (eX.location) {
            if (ei) {
              startBrowserTracingPageLoadSpan(m, {
                name: eX.location.pathname,
                startTime: eU.Z1 ? eU.Z1 / 1000 : undefined,
                attributes: {
                  [ta.Zj]: "url",
                  [ta.S3]: "auto.pageload.browser"
                }
              });
            }
            if (eo) {
              addHistoryInstrumentationHandler(({
                to: _,
                from: C
              }) => {
                if (C === undefined && B && B.indexOf(_) !== -1) {
                  B = undefined;
                  return;
                }
                if (C !== _) {
                  B = undefined;
                  startBrowserTracingNavigationSpan(m, {
                    name: eX.location.pathname,
                    attributes: {
                      [ta.Zj]: "url",
                      [ta.S3]: "auto.navigation.browser"
                    }
                  });
                }
              });
            }
          }
          if (V && eX && eX.document) {
            eX.document.addEventListener("visibilitychange", () => {
              let m = (0, ti.HN)();
              if (!m) {
                return;
              }
              let _ = (0, ti.Gx)(m);
              if (eX.document.hidden && _) {
                let {
                  op: m,
                  status: C
                } = (0, ti.XU)(_);
                if (!C) {
                  _.setStatus({
                    code: tA.jt,
                    message: "cancelled"
                  });
                }
                _.setAttribute("sentry.cancellation_reason", "document.hidden");
                _.end();
              }
            });
          }
          if (L && eX.document) {
            addEventListener("click", () => {
              let m = (0, ti.HN)();
              let _ = m && (0, ti.Gx)(m);
              if (_) {
                let m = (0, ti.XU)(_).op;
                if (["navigation", "pageload"].includes(m)) {
                  return;
                }
              }
              if (R) {
                R.setAttribute(ta.ju, "interactionInterrupted");
                R.end();
                R = undefined;
              }
              if (es.name) {
                R = startIdleSpan({
                  name: es.name,
                  op: "ui.action.click",
                  attributes: {
                    [ta.Zj]: es.source || "url"
                  }
                }, {
                  idleTimeout: U,
                  finalTimeout: H,
                  childSpanTimeout: q
                });
              }
            }, {
              once: false,
              capture: true
            });
          }
          if (_) {
            (function () {
              let handleEntries = ({
                entries: m
              }) => {
                let _ = (0, ti.HN)();
                let C = _ && (0, ti.Gx)(_);
                m.forEach(m => {
                  if (!("duration" in m) || !C) {
                    return;
                  }
                  let _ = m.interactionId;
                  if (_ != null && !tI.has(_)) {
                    if (tx.length > 10) {
                      let m = tx.shift();
                      tI.delete(m);
                    }
                    tx.push(_);
                    tI.set(_, C);
                  }
                });
              };
              addPerformanceInstrumentationHandler("event", handleEntries);
              addPerformanceInstrumentationHandler("first-input", handleEntries);
            })();
          }
          (function (m, _) {
            let {
              traceFetch: C,
              traceXHR: R,
              shouldCreateSpanForRequest: L,
              enableHTTPTimings: B,
              tracePropagationTargets: F
            } = {
              traceFetch: tF.traceFetch,
              traceXHR: tF.traceXHR,
              ..._
            };
            let U = typeof L == "function" ? L : m => true;
            let shouldAttachHeadersWithTargets = m => function (m, _) {
              let C = eX.location && eX.location.href;
              if (C) {
                let R;
                let L;
                try {
                  R = new URL(m, C);
                  L = new URL(C).origin;
                } catch (m) {
                  return false;
                }
                let B = R.origin === L;
                if (_) {
                  return (0, eS.U0)(R.toString(), _) || B && (0, eS.U0)(R.pathname, _);
                } else {
                  return B;
                }
              }
              {
                let C = !!m.match(/^\/(?!\/)/);
                if (_) {
                  return (0, eS.U0)(m, _);
                } else {
                  return C;
                }
              }
            }(m, F);
            let H = {};
            if (C) {
              m.addEventProcessor(m => {
                if (m.type === "transaction" && m.spans) {
                  m.spans.forEach(m => {
                    if (m.op === "http.client") {
                      let _ = tj.get(m.span_id);
                      if (_) {
                        m.timestamp = _ / 1000;
                        tj.delete(m.span_id);
                      }
                    }
                  });
                }
                return m;
              });
              (function (m) {
                let _ = "fetch-body-resolved";
                addHandler(_, m);
                maybeInstrument(_, () => instrumentFetch(streamHandler));
              })(m => {
                if (m.response) {
                  let _ = tB.get(m.response);
                  if (_ && m.endTimestamp) {
                    tj.set(_, m.endTimestamp);
                  }
                }
              });
              addFetchInstrumentationHandler(m => {
                let _ = function (m, _, C, R, L = "auto.http.browser") {
                  if (!m.fetchData) {
                    return;
                  }
                  let B = (0, tC.z)() && _(m.fetchData.url);
                  if (m.endTimestamp && B) {
                    let _ = m.fetchData.__span;
                    if (!_) {
                      return;
                    }
                    let C = R[_];
                    if (C) {
                      (function (m, _) {
                        if (_.response) {
                          (0, tA.Q0)(m, _.response.status);
                          let C = _.response && _.response.headers && _.response.headers.get("content-length");
                          if (C) {
                            let _ = parseInt(C);
                            if (_ > 0) {
                              m.setAttribute("http.response_content_length", _);
                            }
                          }
                        } else if (_.error) {
                          m.setStatus({
                            code: tA.jt,
                            message: "internal_error"
                          });
                        }
                        m.end();
                      })(C, m);
                      delete R[_];
                    }
                    return;
                  }
                  let F = (0, eI.nZ)();
                  let U = (0, eI.s3)();
                  let {
                    method: H,
                    url: q
                  } = m.fetchData;
                  let V = function (m) {
                    try {
                      let _ = new URL(m);
                      return _.href;
                    } catch (m) {
                      return;
                    }
                  }(q);
                  let X = V ? url_parseUrl(V).host : undefined;
                  let K = !!(0, ti.HN)();
                  let Y = B && K ? (0, to.qp)({
                    name: `${H} ${q}`,
                    attributes: {
                      url: q,
                      type: "fetch",
                      "http.method": H,
                      "http.url": V,
                      "server.address": X,
                      [ta.S3]: L,
                      [ta.$J]: "http.client"
                    }
                  }) : new tT.b();
                  m.fetchData.__span = Y.spanContext().spanId;
                  R[Y.spanContext().spanId] = Y;
                  if (C(m.fetchData.url) && U) {
                    let _ = m.args[0];
                    m.args[1] = m.args[1] || {};
                    let C = m.args[1];
                    C.headers = function (m, _, C, R, L) {
                      let B = (0, eI.aF)();
                      let {
                        traceId: F,
                        spanId: U,
                        sampled: H,
                        dsc: q
                      } = {
                        ...B.getPropagationContext(),
                        ...C.getPropagationContext()
                      };
                      let V = L ? (0, ti.Hb)(L) : (0, tD.$p)(F, U, H);
                      let X = (0, tN.IQ)(q || (L ? (0, e$.jC)(L) : (0, e$._l)(F, _)));
                      let K = R.headers || (typeof Request != "undefined" && (0, eB.V9)(m, Request) ? m.headers : undefined);
                      if (!K) {
                        return {
                          "sentry-trace": V,
                          baggage: X
                        };
                      }
                      if (typeof Headers != "undefined" && (0, eB.V9)(K, Headers)) {
                        let m = new Headers(K);
                        m.append("sentry-trace", V);
                        if (X) {
                          m.append(tN.bU, X);
                        }
                        return m;
                      }
                      if (Array.isArray(K)) {
                        let m = [...K, ["sentry-trace", V]];
                        if (X) {
                          m.push([tN.bU, X]);
                        }
                        return m;
                      }
                      {
                        let m = "baggage" in K ? K.baggage : undefined;
                        let _ = [];
                        if (Array.isArray(m)) {
                          _.push(...m);
                        } else if (m) {
                          _.push(m);
                        }
                        if (X) {
                          _.push(X);
                        }
                        return {
                          ...K,
                          "sentry-trace": V,
                          baggage: _.length > 0 ? _.join(",") : undefined
                        };
                      }
                    }(_, U, F, C, (0, tC.z)() && K ? Y : undefined);
                  }
                  return Y;
                }(m, U, shouldAttachHeadersWithTargets, H);
                if (m.response && m.fetchData.__span) {
                  tB.set(m.response, m.fetchData.__span);
                }
                if (_) {
                  let C = request_getFullURL(m.fetchData.url);
                  let R = C ? url_parseUrl(C).host : undefined;
                  _.setAttributes({
                    "http.url": C,
                    "server.address": R
                  });
                }
                if (B && _) {
                  addHTTPTimings(_);
                }
              });
            }
            if (R) {
              addXhrInstrumentationHandler(m => {
                let _ = function (m, _, C, R) {
                  let L = m.xhr;
                  let B = L && L[eZ];
                  if (!L || L.__sentry_own_request__ || !B) {
                    return;
                  }
                  let F = (0, tC.z)() && _(B.url);
                  if (m.endTimestamp && F) {
                    let m = L.__sentry_xhr_span_id__;
                    if (!m) {
                      return;
                    }
                    let _ = R[m];
                    if (_ && B.status_code !== undefined) {
                      (0, tA.Q0)(_, B.status_code);
                      _.end();
                      delete R[m];
                    }
                    return;
                  }
                  let U = request_getFullURL(B.url);
                  let H = U ? url_parseUrl(U).host : undefined;
                  let q = !!(0, ti.HN)();
                  let V = F && q ? (0, to.qp)({
                    name: `${B.method} ${B.url}`,
                    attributes: {
                      type: "xhr",
                      "http.method": B.method,
                      "http.url": U,
                      url: B.url,
                      "server.address": H,
                      [ta.S3]: "auto.http.browser",
                      [ta.$J]: "http.client"
                    }
                  }) : new tT.b();
                  L.__sentry_xhr_span_id__ = V.spanContext().spanId;
                  R[L.__sentry_xhr_span_id__] = V;
                  let X = (0, eI.s3)();
                  if (L.setRequestHeader && C(B.url) && X) {
                    (function (m, _, C) {
                      let R = (0, eI.nZ)();
                      let L = (0, eI.aF)();
                      let {
                        traceId: B,
                        spanId: F,
                        sampled: U,
                        dsc: H
                      } = {
                        ...L.getPropagationContext(),
                        ...R.getPropagationContext()
                      };
                      let q = C && (0, tC.z)() ? (0, ti.Hb)(C) : (0, tD.$p)(B, F, U);
                      let V = (0, tN.IQ)(H || (C ? (0, e$.jC)(C) : (0, e$._l)(B, _)));
                      (function (m, _, C) {
                        try {
                          m.setRequestHeader("sentry-trace", _);
                          if (C) {
                            m.setRequestHeader(tN.bU, C);
                          }
                        } catch (m) {}
                      })(m, q, V);
                    })(L, X, (0, tC.z)() && q ? V : undefined);
                  }
                  return V;
                }(m, U, shouldAttachHeadersWithTargets, H);
                if (B && _) {
                  addHTTPTimings(_);
                }
              });
            }
          })(m, {
            traceFetch: X,
            traceXHR: Y,
            tracePropagationTargets: m.getOptions().tracePropagationTargets,
            shouldCreateSpanForRequest: er,
            enableHTTPTimings: en
          });
        }
      };
    };
    function startBrowserTracingPageLoadSpan(m, _, C) {
      m.emit("startPageLoadSpan", _, C);
      (0, eI.nZ)().setTransactionName(_.name);
      let R = (0, ti.HN)();
      let L = R && (0, ti.XU)(R).op;
      if (L === "pageload") {
        return R;
      } else {
        return undefined;
      }
    }
    function startBrowserTracingNavigationSpan(m, _) {
      (0, eI.aF)().setPropagationContext((0, tL.Q)());
      (0, eI.nZ)().setPropagationContext((0, tL.Q)());
      m.emit("startNavigationSpan", _);
      (0, eI.nZ)().setTransactionName(_.name);
      let C = (0, ti.HN)();
      let R = C && (0, ti.XU)(C).op;
      if (R === "navigation") {
        return C;
      } else {
        return undefined;
      }
    }
    function getMetaContent(m) {
      let _ = (0, eY.qT)(`meta[name=${m}]`);
      if (_) {
        return _.getAttribute("content");
      } else {
        return undefined;
      }
    }
    let tH = "incomplete-app-router-transaction";
    let tW = eT.GLOBAL_OBJ;
    function transactionNameifyRouterArgument(m) {
      try {
        return new URL(m, "http://some-random-base.com/").pathname;
      } catch (m) {
        return "/";
      }
    }
    var t$ = C(11163);
    var tq = C(36096);
    let tG = t$.events ? t$ : t$.default;
    let tz = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
    function resolve(...m) {
      let _ = "";
      let C = false;
      for (let R = m.length - 1; R >= -1 && !C; R--) {
        let L = R >= 0 ? m[R] : "/";
        if (L) {
          _ = `${L}/${_}`;
          C = L.charAt(0) === "/";
        }
      }
      _ = function (m, _) {
        let C = 0;
        for (let _ = m.length - 1; _ >= 0; _--) {
          let R = m[_];
          if (R === ".") {
            m.splice(_, 1);
          } else if (R === "..") {
            m.splice(_, 1);
            C++;
          } else if (C) {
            m.splice(_, 1);
            C--;
          }
        }
        if (_) {
          for (; C--; C) {
            m.unshift("..");
          }
        }
        return m;
      }(_.split("/").filter(m => !!m), !C).join("/");
      return (C ? "/" : "") + _ || ".";
    }
    function trim(m) {
      let _ = 0;
      for (; _ < m.length && m[_] === ""; _++);
      let C = m.length - 1;
      for (; C >= 0 && m[C] === ""; C--);
      if (_ > C) {
        return [];
      } else {
        return m.slice(_, C - _ + 1);
      }
    }
    let rewriteFramesIntegration = (m = {}) => {
      let _ = m.root;
      let C = m.prefix || "app:///";
      let R = "window" in eT.GLOBAL_OBJ && eT.GLOBAL_OBJ.window !== undefined;
      let L = m.iteratee || function ({
        isBrowser: m,
        root: _,
        prefix: C
      }) {
        return R => {
          if (!R.filename) {
            return R;
          }
          let L = /^[a-zA-Z]:\\/.test(R.filename) || R.filename.includes("\\") && !R.filename.includes("/");
          let B = /^\//.test(R.filename);
          if (m) {
            if (_) {
              let m = R.filename;
              if (m.indexOf(_) === 0) {
                R.filename = m.replace(_, C);
              }
            }
          } else if (L || B) {
            var F;
            let m;
            let B = L ? R.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : R.filename;
            let U = _ ? function (m, _) {
              m = resolve(m).slice(1);
              _ = resolve(_).slice(1);
              let C = trim(m.split("/"));
              let R = trim(_.split("/"));
              let L = Math.min(C.length, R.length);
              let B = L;
              for (let m = 0; m < L; m++) {
                if (C[m] !== R[m]) {
                  B = m;
                  break;
                }
              }
              let F = [];
              for (let m = B; m < C.length; m++) {
                F.push("..");
              }
              return (F = F.concat(R.slice(B))).join("/");
            }(_, B) : (m = function (m) {
              let _ = m.length > 1024 ? `<truncated>${m.slice(-1024)}` : m;
              let C = tz.exec(_);
              if (C) {
                return C.slice(1);
              } else {
                return [];
              }
            }(B)[2] || "", F && m.slice(F.length * -1) === F && (m = m.slice(0, m.length - F.length)), m);
            R.filename = `${C}${U}`;
          }
          return R;
        };
      }({
        isBrowser: R,
        root: _,
        prefix: C
      });
      return {
        name: "RewriteFrames",
        processEvent(m) {
          let _ = m;
          if (m.exception && Array.isArray(m.exception.values)) {
            _ = function (m) {
              try {
                return {
                  ...m,
                  exception: {
                    ...m.exception,
                    values: m.exception.values.map(m => {
                      var _;
                      return {
                        ...m,
                        ...(m.stacktrace && {
                          stacktrace: {
                            ...(_ = m.stacktrace),
                            frames: _ && _.frames && _.frames.map(m => L(m))
                          }
                        })
                      };
                    })
                  }
                };
              } catch (_) {
                return m;
              }
            }(_);
          }
          return _;
        }
      };
    };
    let nextjsClientStackFrameNormalizationIntegration = ({
      assetPrefixPath: m
    }) => {
      let _ = rewriteFramesIntegration({
        iteratee: _ => {
          try {
            let {
              origin: C
            } = new URL(_.filename);
            _.filename = _optionalChain([_, "access", m => m.filename, "optionalAccess", m => m.replace, "call", m => m(C, "app://"), "access", m => m.replace, "call", _ => _(m, "")]);
          } catch (m) {}
          if (_.filename && _.filename.startsWith("app:///_next")) {
            _.filename = decodeURI(_.filename);
          }
          if (_.filename && _.filename.match(/^app:\/\/\/_next\/static\/chunks\/(main-|main-app-|polyfills-|webpack-|framework-|framework\.)[0-9a-f]+\.js$/)) {
            _.in_app = false;
          }
          return _;
        }
      });
      return {
        ..._,
        name: "NextjsClientStackFrameNormalization"
      };
    };
    let tV = eT.GLOBAL_OBJ;
    let tJ = eT.GLOBAL_OBJ;
    function removeTrailingSlash(m) {
      if (m[m.length - 1] === "/") {
        return m.slice(0, -1);
      } else {
        return m;
      }
    }
    var tX = C(34155);
    function isBrowser() {
      return typeof window != "undefined" && (typeof __SENTRY_BROWSER_BUNDLE__ != "undefined" && !!__SENTRY_BROWSER_BUNDLE__ || Object.prototype.toString.call(tX !== undefined ? tX : 0) !== "[object process]" || eT.GLOBAL_OBJ.process !== undefined && eT.GLOBAL_OBJ.process.type === "renderer");
    }
    let tK = eT.GLOBAL_OBJ;
    let tZ = "sentryReplaySession";
    let tY = "Unable to send Replay";
    function _nullishCoalesce$1(m, _) {
      return m ?? _();
    }
    function _optionalChain$5(m) {
      let _;
      let C = m[0];
      let R = 1;
      while (R < m.length) {
        let L = m[R];
        let B = m[R + 1];
        R += 2;
        if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
          return;
        }
        if (L === "access" || L === "optionalAccess") {
          _ = C;
          C = B(C);
        } else if (L === "call" || L === "optionalCall") {
          C = B((...m) => C.call(_, ...m));
          _ = undefined;
        }
      }
      return C;
    }
    function isShadowRoot(m) {
      let _ = _optionalChain$5([m, "optionalAccess", m => m.host]);
      return _optionalChain$5([_, "optionalAccess", m => m.shadowRoot]) === m;
    }
    function isNativeShadowDom(m) {
      return Object.prototype.toString.call(m) === "[object ShadowRoot]";
    }
    function stringifyStylesheet(m) {
      try {
        var _;
        let C = m.rules || m.cssRules;
        if (C) {
          if ((_ = Array.from(C, stringifyRule).join("")).includes(" background-clip: text;") && !_.includes(" -webkit-background-clip: text;")) {
            _ = _.replace(/\sbackground-clip:\s*text;/g, " -webkit-background-clip: text; background-clip: text;");
          }
          return _;
        } else {
          return null;
        }
      } catch (m) {
        return null;
      }
    }
    function stringifyRule(m) {
      let _;
      if ("styleSheet" in m) {
        try {
          _ = stringifyStylesheet(m.styleSheet) || function (m) {
            let {
              cssText: _
            } = m;
            if (_.split("\"").length < 3) {
              return _;
            }
            let C = ["@import", `url(${JSON.stringify(m.href)})`];
            if (m.layerName === "") {
              C.push("layer");
            } else if (m.layerName) {
              C.push(`layer(${m.layerName})`);
            }
            if (m.supportsText) {
              C.push(`supports(${m.supportsText})`);
            }
            if (m.media.length) {
              C.push(m.media.mediaText);
            }
            return C.join(" ") + ";";
          }(m);
        } catch (m) {}
      } else if ("selectorText" in m && m.selectorText.includes(":")) {
        return m.cssText.replace(/(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm, "$1\\$2");
      }
      return _ || m.cssText;
    }
    (ec = em ||= {})[ec.Document = 0] = "Document";
    ec[ec.DocumentType = 1] = "DocumentType";
    ec[ec.Element = 2] = "Element";
    ec[ec.Text = 3] = "Text";
    ec[ec.CDATA = 4] = "CDATA";
    ec[ec.Comment = 5] = "Comment";
    let Mirror = class Mirror {
      constructor() {
        this.idNodeMap = new Map();
        this.nodeMetaMap = new WeakMap();
      }
      getId(m) {
        if (!m) {
          return -1;
        }
        let _ = _optionalChain$5([this, "access", m => m.getMeta, "call", _ => _(m), "optionalAccess", m => m.id]);
        return _nullishCoalesce$1(_, () => -1);
      }
      getNode(m) {
        return this.idNodeMap.get(m) || null;
      }
      getIds() {
        return Array.from(this.idNodeMap.keys());
      }
      getMeta(m) {
        return this.nodeMetaMap.get(m) || null;
      }
      removeNodeFromMap(m) {
        let _ = this.getId(m);
        this.idNodeMap.delete(_);
        if (m.childNodes) {
          m.childNodes.forEach(m => this.removeNodeFromMap(m));
        }
      }
      has(m) {
        return this.idNodeMap.has(m);
      }
      hasNode(m) {
        return this.nodeMetaMap.has(m);
      }
      add(m, _) {
        let C = _.id;
        this.idNodeMap.set(C, m);
        this.nodeMetaMap.set(m, _);
      }
      replace(m, _) {
        let C = this.getNode(m);
        if (C) {
          let m = this.nodeMetaMap.get(C);
          if (m) {
            this.nodeMetaMap.set(_, m);
          }
        }
        this.idNodeMap.set(m, _);
      }
      reset() {
        this.idNodeMap = new Map();
        this.nodeMetaMap = new WeakMap();
      }
    };
    function shouldMaskInput({
      maskInputOptions: m,
      tagName: _,
      type: C
    }) {
      if (_ === "OPTION") {
        _ = "SELECT";
      }
      return !!m[_.toLowerCase()] || !!C && !!m[C] || C === "password" || _ === "INPUT" && !C && !!m.text;
    }
    function maskInputValue({
      isMasked: m,
      element: _,
      value: C,
      maskInputFn: R
    }) {
      let L = C || "";
      if (m) {
        if (R) {
          L = R(L, _);
        }
        return "*".repeat(L.length);
      } else {
        return L;
      }
    }
    function toLowerCase(m) {
      return m.toLowerCase();
    }
    function toUpperCase(m) {
      return m.toUpperCase();
    }
    let tQ = "__rrweb_original__";
    function getInputType(m) {
      let _ = m.type;
      if (m.hasAttribute("data-rr-is-password")) {
        return "password";
      } else if (_) {
        return toLowerCase(_);
      } else {
        return null;
      }
    }
    function getInputValue(m, _, C) {
      if (_ === "INPUT" && (C === "radio" || C === "checkbox")) {
        return m.getAttribute("value") || "";
      } else {
        return m.value;
      }
    }
    function extractFileExtension(m, _) {
      let C;
      try {
        C = new URL(m, _nullishCoalesce$1(_, () => window.location.href));
      } catch (m) {
        return null;
      }
      let R = C.pathname.match(/\.([0-9a-z]+)(?:$)/i);
      return _nullishCoalesce$1(_optionalChain$5([R, "optionalAccess", m => m[1]]), () => null);
    }
    let t0 = {};
    function getImplementation$1(m) {
      let _ = t0[m];
      if (_) {
        return _;
      }
      let C = window.document;
      let R = window[m];
      if (C && typeof C.createElement == "function") {
        try {
          let _ = C.createElement("iframe");
          _.hidden = true;
          C.head.appendChild(_);
          let L = _.contentWindow;
          if (L && L[m]) {
            R = L[m];
          }
          C.head.removeChild(_);
        } catch (m) {}
      }
      return t0[m] = R.bind(window);
    }
    function setTimeout$2(...m) {
      return getImplementation$1("setTimeout")(...m);
    }
    function clearTimeout$2(...m) {
      return getImplementation$1("clearTimeout")(...m);
    }
    let t1 = 1;
    let t2 = RegExp("[^a-z0-9-_:]");
    function genId() {
      return t1++;
    }
    let t3 = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
    let t5 = /^(?:[a-z+]+:)?\/\//i;
    let t6 = /^www\..*/i;
    let t4 = /^(data:)([^,]*),(.*)/i;
    function absoluteToStylesheet(m, _) {
      return (m || "").replace(t3, (m, C, R, L, B, F) => {
        let U = R || B || F;
        let H = C || L || "";
        if (!U) {
          return m;
        }
        if (t5.test(U) || t6.test(U) || t4.test(U)) {
          return `url(${H}${U}${H})`;
        }
        if (U[0] === "/") {
          return `url(${H}${(_.indexOf("//") > -1 ? _.split("/").slice(0, 3).join("/") : _.split("/")[0]).split("?")[0] + U}${H})`;
        }
        let q = _.split("/");
        let V = U.split("/");
        q.pop();
        for (let m of V) {
          if (m !== ".") {
            if (m === "..") {
              q.pop();
            } else {
              q.push(m);
            }
          }
        }
        return `url(${H}${q.join("/")}${H})`;
      });
    }
    let t8 = /^[^ \t\n\r\u000c]+/;
    let t9 = /^[, \t\n\r\u000c]+/;
    let t7 = new WeakMap();
    function absoluteToDoc(m, _) {
      if (_ && _.trim() !== "") {
        return getHref(m, _);
      } else {
        return _;
      }
    }
    function getHref(m, _) {
      let C = t7.get(m);
      if (!C) {
        C = m.createElement("a");
        t7.set(m, C);
      }
      if (_) {
        if (_.startsWith("blob:") || _.startsWith("data:")) {
          return _;
        }
      } else {
        _ = "";
      }
      C.setAttribute("href", _);
      return C.href;
    }
    function transformAttribute(m, _, C, R, L, B) {
      if (R) {
        if (C !== "src" && (C !== "href" || _ === "use" && R[0] === "#") && (C !== "xlink:href" || R[0] === "#") && (C !== "background" || _ !== "table" && _ !== "td" && _ !== "th")) {
          if (C === "srcset") {
            return function (m, _) {
              if (_.trim() === "") {
                return _;
              }
              let C = 0;
              function collectCharacters(m) {
                let R;
                let L = m.exec(_.substring(C));
                if (L) {
                  R = L[0];
                  C += R.length;
                  return R;
                } else {
                  return "";
                }
              }
              let R = [];
              while (collectCharacters(t9), !(C >= _.length)) {
                let L = collectCharacters(t8);
                if (L.slice(-1) === ",") {
                  L = absoluteToDoc(m, L.substring(0, L.length - 1));
                  R.push(L);
                } else {
                  let B = "";
                  L = absoluteToDoc(m, L);
                  let F = false;
                  while (true) {
                    let m = _.charAt(C);
                    if (m === "") {
                      R.push((L + B).trim());
                      break;
                    }
                    if (F) {
                      if (m === ")") {
                        F = false;
                      }
                    } else {
                      if (m === ",") {
                        C += 1;
                        R.push((L + B).trim());
                        break;
                      }
                      if (m === "(") {
                        F = true;
                      }
                    }
                    B += m;
                    C += 1;
                  }
                }
              }
              return R.join(", ");
            }(m, R);
          } else if (C === "style") {
            return absoluteToStylesheet(R, getHref(m));
          } else if (_ === "object" && C === "data") {
            return absoluteToDoc(m, R);
          } else if (typeof B == "function") {
            return B(C, R, L);
          } else {
            return R;
          }
        } else {
          return absoluteToDoc(m, R);
        }
      } else {
        return R;
      }
    }
    function ignoreAttribute(m, _, C) {
      return (m === "video" || m === "audio") && _ === "autoplay";
    }
    function distanceToMatch(m, _, C = Infinity, R = 0) {
      if (!m || m.nodeType !== m.ELEMENT_NODE || R > C) {
        return -1;
      } else if (_(m)) {
        return R;
      } else {
        return distanceToMatch(m.parentNode, _, C, R + 1);
      }
    }
    function createMatchPredicate(m, _) {
      return C => {
        if (C === null) {
          return false;
        }
        try {
          if (m) {
            if (typeof m == "string") {
              if (C.matches(`.${m}`)) {
                return true;
              }
            } else if (function (m, _) {
              for (let C = m.classList.length; C--;) {
                let R = m.classList[C];
                if (_.test(R)) {
                  return true;
                }
              }
              return false;
            }(C, m)) {
              return true;
            }
          }
          if (_ && C.matches(_)) {
            return true;
          }
          return false;
        } catch (m) {
          return false;
        }
      };
    }
    function needMaskingText(m, _, C, R, L, B) {
      try {
        let F = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
        if (F === null) {
          return false;
        }
        if (F.tagName === "INPUT") {
          let m = F.getAttribute("autocomplete");
          if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(m)) {
            return true;
          }
        }
        let U = -1;
        let H = -1;
        if (B) {
          if ((H = distanceToMatch(F, createMatchPredicate(R, L))) < 0) {
            return true;
          }
          U = distanceToMatch(F, createMatchPredicate(_, C), H >= 0 ? H : Infinity);
        } else {
          if ((U = distanceToMatch(F, createMatchPredicate(_, C))) < 0) {
            return false;
          }
          H = distanceToMatch(F, createMatchPredicate(R, L), U >= 0 ? U : Infinity);
        }
        if (U >= 0) {
          return !(H >= 0) || U <= H;
        } else {
          return !(H >= 0) && !!B;
        }
      } catch (m) {}
      return !!B;
    }
    function lowerIfExists(m) {
      if (m == null) {
        return "";
      } else {
        return m.toLowerCase();
      }
    }
    function serializeNodeWithId(m, _) {
      let C;
      let {
        doc: R,
        mirror: L,
        blockClass: B,
        blockSelector: F,
        unblockSelector: U,
        maskAllText: H,
        maskTextClass: q,
        unmaskTextClass: V,
        maskTextSelector: X,
        unmaskTextSelector: K,
        skipChild: Y = false,
        inlineStylesheet: Q = true,
        maskInputOptions: et = {},
        maskAttributeFn: ei,
        maskTextFn: eo,
        maskInputFn: ea,
        slimDOMOptions: es,
        dataURLOptions: ec = {},
        inlineImages: el = false,
        recordCanvas: eu = false,
        onSerialize: ed,
        onIframeLoad: ep,
        iframeLoadTimeout: eh = 5000,
        onStylesheetLoad: ef,
        stylesheetLoadTimeout: eg = 5000,
        keepIframeSrcFn: ey = () => false,
        newlyAddedElement: e_ = false
      } = _;
      let {
        preserveWhiteSpace: ev = true
      } = _;
      let eb = function (m, _) {
        let {
          doc: C,
          mirror: R,
          blockClass: L,
          blockSelector: B,
          unblockSelector: F,
          maskAllText: U,
          maskAttributeFn: H,
          maskTextClass: q,
          unmaskTextClass: V,
          maskTextSelector: X,
          unmaskTextSelector: K,
          inlineStylesheet: Y,
          maskInputOptions: Q = {},
          maskTextFn: et,
          maskInputFn: ei,
          dataURLOptions: eo = {},
          inlineImages: ea,
          recordCanvas: es,
          keepIframeSrcFn: ec,
          newlyAddedElement: el = false
        } = _;
        let eu = function (m, _) {
          if (!_.hasNode(m)) {
            return;
          }
          let C = _.getId(m);
          if (C === 1) {
            return undefined;
          } else {
            return C;
          }
        }(C, R);
        switch (m.nodeType) {
          case m.DOCUMENT_NODE:
            if (m.compatMode !== "CSS1Compat") {
              return {
                type: em.Document,
                childNodes: [],
                compatMode: m.compatMode
              };
            }
            return {
              type: em.Document,
              childNodes: []
            };
          case m.DOCUMENT_TYPE_NODE:
            return {
              type: em.DocumentType,
              name: m.name,
              publicId: m.publicId,
              systemId: m.systemId,
              rootId: eu
            };
          case m.ELEMENT_NODE:
            return function (m, _) {
              let C;
              let {
                doc: R,
                blockClass: L,
                blockSelector: B,
                unblockSelector: F,
                inlineStylesheet: U,
                maskInputOptions: H = {},
                maskAttributeFn: q,
                maskInputFn: V,
                dataURLOptions: X = {},
                inlineImages: K,
                recordCanvas: Y,
                keepIframeSrcFn: Q,
                newlyAddedElement: et = false,
                rootId: ei,
                maskAllText: eo,
                maskTextClass: ea,
                unmaskTextClass: es,
                maskTextSelector: ec,
                unmaskTextSelector: el
              } = _;
              let eu = function (m, _, C, R) {
                try {
                  if (R && m.matches(R)) {
                    return false;
                  }
                  if (typeof _ == "string") {
                    if (m.classList.contains(_)) {
                      return true;
                    }
                  } else {
                    for (let C = m.classList.length; C--;) {
                      let R = m.classList[C];
                      if (_.test(R)) {
                        return true;
                      }
                    }
                  }
                  if (C) {
                    return m.matches(C);
                  }
                } catch (m) {}
                return false;
              }(m, L, B, F);
              let ed = function (m) {
                if (m instanceof HTMLFormElement) {
                  return "form";
                }
                let _ = toLowerCase(m.tagName);
                if (t2.test(_)) {
                  return "div";
                } else {
                  return _;
                }
              }(m);
              let ep = {};
              let eh = m.attributes.length;
              for (let _ = 0; _ < eh; _++) {
                let C = m.attributes[_];
                if (C.name && !ignoreAttribute(ed, C.name, C.value)) {
                  ep[C.name] = transformAttribute(R, ed, toLowerCase(C.name), C.value, m, q);
                }
              }
              if (ed === "link" && U) {
                let _ = Array.from(R.styleSheets).find(_ => _.href === m.href);
                let C = null;
                if (_) {
                  C = stringifyStylesheet(_);
                }
                if (C) {
                  delete ep.rel;
                  delete ep.href;
                  ep._cssText = absoluteToStylesheet(C, _.href);
                }
              }
              if (ed === "style" && m.sheet && !(m.innerText || m.textContent || "").trim().length) {
                let _ = stringifyStylesheet(m.sheet);
                if (_) {
                  ep._cssText = absoluteToStylesheet(_, getHref(R));
                }
              }
              if (ed === "input" || ed === "textarea" || ed === "select" || ed === "option") {
                let _ = getInputType(m);
                let C = getInputValue(m, toUpperCase(ed), _);
                let R = m.checked;
                if (_ !== "submit" && _ !== "button" && C) {
                  let R = needMaskingText(m, ea, ec, es, el, shouldMaskInput({
                    type: _,
                    tagName: toUpperCase(ed),
                    maskInputOptions: H
                  }));
                  ep.value = maskInputValue({
                    isMasked: R,
                    element: m,
                    value: C,
                    maskInputFn: V
                  });
                }
                if (R) {
                  ep.checked = R;
                }
              }
              if (ed === "option") {
                if (m.selected && !H.select) {
                  ep.selected = true;
                } else {
                  delete ep.selected;
                }
              }
              if (ed === "canvas" && Y) {
                if (m.__context === "2d") {
                  if (!function (m) {
                    let _ = m.getContext("2d");
                    if (!_) {
                      return true;
                    }
                    for (let C = 0; C < m.width; C += 50) {
                      for (let R = 0; R < m.height; R += 50) {
                        let L = _.getImageData;
                        let B = tQ in L ? L[tQ] : L;
                        let F = new Uint32Array(B.call(_, C, R, Math.min(50, m.width - C), Math.min(50, m.height - R)).data.buffer);
                        if (F.some(m => m !== 0)) {
                          return false;
                        }
                      }
                    }
                    return true;
                  }(m)) {
                    ep.rr_dataURL = m.toDataURL(X.type, X.quality);
                  }
                } else if (!("__context" in m)) {
                  let _ = m.toDataURL(X.type, X.quality);
                  let C = R.createElement("canvas");
                  C.width = m.width;
                  C.height = m.height;
                  let L = C.toDataURL(X.type, X.quality);
                  if (_ !== L) {
                    ep.rr_dataURL = _;
                  }
                }
              }
              if (ed === "img" && K) {
                if (!er) {
                  en = (er = R.createElement("canvas")).getContext("2d");
                }
                let _ = m.currentSrc || m.getAttribute("src") || "<unknown-src>";
                let C = m.crossOrigin;
                let recordInlineImage = () => {
                  m.removeEventListener("load", recordInlineImage);
                  try {
                    er.width = m.naturalWidth;
                    er.height = m.naturalHeight;
                    en.drawImage(m, 0, 0);
                    ep.rr_dataURL = er.toDataURL(X.type, X.quality);
                  } catch (C) {
                    if (m.crossOrigin !== "anonymous") {
                      m.crossOrigin = "anonymous";
                      if (m.complete && m.naturalWidth !== 0) {
                        recordInlineImage();
                      } else {
                        m.addEventListener("load", recordInlineImage);
                      }
                      return;
                    }
                    console.warn(`Cannot inline img src=${_}! Error: ${C}`);
                  }
                  if (m.crossOrigin === "anonymous") {
                    if (C) {
                      ep.crossOrigin = C;
                    } else {
                      m.removeAttribute("crossorigin");
                    }
                  }
                };
                if (m.complete && m.naturalWidth !== 0) {
                  recordInlineImage();
                } else {
                  m.addEventListener("load", recordInlineImage);
                }
              }
              if (ed === "audio" || ed === "video") {
                ep.rr_mediaState = m.paused ? "paused" : "played";
                ep.rr_mediaCurrentTime = m.currentTime;
              }
              if (!et) {
                if (m.scrollLeft) {
                  ep.rr_scrollLeft = m.scrollLeft;
                }
                if (m.scrollTop) {
                  ep.rr_scrollTop = m.scrollTop;
                }
              }
              if (eu) {
                let {
                  width: _,
                  height: C
                } = m.getBoundingClientRect();
                ep = {
                  class: ep.class,
                  rr_width: `${_}px`,
                  rr_height: `${C}px`
                };
              }
              if (ed === "iframe" && !Q(ep.src)) {
                if (!eu && !m.contentDocument) {
                  ep.rr_src = ep.src;
                }
                delete ep.src;
              }
              try {
                if (customElements.get(ed)) {
                  C = true;
                }
              } catch (m) {}
              return {
                type: em.Element,
                tagName: ed,
                attributes: ep,
                childNodes: [],
                isSVG: m.tagName === "svg" || !!m.ownerSVGElement || undefined,
                needBlock: eu,
                rootId: ei,
                isCustom: C
              };
            }(m, {
              doc: C,
              blockClass: L,
              blockSelector: B,
              unblockSelector: F,
              inlineStylesheet: Y,
              maskAttributeFn: H,
              maskInputOptions: Q,
              maskInputFn: ei,
              dataURLOptions: eo,
              inlineImages: ea,
              recordCanvas: es,
              keepIframeSrcFn: ec,
              newlyAddedElement: el,
              rootId: eu,
              maskAllText: U,
              maskTextClass: q,
              unmaskTextClass: V,
              maskTextSelector: X,
              unmaskTextSelector: K
            });
          case m.TEXT_NODE:
            return function (m, _) {
              let {
                maskAllText: C,
                maskTextClass: R,
                unmaskTextClass: L,
                maskTextSelector: B,
                unmaskTextSelector: F,
                maskTextFn: U,
                maskInputOptions: H,
                maskInputFn: q,
                rootId: V
              } = _;
              let X = m.parentNode && m.parentNode.tagName;
              let K = m.textContent;
              let Y = X === "STYLE" || undefined;
              let Q = X === "SCRIPT" || undefined;
              let et = X === "TEXTAREA" || undefined;
              if (Y && K) {
                try {
                  if (!m.nextSibling && !m.previousSibling) {
                    if (_optionalChain$5([m, "access", m => m.parentNode, "access", m => m.sheet, "optionalAccess", m => m.cssRules])) {
                      K = stringifyStylesheet(m.parentNode.sheet);
                    }
                  }
                } catch (_) {
                  console.warn(`Cannot get CSS styles from text's parentNode. Error: ${_}`, m);
                }
                K = absoluteToStylesheet(K, getHref(_.doc));
              }
              if (Q) {
                K = "SCRIPT_PLACEHOLDER";
              }
              let er = needMaskingText(m, R, B, L, F, C);
              if (!Y && !Q && !et && !!K && !!er) {
                K = U ? U(K, m.parentElement) : K.replace(/[\S]/g, "*");
              }
              if (et && K && (H.textarea || er)) {
                K = q ? q(K, m.parentNode) : K.replace(/[\S]/g, "*");
              }
              if (X === "OPTION" && K) {
                let _ = shouldMaskInput({
                  type: null,
                  tagName: X,
                  maskInputOptions: H
                });
                K = maskInputValue({
                  isMasked: needMaskingText(m, R, B, L, F, _),
                  element: m,
                  value: K,
                  maskInputFn: q
                });
              }
              return {
                type: em.Text,
                textContent: K || "",
                isStyle: Y,
                rootId: V
              };
            }(m, {
              doc: C,
              maskAllText: U,
              maskTextClass: q,
              unmaskTextClass: V,
              maskTextSelector: X,
              unmaskTextSelector: K,
              maskTextFn: et,
              maskInputOptions: Q,
              maskInputFn: ei,
              rootId: eu
            });
          case m.CDATA_SECTION_NODE:
            return {
              type: em.CDATA,
              textContent: "",
              rootId: eu
            };
          case m.COMMENT_NODE:
            return {
              type: em.Comment,
              textContent: m.textContent || "",
              rootId: eu
            };
          default:
            return false;
        }
      }(m, {
        doc: R,
        mirror: L,
        blockClass: B,
        blockSelector: F,
        maskAllText: H,
        unblockSelector: U,
        maskTextClass: q,
        unmaskTextClass: V,
        maskTextSelector: X,
        unmaskTextSelector: K,
        inlineStylesheet: Q,
        maskInputOptions: et,
        maskAttributeFn: ei,
        maskTextFn: eo,
        maskInputFn: ea,
        dataURLOptions: ec,
        inlineImages: el,
        recordCanvas: eu,
        keepIframeSrcFn: ey,
        newlyAddedElement: e_
      });
      if (!eb) {
        console.warn(m, "not serialized");
        return null;
      }
      C = L.hasNode(m) ? L.getId(m) : !function (m, _) {
        if (_.comment && m.type === em.Comment) {
          return true;
        }
        if (m.type === em.Element) {
          if (_.script && (m.tagName === "script" || m.tagName === "link" && (m.attributes.rel === "preload" || m.attributes.rel === "modulepreload") && m.attributes.as === "script" || m.tagName === "link" && m.attributes.rel === "prefetch" && typeof m.attributes.href == "string" && extractFileExtension(m.attributes.href) === "js") || _.headFavicon && (m.tagName === "link" && m.attributes.rel === "shortcut icon" || m.tagName === "meta" && (lowerIfExists(m.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(m.attributes.name) === "application-name" || lowerIfExists(m.attributes.rel) === "icon" || lowerIfExists(m.attributes.rel) === "apple-touch-icon" || lowerIfExists(m.attributes.rel) === "shortcut icon"))) {
            return true;
          }
          if (m.tagName === "meta") {
            if (_.headMetaDescKeywords && lowerIfExists(m.attributes.name).match(/^description|keywords$/) || _.headMetaSocial && (lowerIfExists(m.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(m.attributes.name).match(/^(og|twitter):/) || lowerIfExists(m.attributes.name) === "pinterest")) {
              return true;
            }
            if (_.headMetaRobots && (lowerIfExists(m.attributes.name) === "robots" || lowerIfExists(m.attributes.name) === "googlebot" || lowerIfExists(m.attributes.name) === "bingbot")) {
              return true;
            }
            if (_.headMetaHttpEquiv && m.attributes["http-equiv"] !== undefined) {
              return true;
            } else if (_.headMetaAuthorship && (lowerIfExists(m.attributes.name) === "author" || lowerIfExists(m.attributes.name) === "generator" || lowerIfExists(m.attributes.name) === "framework" || lowerIfExists(m.attributes.name) === "publisher" || lowerIfExists(m.attributes.name) === "progid" || lowerIfExists(m.attributes.property).match(/^article:/) || lowerIfExists(m.attributes.property).match(/^product:/))) {
              return true;
            } else if (_.headMetaVerification && (lowerIfExists(m.attributes.name) === "google-site-verification" || lowerIfExists(m.attributes.name) === "yandex-verification" || lowerIfExists(m.attributes.name) === "csrf-token" || lowerIfExists(m.attributes.name) === "p:domain_verify" || lowerIfExists(m.attributes.name) === "verify-v1" || lowerIfExists(m.attributes.name) === "verification" || lowerIfExists(m.attributes.name) === "shopify-checkout-api-token")) {
              return true;
            }
          }
        }
        return false;
      }(eb, es) && (ev || eb.type !== em.Text || eb.isStyle || eb.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : -2;
      let eS = Object.assign(eb, {
        id: C
      });
      L.add(m, eS);
      if (C === -2) {
        return null;
      }
      if (ed) {
        ed(m);
      }
      let ew = !Y;
      if (eS.type === em.Element) {
        ew = ew && !eS.needBlock;
        delete eS.needBlock;
        let _ = m.shadowRoot;
        if (_ && isNativeShadowDom(_)) {
          eS.isShadowHost = true;
        }
      }
      if ((eS.type === em.Document || eS.type === em.Element) && ew) {
        if (es.headWhitespace && eS.type === em.Element && eS.tagName === "head") {
          ev = false;
        }
        let _ = {
          doc: R,
          mirror: L,
          blockClass: B,
          blockSelector: F,
          maskAllText: H,
          unblockSelector: U,
          maskTextClass: q,
          unmaskTextClass: V,
          maskTextSelector: X,
          unmaskTextSelector: K,
          skipChild: Y,
          inlineStylesheet: Q,
          maskInputOptions: et,
          maskAttributeFn: ei,
          maskTextFn: eo,
          maskInputFn: ea,
          slimDOMOptions: es,
          dataURLOptions: ec,
          inlineImages: el,
          recordCanvas: eu,
          preserveWhiteSpace: ev,
          onSerialize: ed,
          onIframeLoad: ep,
          iframeLoadTimeout: eh,
          onStylesheetLoad: ef,
          stylesheetLoadTimeout: eg,
          keepIframeSrcFn: ey
        };
        for (let C of Array.from(m.childNodes)) {
          let m = serializeNodeWithId(C, _);
          if (m) {
            eS.childNodes.push(m);
          }
        }
        if (m.nodeType === m.ELEMENT_NODE && m.shadowRoot) {
          for (let C of Array.from(m.shadowRoot.childNodes)) {
            let R = serializeNodeWithId(C, _);
            if (R) {
              if (isNativeShadowDom(m.shadowRoot)) {
                R.isShadow = true;
              }
              eS.childNodes.push(R);
            }
          }
        }
      }
      if (m.parentNode && isShadowRoot(m.parentNode) && isNativeShadowDom(m.parentNode)) {
        eS.isShadow = true;
      }
      if (eS.type === em.Element && eS.tagName === "iframe") {
        (function (m, _, C) {
          let R;
          let L = m.contentWindow;
          if (!L) {
            return;
          }
          let B = false;
          try {
            R = L.document.readyState;
          } catch (m) {
            return;
          }
          if (R !== "complete") {
            let R = setTimeout$2(() => {
              if (!B) {
                _();
                B = true;
              }
            }, C);
            m.addEventListener("load", () => {
              clearTimeout$2(R);
              B = true;
              _();
            });
            return;
          }
          let F = "about:blank";
          if (L.location.href !== F || m.src === F || m.src === "") {
            setTimeout$2(_, 0);
            return m.addEventListener("load", _);
          }
          m.addEventListener("load", _);
        })(m, () => {
          let _ = m.contentDocument;
          if (_ && ep) {
            let C = serializeNodeWithId(_, {
              doc: _,
              mirror: L,
              blockClass: B,
              blockSelector: F,
              unblockSelector: U,
              maskAllText: H,
              maskTextClass: q,
              unmaskTextClass: V,
              maskTextSelector: X,
              unmaskTextSelector: K,
              skipChild: false,
              inlineStylesheet: Q,
              maskInputOptions: et,
              maskAttributeFn: ei,
              maskTextFn: eo,
              maskInputFn: ea,
              slimDOMOptions: es,
              dataURLOptions: ec,
              inlineImages: el,
              recordCanvas: eu,
              preserveWhiteSpace: ev,
              onSerialize: ed,
              onIframeLoad: ep,
              iframeLoadTimeout: eh,
              onStylesheetLoad: ef,
              stylesheetLoadTimeout: eg,
              keepIframeSrcFn: ey
            });
            if (C) {
              ep(m, C);
            }
          }
        }, eh);
      }
      if (eS.type === em.Element && eS.tagName === "link" && typeof eS.attributes.rel == "string" && (eS.attributes.rel === "stylesheet" || eS.attributes.rel === "preload" && typeof eS.attributes.href == "string" && extractFileExtension(eS.attributes.href) === "css")) {
        (function (m, _, C) {
          let R;
          let L = false;
          try {
            R = m.sheet;
          } catch (m) {
            return;
          }
          if (R) {
            return;
          }
          let B = setTimeout$2(() => {
            if (!L) {
              _();
              L = true;
            }
          }, C);
          m.addEventListener("load", () => {
            clearTimeout$2(B);
            L = true;
            _();
          });
        })(m, () => {
          if (ef) {
            let _ = serializeNodeWithId(m, {
              doc: R,
              mirror: L,
              blockClass: B,
              blockSelector: F,
              unblockSelector: U,
              maskAllText: H,
              maskTextClass: q,
              unmaskTextClass: V,
              maskTextSelector: X,
              unmaskTextSelector: K,
              skipChild: false,
              inlineStylesheet: Q,
              maskInputOptions: et,
              maskAttributeFn: ei,
              maskTextFn: eo,
              maskInputFn: ea,
              slimDOMOptions: es,
              dataURLOptions: ec,
              inlineImages: el,
              recordCanvas: eu,
              preserveWhiteSpace: ev,
              onSerialize: ed,
              onIframeLoad: ep,
              iframeLoadTimeout: eh,
              onStylesheetLoad: ef,
              stylesheetLoadTimeout: eg,
              keepIframeSrcFn: ey
            });
            if (_) {
              ef(m, _);
            }
          }
        }, eg);
      }
      return eS;
    }
    function _optionalChain$4(m) {
      let _;
      let C = m[0];
      let R = 1;
      while (R < m.length) {
        let L = m[R];
        let B = m[R + 1];
        R += 2;
        if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
          return;
        }
        if (L === "access" || L === "optionalAccess") {
          _ = C;
          C = B(C);
        } else if (L === "call" || L === "optionalCall") {
          C = B((...m) => C.call(_, ...m));
          _ = undefined;
        }
      }
      return C;
    }
    function on(m, _, C = document) {
      let R = {
        capture: true,
        passive: true
      };
      C.addEventListener(m, _, R);
      return () => C.removeEventListener(m, _, R);
    }
    let re = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
    let rt = {
      map: {},
      getId: () => {
        console.error(re);
        return -1;
      },
      getNode: () => {
        console.error(re);
        return null;
      },
      removeNodeFromMap() {
        console.error(re);
      },
      has: () => {
        console.error(re);
        return false;
      },
      reset() {
        console.error(re);
      }
    };
    function throttle$1(m, _, C = {}) {
      let R = null;
      let L = 0;
      return function (...B) {
        let F = Date.now();
        if (!L && C.leading === false) {
          L = F;
        }
        let U = _ - (F - L);
        let H = this;
        if (U <= 0 || U > _) {
          if (R) {
            (function (...m) {
              getImplementation("clearTimeout")(...m);
            })(R);
            R = null;
          }
          L = F;
          m.apply(H, B);
        } else if (!R && C.trailing !== false) {
          R = setTimeout$1(() => {
            L = C.leading === false ? 0 : Date.now();
            R = null;
            m.apply(H, B);
          }, U);
        }
      };
    }
    function patch(m, _, C) {
      try {
        if (!(_ in m)) {
          return () => {};
        }
        let R = m[_];
        let L = C(R);
        if (typeof L == "function") {
          L.prototype = L.prototype || {};
          Object.defineProperties(L, {
            __rrweb_original__: {
              enumerable: false,
              value: R
            }
          });
        }
        m[_] = L;
        return () => {
          m[_] = R;
        };
      } catch (m) {
        return () => {};
      }
    }
    if (typeof window != "undefined" && window.Proxy && window.Reflect) {
      rt = new Proxy(rt, {
        get: (m, _, C) => {
          if (_ === "map") {
            console.error(re);
          }
          return Reflect.get(m, _, C);
        }
      });
    }
    let rr = Date.now;
    function getWindowScroll(m) {
      let _ = m.document;
      return {
        left: _.scrollingElement ? _.scrollingElement.scrollLeft : m.pageXOffset !== undefined ? m.pageXOffset : _optionalChain$4([_, "optionalAccess", m => m.documentElement, "access", m => m.scrollLeft]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.parentElement, "optionalAccess", m => m.scrollLeft]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.scrollLeft]) || 0,
        top: _.scrollingElement ? _.scrollingElement.scrollTop : m.pageYOffset !== undefined ? m.pageYOffset : _optionalChain$4([_, "optionalAccess", m => m.documentElement, "access", m => m.scrollTop]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.parentElement, "optionalAccess", m => m.scrollTop]) || _optionalChain$4([_, "optionalAccess", m => m.body, "optionalAccess", m => m.scrollTop]) || 0
      };
    }
    function getWindowHeight() {
      return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
    }
    function getWindowWidth() {
      return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
    }
    function closestElementOfNode(m) {
      if (!m) {
        return null;
      }
      let _ = m.nodeType === m.ELEMENT_NODE ? m : m.parentElement;
      return _;
    }
    function isBlocked(m, _, C, R, L) {
      if (!m) {
        return false;
      }
      let B = closestElementOfNode(m);
      if (!B) {
        return false;
      }
      let F = createMatchPredicate(_, C);
      if (!L) {
        let m = R && B.matches(R);
        return F(B) && !m;
      }
      let U = distanceToMatch(B, F);
      let H = -1;
      return !(U < 0) && (R && (H = distanceToMatch(B, createMatchPredicate(null, R))), U > -1 && H < 0 || U < H);
    }
    function isIgnored(m, _) {
      return _.getId(m) === -2;
    }
    function legacy_isTouchEvent(m) {
      return !!m.changedTouches;
    }
    function isSerializedIframe(m, _) {
      return m.nodeName === "IFRAME" && !!_.getMeta(m);
    }
    function isSerializedStylesheet(m, _) {
      return m.nodeName === "LINK" && m.nodeType === m.ELEMENT_NODE && !!m.getAttribute && m.getAttribute("rel") === "stylesheet" && !!_.getMeta(m);
    }
    function hasShadowRoot(m) {
      return !!_optionalChain$4([m, "optionalAccess", m => m.shadowRoot]);
    }
    if (!/[1-9][0-9]{12}/.test(Date.now().toString())) {
      rr = () => new Date().getTime();
    }
    let StyleSheetMirror = class StyleSheetMirror {
      constructor() {
        this.id = 1;
        this.styleIDMap = new WeakMap();
        this.idStyleMap = new Map();
      }
      getId(m) {
        var _;
        _ = this.styleIDMap.get(m);
        return _ ?? -1;
      }
      has(m) {
        return this.styleIDMap.has(m);
      }
      add(m, _) {
        let C;
        if (this.has(m)) {
          return this.getId(m);
        } else {
          C = _ === undefined ? this.id++ : _;
          this.styleIDMap.set(m, C);
          this.idStyleMap.set(C, m);
          return C;
        }
      }
      getStyle(m) {
        return this.idStyleMap.get(m) || null;
      }
      reset() {
        this.styleIDMap = new WeakMap();
        this.idStyleMap = new Map();
        this.id = 1;
      }
      generateId() {
        return this.id++;
      }
    };
    function getShadowHost(m) {
      let _ = null;
      if (_optionalChain$4([m, "access", m => m.getRootNode, "optionalCall", m => m(), "optionalAccess", m => m.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && m.getRootNode().host) {
        _ = m.getRootNode().host;
      }
      return _;
    }
    function inDom(m) {
      let _ = m.ownerDocument;
      return !!_ && (_.contains(m) || function (m) {
        let _ = m.ownerDocument;
        if (!_) {
          return false;
        }
        let C = function (m) {
          let _;
          let C = m;
          while (_ = getShadowHost(C)) {
            C = _;
          }
          return C;
        }(m);
        return _.contains(C);
      }(m));
    }
    let rn = {};
    function getImplementation(m) {
      let _ = rn[m];
      if (_) {
        return _;
      }
      let C = window.document;
      let R = window[m];
      if (C && typeof C.createElement == "function") {
        try {
          let _ = C.createElement("iframe");
          _.hidden = true;
          C.head.appendChild(_);
          let L = _.contentWindow;
          if (L && L[m]) {
            R = L[m];
          }
          C.head.removeChild(_);
        } catch (m) {}
      }
      return rn[m] = R.bind(window);
    }
    function setTimeout$1(...m) {
      return getImplementation("setTimeout")(...m);
    }
    (el = ri || {})[el.DomContentLoaded = 0] = "DomContentLoaded";
    el[el.Load = 1] = "Load";
    el[el.FullSnapshot = 2] = "FullSnapshot";
    el[el.IncrementalSnapshot = 3] = "IncrementalSnapshot";
    el[el.Meta = 4] = "Meta";
    el[el.Custom = 5] = "Custom";
    el[el.Plugin = 6] = "Plugin";
    var ri = el;
    (eu = ro || {})[eu.Mutation = 0] = "Mutation";
    eu[eu.MouseMove = 1] = "MouseMove";
    eu[eu.MouseInteraction = 2] = "MouseInteraction";
    eu[eu.Scroll = 3] = "Scroll";
    eu[eu.ViewportResize = 4] = "ViewportResize";
    eu[eu.Input = 5] = "Input";
    eu[eu.TouchMove = 6] = "TouchMove";
    eu[eu.MediaInteraction = 7] = "MediaInteraction";
    eu[eu.StyleSheetRule = 8] = "StyleSheetRule";
    eu[eu.CanvasMutation = 9] = "CanvasMutation";
    eu[eu.Font = 10] = "Font";
    eu[eu.Log = 11] = "Log";
    eu[eu.Drag = 12] = "Drag";
    eu[eu.StyleDeclaration = 13] = "StyleDeclaration";
    eu[eu.Selection = 14] = "Selection";
    eu[eu.AdoptedStyleSheet = 15] = "AdoptedStyleSheet";
    eu[eu.CustomElement = 16] = "CustomElement";
    var ro = eu;
    (ed = ra || {})[ed.MouseUp = 0] = "MouseUp";
    ed[ed.MouseDown = 1] = "MouseDown";
    ed[ed.Click = 2] = "Click";
    ed[ed.ContextMenu = 3] = "ContextMenu";
    ed[ed.DblClick = 4] = "DblClick";
    ed[ed.Focus = 5] = "Focus";
    ed[ed.Blur = 6] = "Blur";
    ed[ed.TouchStart = 7] = "TouchStart";
    ed[ed.TouchMove_Departed = 8] = "TouchMove_Departed";
    ed[ed.TouchEnd = 9] = "TouchEnd";
    ed[ed.TouchCancel = 10] = "TouchCancel";
    var ra = ed;
    (ep = rs || {})[ep.Mouse = 0] = "Mouse";
    ep[ep.Pen = 1] = "Pen";
    ep[ep.Touch = 2] = "Touch";
    var rs = ep;
    let DoubleLinkedList = class DoubleLinkedList {
      constructor() {
        this.length = 0;
        this.head = null;
        this.tail = null;
      }
      get(m) {
        if (m >= this.length) {
          throw Error("Position outside of list range");
        }
        let _ = this.head;
        for (let C = 0; C < m; C++) {
          _ = function (m) {
            let _;
            let C = m[0];
            let R = 1;
            while (R < m.length) {
              let L = m[R];
              let B = m[R + 1];
              R += 2;
              if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
                return;
              }
              if (L === "access" || L === "optionalAccess") {
                _ = C;
                C = B(C);
              } else if (L === "call" || L === "optionalCall") {
                C = B((...m) => C.call(_, ...m));
                _ = undefined;
              }
            }
            return C;
          }([_, "optionalAccess", m => m.next]) || null;
        }
        return _;
      }
      addNode(m) {
        let _ = {
          value: m,
          previous: null,
          next: null
        };
        m.__ln = _;
        if (m.previousSibling && "__ln" in m.previousSibling) {
          let C = m.previousSibling.__ln.next;
          _.next = C;
          _.previous = m.previousSibling.__ln;
          m.previousSibling.__ln.next = _;
          if (C) {
            C.previous = _;
          }
        } else if (m.nextSibling && "__ln" in m.nextSibling && m.nextSibling.__ln.previous) {
          let C = m.nextSibling.__ln.previous;
          _.previous = C;
          _.next = m.nextSibling.__ln;
          m.nextSibling.__ln.previous = _;
          if (C) {
            C.next = _;
          }
        } else {
          if (this.head) {
            this.head.previous = _;
          }
          _.next = this.head;
          this.head = _;
        }
        if (_.next === null) {
          this.tail = _;
        }
        this.length++;
      }
      removeNode(m) {
        let _ = m.__ln;
        if (this.head) {
          if (_.previous) {
            _.previous.next = _.next;
            if (_.next) {
              _.next.previous = _.previous;
            } else {
              this.tail = _.previous;
            }
          } else {
            this.head = _.next;
            if (this.head) {
              this.head.previous = null;
            } else {
              this.tail = null;
            }
          }
          if (m.__ln) {
            delete m.__ln;
          }
          this.length--;
        }
      }
    };
    let moveKey = (m, _) => `${m}@${_}`;
    let MutationBuffer = class MutationBuffer {
      constructor() {
        this.frozen = false;
        this.locked = false;
        this.texts = [];
        this.attributes = [];
        this.attributeMap = new WeakMap();
        this.removes = [];
        this.mapRemoves = [];
        this.movedMap = {};
        this.addedSet = new Set();
        this.movedSet = new Set();
        this.droppedSet = new Set();
        this.processMutations = m => {
          m.forEach(this.processMutation);
          this.emit();
        };
        this.emit = () => {
          if (this.frozen || this.locked) {
            return;
          }
          let m = [];
          let _ = new Set();
          let C = new DoubleLinkedList();
          let getNextId = m => {
            let _ = m;
            let C = -2;
            while (C === -2) {
              C = (_ = _ && _.nextSibling) && this.mirror.getId(_);
            }
            return C;
          };
          let pushAdd = R => {
            if (!R.parentNode || !inDom(R)) {
              return;
            }
            let L = isShadowRoot(R.parentNode) ? this.mirror.getId(getShadowHost(R)) : this.mirror.getId(R.parentNode);
            let B = getNextId(R);
            if (L === -1 || B === -1) {
              return C.addNode(R);
            }
            let F = serializeNodeWithId(R, {
              doc: this.doc,
              mirror: this.mirror,
              blockClass: this.blockClass,
              blockSelector: this.blockSelector,
              maskAllText: this.maskAllText,
              unblockSelector: this.unblockSelector,
              maskTextClass: this.maskTextClass,
              unmaskTextClass: this.unmaskTextClass,
              maskTextSelector: this.maskTextSelector,
              unmaskTextSelector: this.unmaskTextSelector,
              skipChild: true,
              newlyAddedElement: true,
              inlineStylesheet: this.inlineStylesheet,
              maskInputOptions: this.maskInputOptions,
              maskAttributeFn: this.maskAttributeFn,
              maskTextFn: this.maskTextFn,
              maskInputFn: this.maskInputFn,
              slimDOMOptions: this.slimDOMOptions,
              dataURLOptions: this.dataURLOptions,
              recordCanvas: this.recordCanvas,
              inlineImages: this.inlineImages,
              onSerialize: m => {
                if (isSerializedIframe(m, this.mirror) && !isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, false)) {
                  this.iframeManager.addIframe(m);
                }
                if (isSerializedStylesheet(m, this.mirror)) {
                  this.stylesheetManager.trackLinkElement(m);
                }
                if (hasShadowRoot(R)) {
                  this.shadowDomManager.addShadowRoot(R.shadowRoot, this.doc);
                }
              },
              onIframeLoad: (m, _) => {
                if (!isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, false)) {
                  this.iframeManager.attachIframe(m, _);
                  if (m.contentWindow) {
                    this.canvasManager.addWindow(m.contentWindow);
                  }
                  this.shadowDomManager.observeAttachShadow(m);
                }
              },
              onStylesheetLoad: (m, _) => {
                this.stylesheetManager.attachLinkElement(m, _);
              }
            });
            if (F) {
              m.push({
                parentId: L,
                nextId: B,
                node: F
              });
              _.add(F.id);
            }
          };
          while (this.mapRemoves.length) {
            this.mirror.removeNodeFromMap(this.mapRemoves.shift());
          }
          for (let m of this.movedSet) {
            if (!isParentRemoved(this.removes, m, this.mirror) || this.movedSet.has(m.parentNode)) {
              pushAdd(m);
            }
          }
          for (let m of this.addedSet) {
            if (isAncestorInSet(this.droppedSet, m) || isParentRemoved(this.removes, m, this.mirror)) {
              if (isAncestorInSet(this.movedSet, m)) {
                pushAdd(m);
              } else {
                this.droppedSet.add(m);
              }
            } else {
              pushAdd(m);
            }
          }
          let R = null;
          while (C.length) {
            let m = null;
            if (R) {
              let _ = this.mirror.getId(R.value.parentNode);
              let C = getNextId(R.value);
              if (_ !== -1 && C !== -1) {
                m = R;
              }
            }
            if (!m) {
              let _ = C.tail;
              while (_) {
                let C = _;
                _ = _.previous;
                if (C) {
                  let _ = this.mirror.getId(C.value.parentNode);
                  let R = getNextId(C.value);
                  if (R === -1) {
                    continue;
                  }
                  if (_ !== -1) {
                    m = C;
                    break;
                  }
                  {
                    let _ = C.value;
                    if (_.parentNode && _.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      let R = _.parentNode.host;
                      let L = this.mirror.getId(R);
                      if (L !== -1) {
                        m = C;
                        break;
                      }
                    }
                  }
                }
              }
            }
            if (!m) {
              while (C.head) {
                C.removeNode(C.head.value);
              }
              break;
            }
            R = m.previous;
            C.removeNode(m.value);
            pushAdd(m.value);
          }
          let L = {
            texts: this.texts.map(m => ({
              id: this.mirror.getId(m.node),
              value: m.value
            })).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
            attributes: this.attributes.map(m => {
              let {
                attributes: _
              } = m;
              if (typeof _.style == "string") {
                let C = JSON.stringify(m.styleDiff);
                let R = JSON.stringify(m._unchangedStyles);
                if (C.length < _.style.length && (C + R).split("var(").length === _.style.split("var(").length) {
                  _.style = m.styleDiff;
                }
              }
              return {
                id: this.mirror.getId(m.node),
                attributes: _
              };
            }).filter(m => !_.has(m.id)).filter(m => this.mirror.has(m.id)),
            removes: this.removes,
            adds: m
          };
          if (L.texts.length || L.attributes.length || L.removes.length || L.adds.length) {
            this.texts = [];
            this.attributes = [];
            this.attributeMap = new WeakMap();
            this.removes = [];
            this.addedSet = new Set();
            this.movedSet = new Set();
            this.droppedSet = new Set();
            this.movedMap = {};
            this.mutationCb(L);
          }
        };
        this.processMutation = m => {
          if (!isIgnored(m.target, this.mirror)) {
            switch (m.type) {
              case "characterData":
                {
                  let _ = m.target.textContent;
                  if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && _ !== m.oldValue) {
                    this.texts.push({
                      value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && _ ? this.maskTextFn ? this.maskTextFn(_, closestElementOfNode(m.target)) : _.replace(/[\S]/g, "*") : _,
                      node: m.target
                    });
                  }
                  break;
                }
              case "attributes":
                {
                  let _ = m.target;
                  let C = m.attributeName;
                  let R = m.target.getAttribute(C);
                  if (C === "value") {
                    let C = getInputType(_);
                    let L = _.tagName;
                    R = getInputValue(_, L, C);
                    let B = shouldMaskInput({
                      maskInputOptions: this.maskInputOptions,
                      tagName: L,
                      type: C
                    });
                    let F = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, B);
                    R = maskInputValue({
                      isMasked: F,
                      element: _,
                      value: R,
                      maskInputFn: this.maskInputFn
                    });
                  }
                  if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || R === m.oldValue) {
                    return;
                  }
                  let L = this.attributeMap.get(m.target);
                  if (_.tagName === "IFRAME" && C === "src" && !this.keepIframeSrcFn(R)) {
                    if (_.contentDocument) {
                      return;
                    }
                    C = "rr_src";
                  }
                  if (!L) {
                    L = {
                      node: m.target,
                      attributes: {},
                      styleDiff: {},
                      _unchangedStyles: {}
                    };
                    this.attributes.push(L);
                    this.attributeMap.set(m.target, L);
                  }
                  if (C === "type" && _.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
                    _.setAttribute("data-rr-is-password", "true");
                  }
                  if (!ignoreAttribute(_.tagName, C) && (L.attributes[C] = transformAttribute(this.doc, toLowerCase(_.tagName), toLowerCase(C), R, _, this.maskAttributeFn), C === "style")) {
                    if (!this.unattachedDoc) {
                      try {
                        this.unattachedDoc = document.implementation.createHTMLDocument();
                      } catch (m) {
                        this.unattachedDoc = this.doc;
                      }
                    }
                    let C = this.unattachedDoc.createElement("span");
                    if (m.oldValue) {
                      C.setAttribute("style", m.oldValue);
                    }
                    for (let R of Array.from(_.style)) {
                      let m = _.style.getPropertyValue(R);
                      let B = _.style.getPropertyPriority(R);
                      if (m !== C.style.getPropertyValue(R) || B !== C.style.getPropertyPriority(R)) {
                        if (B === "") {
                          L.styleDiff[R] = m;
                        } else {
                          L.styleDiff[R] = [m, B];
                        }
                      } else {
                        L._unchangedStyles[R] = [m, B];
                      }
                    }
                    for (let m of Array.from(C.style)) {
                      if (_.style.getPropertyValue(m) === "") {
                        L.styleDiff[m] = false;
                      }
                    }
                  }
                  break;
                }
              case "childList":
                if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {
                  return;
                }
                m.addedNodes.forEach(_ => this.genAdds(_, m.target));
                m.removedNodes.forEach(_ => {
                  let C = this.mirror.getId(_);
                  let R = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
                  if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && !isIgnored(_, this.mirror) && this.mirror.getId(_) !== -1) {
                    if (this.addedSet.has(_)) {
                      deepDelete(this.addedSet, _);
                      this.droppedSet.add(_);
                    } else if ((!this.addedSet.has(m.target) || C !== -1) && !function isAncestorRemoved(m, _) {
                      if (isShadowRoot(m)) {
                        return false;
                      }
                      let C = _.getId(m);
                      return !_.has(C) || (!m.parentNode || m.parentNode.nodeType !== m.DOCUMENT_NODE) && (!m.parentNode || isAncestorRemoved(m.parentNode, _));
                    }(m.target, this.mirror)) {
                      if (this.movedSet.has(_) && this.movedMap[moveKey(C, R)]) {
                        deepDelete(this.movedSet, _);
                      } else {
                        this.removes.push({
                          parentId: R,
                          id: C,
                          isShadow: !!isShadowRoot(m.target) && !!isNativeShadowDom(m.target) || undefined
                        });
                      }
                    }
                    this.mapRemoves.push(_);
                  }
                });
            }
          }
        };
        this.genAdds = (m, _) => {
          if (!this.processedNodeManager.inOtherBuffer(m, this) && !this.addedSet.has(m) && !this.movedSet.has(m)) {
            if (this.mirror.hasNode(m)) {
              if (isIgnored(m, this.mirror)) {
                return;
              }
              this.movedSet.add(m);
              let C = null;
              if (_ && this.mirror.hasNode(_)) {
                C = this.mirror.getId(_);
              }
              if (C && C !== -1) {
                this.movedMap[moveKey(this.mirror.getId(m), C)] = true;
              }
            } else {
              this.addedSet.add(m);
              this.droppedSet.delete(m);
            }
            if (!isBlocked(m, this.blockClass, this.blockSelector, this.unblockSelector, false)) {
              m.childNodes.forEach(m => this.genAdds(m));
              if (hasShadowRoot(m)) {
                m.shadowRoot.childNodes.forEach(_ => {
                  this.processedNodeManager.add(_, this);
                  this.genAdds(_, m);
                });
              }
            }
          }
        };
      }
      init(m) {
        ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(_ => {
          this[_] = m[_];
        });
      }
      freeze() {
        this.frozen = true;
        this.canvasManager.freeze();
      }
      unfreeze() {
        this.frozen = false;
        this.canvasManager.unfreeze();
        this.emit();
      }
      isFrozen() {
        return this.frozen;
      }
      lock() {
        this.locked = true;
        this.canvasManager.lock();
      }
      unlock() {
        this.locked = false;
        this.canvasManager.unlock();
        this.emit();
      }
      reset() {
        this.shadowDomManager.reset();
        this.canvasManager.reset();
      }
    };
    function deepDelete(m, _) {
      m.delete(_);
      _.childNodes.forEach(_ => deepDelete(m, _));
    }
    function isParentRemoved(m, _, C) {
      return m.length !== 0 && function (m, _, C) {
        let R = _.parentNode;
        while (R) {
          let _ = C.getId(R);
          if (m.some(m => m.id === _)) {
            return true;
          }
          R = R.parentNode;
        }
        return false;
      }(m, _, C);
    }
    function isAncestorInSet(m, _) {
      return m.size !== 0 && function _isAncestorInSet(m, _) {
        let {
          parentNode: C
        } = _;
        return !!C && (!!m.has(C) || _isAncestorInSet(m, C));
      }(m, _);
    }
    let callbackWrapper = m => ei ? (..._) => {
      try {
        return m(..._);
      } catch (m) {
        if (ei && ei(m) === true) {
          return () => {};
        }
        throw m;
      }
    } : m;
    function _optionalChain$2(m) {
      let _;
      let C = m[0];
      let R = 1;
      while (R < m.length) {
        let L = m[R];
        let B = m[R + 1];
        R += 2;
        if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
          return;
        }
        if (L === "access" || L === "optionalAccess") {
          _ = C;
          C = B(C);
        } else if (L === "call" || L === "optionalCall") {
          C = B((...m) => C.call(_, ...m));
          _ = undefined;
        }
      }
      return C;
    }
    let rc = [];
    function esm_getEventTarget(m) {
      try {
        if ("composedPath" in m) {
          let _ = m.composedPath();
          if (_.length) {
            return _[0];
          }
        } else if ("path" in m && m.path.length) {
          return m.path[0];
        }
      } catch (m) {}
      return m && m.target;
    }
    function initMutationObserver(m, _) {
      let C = new MutationBuffer();
      rc.push(C);
      C.init(m);
      let R = window.MutationObserver || window.__rrMutationObserver;
      let L = _optionalChain$2([window, "optionalAccess", m => m.Zone, "optionalAccess", m => m.__symbol__, "optionalCall", m => m("MutationObserver")]);
      if (L && window[L]) {
        R = window[L];
      }
      let B = new R(callbackWrapper(_ => {
        if (!m.onMutation || m.onMutation(_) !== false) {
          C.processMutations.bind(C)(_);
        }
      }));
      B.observe(_, {
        attributes: true,
        attributeOldValue: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true
      });
      return B;
    }
    function initScrollObserver({
      scrollCb: m,
      doc: _,
      mirror: C,
      blockClass: R,
      blockSelector: L,
      unblockSelector: B,
      sampling: F
    }) {
      let U = callbackWrapper(throttle$1(callbackWrapper(F => {
        let U = esm_getEventTarget(F);
        if (!U || isBlocked(U, R, L, B, true)) {
          return;
        }
        let H = C.getId(U);
        if (U === _ && _.defaultView) {
          let C = getWindowScroll(_.defaultView);
          m({
            id: H,
            x: C.left,
            y: C.top
          });
        } else {
          m({
            id: H,
            x: U.scrollLeft,
            y: U.scrollTop
          });
        }
      }), F.scroll || 100));
      return on("scroll", U, _);
    }
    let rl = ["INPUT", "TEXTAREA", "SELECT"];
    let ru = new WeakMap();
    function getNestedCSSRulePositions(m) {
      return function (m, _) {
        if (hasNestedCSSRule("CSSGroupingRule") && m.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && m.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && m.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && m.parentRule instanceof CSSConditionRule) {
          let C = Array.from(m.parentRule.cssRules);
          let R = C.indexOf(m);
          _.unshift(R);
        } else if (m.parentStyleSheet) {
          let C = Array.from(m.parentStyleSheet.cssRules);
          let R = C.indexOf(m);
          _.unshift(R);
        }
        return _;
      }(m, []);
    }
    function getIdAndStyleId(m, _, C) {
      let R;
      let L;
      if (m) {
        if (m.ownerNode) {
          R = _.getId(m.ownerNode);
        } else {
          L = C.getId(m);
        }
        return {
          styleId: L,
          id: R
        };
      } else {
        return {};
      }
    }
    function initAdoptedStyleSheetObserver({
      mirror: m,
      stylesheetManager: _
    }, C) {
      let R = null;
      R = C.nodeName === "#document" ? m.getId(C) : m.getId(C.host);
      let L = C.nodeName === "#document" ? _optionalChain$2([C, "access", m => m.defaultView, "optionalAccess", m => m.Document]) : _optionalChain$2([C, "access", m => m.ownerDocument, "optionalAccess", m => m.defaultView, "optionalAccess", m => m.ShadowRoot]);
      let B = _optionalChain$2([L, "optionalAccess", m => m.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([L, "optionalAccess", m => m.prototype]), "adoptedStyleSheets") : undefined;
      if (R !== null && R !== -1 && L && B) {
        Object.defineProperty(C, "adoptedStyleSheets", {
          configurable: B.configurable,
          enumerable: B.enumerable,
          get() {
            return _optionalChain$2([B, "access", m => m.get, "optionalAccess", m => m.call, "call", m => m(this)]);
          },
          set(m) {
            let C = _optionalChain$2([B, "access", m => m.set, "optionalAccess", m => m.call, "call", _ => _(this, m)]);
            if (R !== null && R !== -1) {
              try {
                _.adoptStyleSheets(m, R);
              } catch (m) {}
            }
            return C;
          }
        });
        return callbackWrapper(() => {
          Object.defineProperty(C, "adoptedStyleSheets", {
            configurable: B.configurable,
            enumerable: B.enumerable,
            get: B.get,
            set: B.set
          });
        });
      } else {
        return () => {};
      }
    }
    function initObservers(m, _ = {}) {
      let C;
      let R = m.doc.defaultView;
      if (!R) {
        return () => {};
      }
      if (m.recordDOM) {
        C = initMutationObserver(m, m.doc);
      }
      let L = function ({
        mousemoveCb: m,
        sampling: _,
        doc: C,
        mirror: R
      }) {
        let L;
        if (_.mousemove === false) {
          return () => {};
        }
        let B = typeof _.mousemove == "number" ? _.mousemove : 50;
        let F = typeof _.mousemoveCallback == "number" ? _.mousemoveCallback : 500;
        let U = [];
        let H = throttle$1(callbackWrapper(_ => {
          let C = Date.now() - L;
          m(U.map(m => {
            m.timeOffset -= C;
            return m;
          }), _);
          U = [];
          L = null;
        }), F);
        let q = callbackWrapper(throttle$1(callbackWrapper(m => {
          let _ = esm_getEventTarget(m);
          let {
            clientX: C,
            clientY: B
          } = legacy_isTouchEvent(m) ? m.changedTouches[0] : m;
          L ||= rr();
          U.push({
            x: C,
            y: B,
            id: R.getId(_),
            timeOffset: rr() - L
          });
          H(typeof DragEvent != "undefined" && m instanceof DragEvent ? ro.Drag : m instanceof MouseEvent ? ro.MouseMove : ro.TouchMove);
        }), B, {
          trailing: false
        }));
        let V = [on("mousemove", q, C), on("touchmove", q, C), on("drag", q, C)];
        return callbackWrapper(() => {
          V.forEach(m => m());
        });
      }(m);
      let B = function ({
        mouseInteractionCb: m,
        doc: _,
        mirror: C,
        blockClass: R,
        blockSelector: L,
        unblockSelector: B,
        sampling: F
      }) {
        if (F.mouseInteraction === false) {
          return () => {};
        }
        let U = F.mouseInteraction === true || F.mouseInteraction === undefined ? {} : F.mouseInteraction;
        let H = [];
        let q = null;
        let getHandler = _ => F => {
          let U = esm_getEventTarget(F);
          if (isBlocked(U, R, L, B, true)) {
            return;
          }
          let H = null;
          let V = _;
          if ("pointerType" in F) {
            switch (F.pointerType) {
              case "mouse":
                H = rs.Mouse;
                break;
              case "touch":
                H = rs.Touch;
                break;
              case "pen":
                H = rs.Pen;
            }
            if (H === rs.Touch) {
              if (ra[_] === ra.MouseDown) {
                V = "TouchStart";
              } else if (ra[_] === ra.MouseUp) {
                V = "TouchEnd";
              }
            } else {
              rs.Pen;
            }
          } else if (legacy_isTouchEvent(F)) {
            H = rs.Touch;
          }
          if (H !== null) {
            q = H;
            if (V.startsWith("Touch") && H === rs.Touch || V.startsWith("Mouse") && H === rs.Mouse) {
              H = null;
            }
          } else if (ra[_] === ra.Click) {
            H = q;
            q = null;
          }
          let X = legacy_isTouchEvent(F) ? F.changedTouches[0] : F;
          if (!X) {
            return;
          }
          let K = C.getId(U);
          let {
            clientX: Y,
            clientY: Q
          } = X;
          callbackWrapper(m)({
            type: ra[V],
            id: K,
            x: Y,
            y: Q,
            ...(H !== null && {
              pointerType: H
            })
          });
        };
        Object.keys(ra).filter(m => Number.isNaN(Number(m)) && !m.endsWith("_Departed") && U[m] !== false).forEach(m => {
          let C = toLowerCase(m);
          let R = getHandler(m);
          if (window.PointerEvent) {
            switch (ra[m]) {
              case ra.MouseDown:
              case ra.MouseUp:
                C = C.replace("mouse", "pointer");
                break;
              case ra.TouchStart:
              case ra.TouchEnd:
                return;
            }
          }
          H.push(on(C, R, _));
        });
        return callbackWrapper(() => {
          H.forEach(m => m());
        });
      }(m);
      let F = initScrollObserver(m);
      let U = function ({
        viewportResizeCb: m
      }, {
        win: _
      }) {
        let C = -1;
        let R = -1;
        let L = callbackWrapper(throttle$1(callbackWrapper(() => {
          let _ = getWindowHeight();
          let L = getWindowWidth();
          if (C !== _ || R !== L) {
            m({
              width: Number(L),
              height: Number(_)
            });
            C = _;
            R = L;
          }
        }), 200));
        return on("resize", L, _);
      }(m, {
        win: R
      });
      let H = function ({
        inputCb: m,
        doc: _,
        mirror: C,
        blockClass: R,
        blockSelector: L,
        unblockSelector: B,
        ignoreClass: F,
        ignoreSelector: U,
        maskInputOptions: H,
        maskInputFn: q,
        sampling: V,
        userTriggeredOnInput: X,
        maskTextClass: K,
        unmaskTextClass: Y,
        maskTextSelector: Q,
        unmaskTextSelector: et
      }) {
        function eventHandler(m) {
          let C = esm_getEventTarget(m);
          let V = m.isTrusted;
          let er = C && toUpperCase(C.tagName);
          if (er === "OPTION") {
            C = C.parentElement;
          }
          if (!C || !er || rl.indexOf(er) < 0 || isBlocked(C, R, L, B, true)) {
            return;
          }
          let en = C;
          if (en.classList.contains(F) || U && en.matches(U)) {
            return;
          }
          let ei = getInputType(C);
          let eo = getInputValue(en, er, ei);
          let ea = false;
          let es = shouldMaskInput({
            maskInputOptions: H,
            tagName: er,
            type: ei
          });
          let ec = needMaskingText(C, K, Q, Y, et, es);
          if (ei === "radio" || ei === "checkbox") {
            ea = C.checked;
          }
          eo = maskInputValue({
            isMasked: ec,
            element: C,
            value: eo,
            maskInputFn: q
          });
          cbWithDedup(C, X ? {
            text: eo,
            isChecked: ea,
            userTriggered: V
          } : {
            text: eo,
            isChecked: ea
          });
          let el = C.name;
          if (ei === "radio" && el && ea) {
            _.querySelectorAll(`input[type="radio"][name="${el}"]`).forEach(m => {
              if (m !== C) {
                let _ = maskInputValue({
                  isMasked: ec,
                  element: m,
                  value: getInputValue(m, er, ei),
                  maskInputFn: q
                });
                cbWithDedup(m, X ? {
                  text: _,
                  isChecked: !ea,
                  userTriggered: false
                } : {
                  text: _,
                  isChecked: !ea
                });
              }
            });
          }
        }
        function cbWithDedup(_, R) {
          let L = ru.get(_);
          if (!L || L.text !== R.text || L.isChecked !== R.isChecked) {
            ru.set(_, R);
            let L = C.getId(_);
            callbackWrapper(m)({
              ...R,
              id: L
            });
          }
        }
        let er = V.input === "last" ? ["change"] : ["input", "change"];
        let en = er.map(m => on(m, callbackWrapper(eventHandler), _));
        let ei = _.defaultView;
        if (!ei) {
          return () => {
            en.forEach(m => m());
          };
        }
        let eo = ei.Object.getOwnPropertyDescriptor(ei.HTMLInputElement.prototype, "value");
        let ea = [[ei.HTMLInputElement.prototype, "value"], [ei.HTMLInputElement.prototype, "checked"], [ei.HTMLSelectElement.prototype, "value"], [ei.HTMLTextAreaElement.prototype, "value"], [ei.HTMLSelectElement.prototype, "selectedIndex"], [ei.HTMLOptionElement.prototype, "selected"]];
        if (eo && eo.set) {
          en.push(...ea.map(m => function hookSetter(m, _, C, R, L = window) {
            let B = L.Object.getOwnPropertyDescriptor(m, _);
            L.Object.defineProperty(m, _, R ? C : {
              set(m) {
                setTimeout$1(() => {
                  C.set.call(this, m);
                }, 0);
                if (B && B.set) {
                  B.set.call(this, m);
                }
              }
            });
            return () => hookSetter(m, _, B || {}, true);
          }(m[0], m[1], {
            set() {
              callbackWrapper(eventHandler)({
                target: this,
                isTrusted: false
              });
            }
          }, false, ei)));
        }
        return callbackWrapper(() => {
          en.forEach(m => m());
        });
      }(m);
      let q = function ({
        mediaInteractionCb: m,
        blockClass: _,
        blockSelector: C,
        unblockSelector: R,
        mirror: L,
        sampling: B,
        doc: F
      }) {
        let U = callbackWrapper(F => throttle$1(callbackWrapper(B => {
          let U = esm_getEventTarget(B);
          if (!U || isBlocked(U, _, C, R, true)) {
            return;
          }
          let {
            currentTime: H,
            volume: q,
            muted: V,
            playbackRate: X
          } = U;
          m({
            type: F,
            id: L.getId(U),
            currentTime: H,
            volume: q,
            muted: V,
            playbackRate: X
          });
        }), B.media || 500));
        let H = [on("play", U(0), F), on("pause", U(1), F), on("seeked", U(2), F), on("volumechange", U(3), F), on("ratechange", U(4), F)];
        return callbackWrapper(() => {
          H.forEach(m => m());
        });
      }(m);
      let styleSheetObserver = () => {};
      let adoptedStyleSheetObserver = () => {};
      let styleDeclarationObserver = () => {};
      let fontObserver = () => {};
      if (m.recordDOM) {
        styleSheetObserver = function ({
          styleSheetRuleCb: m,
          mirror: _,
          stylesheetManager: C
        }, {
          win: R
        }) {
          let L;
          let B;
          if (!R.CSSStyleSheet || !R.CSSStyleSheet.prototype) {
            return () => {};
          }
          let F = R.CSSStyleSheet.prototype.insertRule;
          R.CSSStyleSheet.prototype.insertRule = new Proxy(F, {
            apply: callbackWrapper((R, L, B) => {
              let [F, U] = B;
              let {
                id: H,
                styleId: q
              } = getIdAndStyleId(L, _, C.styleMirror);
              if (H && H !== -1 || q && q !== -1) {
                m({
                  id: H,
                  styleId: q,
                  adds: [{
                    rule: F,
                    index: U
                  }]
                });
              }
              return R.apply(L, B);
            })
          });
          let U = R.CSSStyleSheet.prototype.deleteRule;
          R.CSSStyleSheet.prototype.deleteRule = new Proxy(U, {
            apply: callbackWrapper((R, L, B) => {
              let [F] = B;
              let {
                id: U,
                styleId: H
              } = getIdAndStyleId(L, _, C.styleMirror);
              if (U && U !== -1 || H && H !== -1) {
                m({
                  id: U,
                  styleId: H,
                  removes: [{
                    index: F
                  }]
                });
              }
              return R.apply(L, B);
            })
          });
          if (R.CSSStyleSheet.prototype.replace) {
            L = R.CSSStyleSheet.prototype.replace;
            R.CSSStyleSheet.prototype.replace = new Proxy(L, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    replace: F
                  });
                }
                return R.apply(L, B);
              })
            });
          }
          if (R.CSSStyleSheet.prototype.replaceSync) {
            B = R.CSSStyleSheet.prototype.replaceSync;
            R.CSSStyleSheet.prototype.replaceSync = new Proxy(B, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    replaceSync: F
                  });
                }
                return R.apply(L, B);
              })
            });
          }
          let H = {};
          if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
            H.CSSGroupingRule = R.CSSGroupingRule;
          } else {
            if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
              H.CSSMediaRule = R.CSSMediaRule;
            }
            if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
              H.CSSConditionRule = R.CSSConditionRule;
            }
            if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
              H.CSSSupportsRule = R.CSSSupportsRule;
            }
          }
          let q = {};
          Object.entries(H).forEach(([R, L]) => {
            q[R] = {
              insertRule: L.prototype.insertRule,
              deleteRule: L.prototype.deleteRule
            };
            L.prototype.insertRule = new Proxy(q[R].insertRule, {
              apply: callbackWrapper((R, L, B) => {
                let [F, U] = B;
                let {
                  id: H,
                  styleId: q
                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                if (H && H !== -1 || q && q !== -1) {
                  m({
                    id: H,
                    styleId: q,
                    adds: [{
                      rule: F,
                      index: [...getNestedCSSRulePositions(L), U || 0]
                    }]
                  });
                }
                return R.apply(L, B);
              })
            });
            L.prototype.deleteRule = new Proxy(q[R].deleteRule, {
              apply: callbackWrapper((R, L, B) => {
                let [F] = B;
                let {
                  id: U,
                  styleId: H
                } = getIdAndStyleId(L.parentStyleSheet, _, C.styleMirror);
                if (U && U !== -1 || H && H !== -1) {
                  m({
                    id: U,
                    styleId: H,
                    removes: [{
                      index: [...getNestedCSSRulePositions(L), F]
                    }]
                  });
                }
                return R.apply(L, B);
              })
            });
          });
          return callbackWrapper(() => {
            R.CSSStyleSheet.prototype.insertRule = F;
            R.CSSStyleSheet.prototype.deleteRule = U;
            if (L) {
              R.CSSStyleSheet.prototype.replace = L;
            }
            if (B) {
              R.CSSStyleSheet.prototype.replaceSync = B;
            }
            Object.entries(H).forEach(([m, _]) => {
              _.prototype.insertRule = q[m].insertRule;
              _.prototype.deleteRule = q[m].deleteRule;
            });
          });
        }(m, {
          win: R
        });
        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(m, m.doc);
        styleDeclarationObserver = function ({
          styleDeclarationCb: m,
          mirror: _,
          ignoreCSSAttributes: C,
          stylesheetManager: R
        }, {
          win: L
        }) {
          let B = L.CSSStyleDeclaration.prototype.setProperty;
          L.CSSStyleDeclaration.prototype.setProperty = new Proxy(B, {
            apply: callbackWrapper((L, F, U) => {
              let [H, q, V] = U;
              if (C.has(H)) {
                return B.apply(F, [H, q, V]);
              }
              let {
                id: X,
                styleId: K
              } = getIdAndStyleId(_optionalChain$2([F, "access", m => m.parentRule, "optionalAccess", m => m.parentStyleSheet]), _, R.styleMirror);
              if (X && X !== -1 || K && K !== -1) {
                m({
                  id: X,
                  styleId: K,
                  set: {
                    property: H,
                    value: q,
                    priority: V
                  },
                  index: getNestedCSSRulePositions(F.parentRule)
                });
              }
              return L.apply(F, U);
            })
          });
          let F = L.CSSStyleDeclaration.prototype.removeProperty;
          L.CSSStyleDeclaration.prototype.removeProperty = new Proxy(F, {
            apply: callbackWrapper((L, B, U) => {
              let [H] = U;
              if (C.has(H)) {
                return F.apply(B, [H]);
              }
              let {
                id: q,
                styleId: V
              } = getIdAndStyleId(_optionalChain$2([B, "access", m => m.parentRule, "optionalAccess", m => m.parentStyleSheet]), _, R.styleMirror);
              if (q && q !== -1 || V && V !== -1) {
                m({
                  id: q,
                  styleId: V,
                  remove: {
                    property: H
                  },
                  index: getNestedCSSRulePositions(B.parentRule)
                });
              }
              return L.apply(B, U);
            })
          });
          return callbackWrapper(() => {
            L.CSSStyleDeclaration.prototype.setProperty = B;
            L.CSSStyleDeclaration.prototype.removeProperty = F;
          });
        }(m, {
          win: R
        });
        if (m.collectFonts) {
          fontObserver = function ({
            fontCb: m,
            doc: _
          }) {
            let C = _.defaultView;
            if (!C) {
              return () => {};
            }
            let R = [];
            let L = new WeakMap();
            let B = C.FontFace;
            C.FontFace = function (m, _, C) {
              let R = new B(m, _, C);
              L.set(R, {
                family: m,
                buffer: typeof _ != "string",
                descriptors: C,
                fontSource: typeof _ == "string" ? _ : JSON.stringify(Array.from(new Uint8Array(_)))
              });
              return R;
            };
            let F = patch(_.fonts, "add", function (_) {
              return function (C) {
                setTimeout$1(callbackWrapper(() => {
                  let _ = L.get(C);
                  if (_) {
                    m(_);
                    L.delete(C);
                  }
                }), 0);
                return _.apply(this, [C]);
              };
            });
            R.push(() => {
              C.FontFace = B;
            });
            R.push(F);
            return callbackWrapper(() => {
              R.forEach(m => m());
            });
          }(m);
        }
      }
      let V = function (m) {
        let {
          doc: _,
          mirror: C,
          blockClass: R,
          blockSelector: L,
          unblockSelector: B,
          selectionCb: F
        } = m;
        let U = true;
        let H = callbackWrapper(() => {
          let m = _.getSelection();
          if (!m || U && _optionalChain$2([m, "optionalAccess", m => m.isCollapsed])) {
            return;
          }
          U = m.isCollapsed || false;
          let H = [];
          let q = m.rangeCount || 0;
          for (let _ = 0; _ < q; _++) {
            let F = m.getRangeAt(_);
            let {
              startContainer: U,
              startOffset: q,
              endContainer: V,
              endOffset: X
            } = F;
            let K = isBlocked(U, R, L, B, true) || isBlocked(V, R, L, B, true);
            if (!K) {
              H.push({
                start: C.getId(U),
                startOffset: q,
                end: C.getId(V),
                endOffset: X
              });
            }
          }
          F({
            ranges: H
          });
        });
        H();
        return on("selectionchange", H);
      }(m);
      let X = function ({
        doc: m,
        customElementCb: _
      }) {
        let C = m.defaultView;
        if (!C || !C.customElements) {
          return () => {};
        }
        let R = patch(C.customElements, "define", function (m) {
          return function (C, R, L) {
            try {
              _({
                define: {
                  name: C
                }
              });
            } catch (m) {}
            return m.apply(this, [C, R, L]);
          };
        });
        return R;
      }(m);
      let K = [];
      for (let _ of m.plugins) {
        K.push(_.observer(_.callback, R, _.options));
      }
      return callbackWrapper(() => {
        rc.forEach(m => m.reset());
        _optionalChain$2([C, "optionalAccess", m => m.disconnect, "call", m => m()]);
        L();
        B();
        F();
        U();
        H();
        q();
        styleSheetObserver();
        adoptedStyleSheetObserver();
        styleDeclarationObserver();
        fontObserver();
        V();
        X();
        K.forEach(m => m());
      });
    }
    function hasNestedCSSRule(m) {
      return window[m] !== undefined;
    }
    function canMonkeyPatchNestedCSSRule(m) {
      return window[m] !== undefined && !!window[m].prototype && !!("insertRule" in window[m].prototype) && !!("deleteRule" in window[m].prototype);
    }
    let CrossOriginIframeMirror = class CrossOriginIframeMirror {
      constructor(m) {
        this.generateIdFn = m;
        this.iframeIdToRemoteIdMap = new WeakMap();
        this.iframeRemoteIdToIdMap = new WeakMap();
      }
      getId(m, _, C, R) {
        let L = C || this.getIdToRemoteIdMap(m);
        let B = R || this.getRemoteIdToIdMap(m);
        let F = L.get(_);
        if (!F) {
          F = this.generateIdFn();
          L.set(_, F);
          B.set(F, _);
        }
        return F;
      }
      getIds(m, _) {
        let C = this.getIdToRemoteIdMap(m);
        let R = this.getRemoteIdToIdMap(m);
        return _.map(_ => this.getId(m, _, C, R));
      }
      getRemoteId(m, _, C) {
        let R = C || this.getRemoteIdToIdMap(m);
        if (typeof _ != "number") {
          return _;
        }
        let L = R.get(_);
        return L || -1;
      }
      getRemoteIds(m, _) {
        let C = this.getRemoteIdToIdMap(m);
        return _.map(_ => this.getRemoteId(m, _, C));
      }
      reset(m) {
        if (!m) {
          this.iframeIdToRemoteIdMap = new WeakMap();
          this.iframeRemoteIdToIdMap = new WeakMap();
          return;
        }
        this.iframeIdToRemoteIdMap.delete(m);
        this.iframeRemoteIdToIdMap.delete(m);
      }
      getIdToRemoteIdMap(m) {
        let _ = this.iframeIdToRemoteIdMap.get(m);
        if (!_) {
          _ = new Map();
          this.iframeIdToRemoteIdMap.set(m, _);
        }
        return _;
      }
      getRemoteIdToIdMap(m) {
        let _ = this.iframeRemoteIdToIdMap.get(m);
        if (!_) {
          _ = new Map();
          this.iframeRemoteIdToIdMap.set(m, _);
        }
        return _;
      }
    };
    function _optionalChain$1(m) {
      let _;
      let C = m[0];
      let R = 1;
      while (R < m.length) {
        let L = m[R];
        let B = m[R + 1];
        R += 2;
        if ((L === "optionalAccess" || L === "optionalCall") && C == null) {
          return;
        }
        if (L === "access" || L === "optionalAccess") {
          _ = C;
          C = B(C);
        } else if (L === "call" || L === "optionalCall") {
          C = B((...m) => C.call(_, ...m));
          _ = undefined;
        }
      }
      return C;
    }
    let IframeManagerNoop = class IframeManagerNoop {
      constructor() {
        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
        this.crossOriginIframeRootIdMap = new WeakMap();
      }
      addIframe() {}
      addLoadListener() {}
      attachIframe() {}
    };
    let IframeManager = class IframeManager {
      constructor(m) {
        this.iframes = new WeakMap();
        this.crossOriginIframeMap = new WeakMap();
        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
        this.crossOriginIframeRootIdMap = new WeakMap();
        this.mutationCb = m.mutationCb;
        this.wrappedEmit = m.wrappedEmit;
        this.stylesheetManager = m.stylesheetManager;
        this.recordCrossOriginIframes = m.recordCrossOriginIframes;
        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));
        this.mirror = m.mirror;
        if (this.recordCrossOriginIframes) {
          window.addEventListener("message", this.handleMessage.bind(this));
        }
      }
      addIframe(m) {
        this.iframes.set(m, true);
        if (m.contentWindow) {
          this.crossOriginIframeMap.set(m.contentWindow, m);
        }
      }
      addLoadListener(m) {
        this.loadListener = m;
      }
      attachIframe(m, _) {
        this.mutationCb({
          adds: [{
            parentId: this.mirror.getId(m),
            nextId: null,
            node: _
          }],
          removes: [],
          texts: [],
          attributes: [],
          isAttachIframe: true
        });
        _optionalChain$1([this, "access", m => m.loadListener, "optionalCall", _ => _(m)]);
        if (m.contentDocument && m.contentDocument.adoptedStyleSheets && m.contentDocument.adoptedStyleSheets.length > 0) {
          this.stylesheetManager.adoptStyleSheets(m.contentDocument.adoptedStyleSheets, this.mirror.getId(m.contentDocument));
        }
      }
      handleMessage(m) {
        if (m.data.type !== "rrweb" || m.origin !== m.data.origin) {
          return;
        }
        let _ = m.source;
        if (!_) {
          return;
        }
        let C = this.crossOriginIframeMap.get(m.source);
        if (!C) {
          return;
        }
        let R = this.transformCrossOriginEvent(C, m.data.event);
        if (R) {
          this.wrappedEmit(R, m.data.isCheckout);
        }
      }
      transformCrossOriginEvent(m, _) {
        switch (_.type) {
          case ri.FullSnapshot:
            {
              this.crossOriginIframeMirror.reset(m);
              this.crossOriginIframeStyleMirror.reset(m);
              this.replaceIdOnNode(_.data.node, m);
              let C = _.data.node.id;
              this.crossOriginIframeRootIdMap.set(m, C);
              this.patchRootIdOnNode(_.data.node, C);
              return {
                timestamp: _.timestamp,
                type: ri.IncrementalSnapshot,
                data: {
                  source: ro.Mutation,
                  adds: [{
                    parentId: this.mirror.getId(m),
                    nextId: null,
                    node: _.data.node
                  }],
                  removes: [],
                  texts: [],
                  attributes: [],
                  isAttachIframe: true
                }
              };
            }
          case ri.Meta:
          case ri.Load:
          case ri.DomContentLoaded:
            break;
          case ri.Plugin:
            return _;
          case ri.Custom:
            this.replaceIds(_.data.payload, m, ["id", "parentId", "previousId", "nextId"]);
            return _;
          case ri.IncrementalSnapshot:
            switch (_.data.source) {
              case ro.Mutation:
                _.data.adds.forEach(_ => {
                  this.replaceIds(_, m, ["parentId", "nextId", "previousId"]);
                  this.replaceIdOnNode(_.node, m);
                  let C = this.crossOriginIframeRootIdMap.get(m);
                  if (C) {
                    this.patchRootIdOnNode(_.node, C);
                  }
                });
                _.data.removes.forEach(_ => {
                  this.replaceIds(_, m, ["parentId", "id"]);
                });
                _.data.attributes.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                _.data.texts.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                return _;
              case ro.Drag:
              case ro.TouchMove:
              case ro.MouseMove:
                _.data.positions.forEach(_ => {
                  this.replaceIds(_, m, ["id"]);
                });
                return _;
              case ro.ViewportResize:
                return false;
              case ro.MediaInteraction:
              case ro.MouseInteraction:
              case ro.Scroll:
              case ro.CanvasMutation:
              case ro.Input:
                this.replaceIds(_.data, m, ["id"]);
                return _;
              case ro.StyleSheetRule:
              case ro.StyleDeclaration:
                this.replaceIds(_.data, m, ["id"]);
                this.replaceStyleIds(_.data, m, ["styleId"]);
                return _;
              case ro.Font:
                return _;
              case ro.Selection:
                _.data.ranges.forEach(_ => {
                  this.replaceIds(_, m, ["start", "end"]);
                });
                return _;
              case ro.AdoptedStyleSheet:
                this.replaceIds(_.data, m, ["id"]);
                this.replaceStyleIds(_.data, m, ["styleIds"]);
                _optionalChain$1([_, "access", m => m.data, "access", m => m.styles, "optionalAccess", m => m.forEach, "call", _ => _(_ => {
                  this.replaceStyleIds(_, m, ["styleId"]);
                })]);
                return _;
            }
        }
        return false;
      }
      replace(m, _, C, R) {
        for (let L of R) {
          if (Array.isArray(_[L]) || typeof _[L] == "number") {
            if (Array.isArray(_[L])) {
              _[L] = m.getIds(C, _[L]);
            } else {
              _[L] = m.getId(C, _[L]);
            }
          }
        }
        return _;
      }
      replaceIds(m, _, C) {
        return this.replace(this.crossOriginIframeMirror, m, _, C);
      }
      replaceStyleIds(m, _, C) {
        return this.replace(this.crossOriginIframeStyleMirror, m, _, C);
      }
      replaceIdOnNode(m, _) {
        this.replaceIds(m, _, ["id", "rootId"]);
        if ("childNodes" in m) {
          m.childNodes.forEach(m => {
            this.replaceIdOnNode(m, _);
          });
        }
      }
      patchRootIdOnNode(m, _) {
        if (m.type !== em.Document && !m.rootId) {
          m.rootId = _;
        }
        if ("childNodes" in m) {
          m.childNodes.forEach(m => {
            this.patchRootIdOnNode(m, _);
          });
        }
      }
    };
    let ShadowDomManagerNoop = class ShadowDomManagerNoop {
      init() {}
      addShadowRoot() {}
      observeAttachShadow() {}
      reset() {}
    };
    let ShadowDomManager = class ShadowDomManager {
      constructor(m) {
        this.shadowDoms = new WeakSet();
        this.restoreHandlers = [];
        this.mutationCb = m.mutationCb;
        this.scrollCb = m.scrollCb;
        this.bypassOptions = m.bypassOptions;
        this.mirror = m.mirror;
        this.init();
      }
      init() {
        this.reset();
        this.patchAttachShadow(Element, document);
      }
      addShadowRoot(m, _) {
        if (!isNativeShadowDom(m) || this.shadowDoms.has(m)) {
          return;
        }
        this.shadowDoms.add(m);
        this.bypassOptions.canvasManager.addShadowRoot(m);
        let C = initMutationObserver({
          ...this.bypassOptions,
          doc: _,
          mutationCb: this.mutationCb,
          mirror: this.mirror,
          shadowDomManager: this
        }, m);
        this.restoreHandlers.push(() => C.disconnect());
        this.restoreHandlers.push(initScrollObserver({
          ...this.bypassOptions,
          scrollCb: this.scrollCb,
          doc: m,
          mirror: this.mirror
        }));
        setTimeout$1(() => {
          if (m.adoptedStyleSheets && m.adoptedStyleSheets.length > 0) {
            this.bypassOptions.stylesheetManager.adoptStyleSheets(m.adoptedStyleSheets, this.mirror.getId(m.host));
          }
          this.restoreHandlers.push(initAdoptedStyleSheetObserver({
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          }, m));
        }, 0);
      }
      observeAttachShadow(m) {
        if (m.contentWindow && m.contentDocument) {
          this.patchAttachShadow(m.contentWindow.Element, m.contentDocument);
        }
      }
      patchAttachShadow(m, _) {
        let C = this;
        this.restoreHandlers.push(patch(m.prototype, "attachShadow", function (m) {
          return function (R) {
            let L = m.call(this, R);
            if (this.shadowRoot && inDom(this)) {
              C.addShadowRoot(this.shadowRoot, _);
            }
            return L;
          };
        }));
      }
      reset() {
        this.restoreHandlers.forEach(m => {
          try {
            m();
          } catch (m) {}
        });
        this.restoreHandlers = [];
        this.shadowDoms = new WeakSet();
        this.bypassOptions.canvasManager.resetShadowRoots();
      }
    };
    let CanvasManagerNoop = class CanvasManagerNoop {
      reset() {}
      freeze() {}
      unfreeze() {}
      lock() {}
      unlock() {}
      snapshot() {}
      addWindow() {}
      addShadowRoot() {}
      resetShadowRoots() {}
    };
    let StylesheetManager = class StylesheetManager {
      constructor(m) {
        this.trackedLinkElements = new WeakSet();
        this.styleMirror = new StyleSheetMirror();
        this.mutationCb = m.mutationCb;
        this.adoptedStyleSheetCb = m.adoptedStyleSheetCb;
      }
      attachLinkElement(m, _) {
        if ("_cssText" in _.attributes) {
          this.mutationCb({
            adds: [],
            removes: [],
            texts: [],
            attributes: [{
              id: _.id,
              attributes: _.attributes
            }]
          });
        }
        this.trackLinkElement(m);
      }
      trackLinkElement(m) {
        if (!this.trackedLinkElements.has(m)) {
          this.trackedLinkElements.add(m);
          this.trackStylesheetInLinkElement(m);
        }
      }
      adoptStyleSheets(m, _) {
        if (m.length === 0) {
          return;
        }
        let C = {
          id: _,
          styleIds: []
        };
        let R = [];
        for (let _ of m) {
          let m;
          if (this.styleMirror.has(_)) {
            m = this.styleMirror.getId(_);
          } else {
            m = this.styleMirror.add(_);
            R.push({
              styleId: m,
              rules: Array.from(_.rules || CSSRule, (m, _) => ({
                rule: stringifyRule(m),
                index: _
              }))
            });
          }
          C.styleIds.push(m);
        }
        if (R.length > 0) {
          C.styles = R;
        }
        this.adoptedStyleSheetCb(C);
      }
      reset() {
        this.styleMirror.reset();
        this.trackedLinkElements = new WeakSet();
      }
      trackStylesheetInLinkElement(m) {}
    };
    let ProcessedNodeManager = class ProcessedNodeManager {
      constructor() {
        this.nodeMap = new WeakMap();
        this.active = false;
      }
      inOtherBuffer(m, _) {
        let C = this.nodeMap.get(m);
        return C && Array.from(C).some(m => m !== _);
      }
      add(m, _) {
        if (!this.active) {
          this.active = true;
          (function (...m) {
            getImplementation("requestAnimationFrame")(...m);
          })(() => {
            this.nodeMap = new WeakMap();
            this.active = false;
          });
        }
        this.nodeMap.set(m, (this.nodeMap.get(m) || new Set()).add(_));
      }
      destroy() {}
    };
    try {
      if (Array.from([1], m => m * 2)[0] !== 2) {
        let m = document.createElement("iframe");
        document.body.appendChild(m);
        Array.from = _optionalChain([m, "access", m => m.contentWindow, "optionalAccess", m => m.Array, "access", m => m.from]) || Array.from;
        document.body.removeChild(m);
      }
    } catch (m) {
      console.debug("Unable to override Array.from", m);
    }
    let rd = new Mirror();
    function record(m = {}) {
      let _;
      let {
        emit: C,
        checkoutEveryNms: R,
        checkoutEveryNth: L,
        blockClass: B = "rr-block",
        blockSelector: F = null,
        unblockSelector: U = null,
        ignoreClass: H = "rr-ignore",
        ignoreSelector: q = null,
        maskAllText: V = false,
        maskTextClass: X = "rr-mask",
        unmaskTextClass: K = null,
        maskTextSelector: Y = null,
        unmaskTextSelector: Q = null,
        inlineStylesheet: et = true,
        maskAllInputs: er,
        maskInputOptions: en,
        slimDOMOptions: es,
        maskAttributeFn: ec,
        maskInputFn: el,
        maskTextFn: eu,
        maxCanvasSize: ed = null,
        packFn: ep,
        sampling: eh = {},
        dataURLOptions: ef = {},
        mousemoveWait: em,
        recordDOM: eg = true,
        recordCanvas: ey = false,
        recordCrossOriginIframes: e_ = false,
        recordAfter: ev = m.recordAfter === "DOMContentLoaded" ? m.recordAfter : "load",
        userTriggeredOnInput: eb = false,
        collectFonts: eS = false,
        inlineImages: ew = false,
        plugins: eE,
        keepIframeSrcFn: ek = () => false,
        ignoreCSSAttributes: ex = new Set([]),
        errorHandler: eI,
        onMutation: eO,
        getCanvasManager: eC
      } = m;
      ei = eI;
      let eM = !e_ || window.parent === window;
      let eT = false;
      if (!eM) {
        try {
          if (window.parent.document) {
            eT = false;
          }
        } catch (m) {
          eT = true;
        }
      }
      if (eM && !C) {
        throw Error("emit function is required");
      }
      if (!eM && !eT) {
        return () => {};
      }
      if (em !== undefined && eh.mousemove === undefined) {
        eh.mousemove = em;
      }
      rd.reset();
      let eA = er === true ? {
        color: true,
        date: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true,
        textarea: true,
        select: true,
        radio: true,
        checkbox: true
      } : en !== undefined ? en : {};
      let eR = es === true || es === "all" ? {
        script: true,
        comment: true,
        headFavicon: true,
        headWhitespace: true,
        headMetaSocial: true,
        headMetaRobots: true,
        headMetaHttpEquiv: true,
        headMetaVerification: true,
        headMetaAuthorship: es === "all",
        headMetaDescKeywords: es === "all"
      } : es || {};
      (function (m = window) {
        if ("NodeList" in m && !m.NodeList.prototype.forEach) {
          m.NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if ("DOMTokenList" in m && !m.DOMTokenList.prototype.forEach) {
          m.DOMTokenList.prototype.forEach = Array.prototype.forEach;
        }
        Node.prototype.contains ||= (...m) => {
          let _ = m[0];
          if (!(0 in m)) {
            throw TypeError("1 argument is required");
          }
          do {
            if (this === _) {
              return true;
            }
          } while (_ = _ && _.parentNode);
          return false;
        };
      })();
      let eP = 0;
      let eventProcessor = m => {
        for (let _ of eE || []) {
          if (_.eventProcessor) {
            m = _.eventProcessor(m);
          }
        }
        if (ep && !eT) {
          m = ep(m);
        }
        return m;
      };
      eo = (m, B) => {
        m.timestamp = rr();
        if (_optionalChain([rc, "access", m => m[0], "optionalAccess", m => m.isFrozen, "call", m => m()]) && m.type !== ri.FullSnapshot && (m.type !== ri.IncrementalSnapshot || m.data.source !== ro.Mutation)) {
          rc.forEach(m => m.unfreeze());
        }
        if (eM) {
          _optionalChain([C, "optionalCall", _ => _(eventProcessor(m), B)]);
        } else if (eT) {
          let _ = {
            type: "rrweb",
            event: eventProcessor(m),
            origin: window.location.origin,
            isCheckout: B
          };
          window.parent.postMessage(_, "*");
        }
        if (m.type === ri.FullSnapshot) {
          _ = m;
          eP = 0;
        } else if (m.type === ri.IncrementalSnapshot) {
          if (m.data.source === ro.Mutation && m.data.isAttachIframe) {
            return;
          }
          eP++;
          let C = L && eP >= L;
          let B = R && _ && m.timestamp - _.timestamp > R;
          if (C || B) {
            takeFullSnapshot(true);
          }
        }
      };
      let wrappedMutationEmit = m => {
        eo({
          type: ri.IncrementalSnapshot,
          data: {
            source: ro.Mutation,
            ...m
          }
        });
      };
      let wrappedScrollEmit = m => eo({
        type: ri.IncrementalSnapshot,
        data: {
          source: ro.Scroll,
          ...m
        }
      });
      let wrappedCanvasMutationEmit = m => eo({
        type: ri.IncrementalSnapshot,
        data: {
          source: ro.CanvasMutation,
          ...m
        }
      });
      let eD = new StylesheetManager({
        mutationCb: wrappedMutationEmit,
        adoptedStyleSheetCb: m => eo({
          type: ri.IncrementalSnapshot,
          data: {
            source: ro.AdoptedStyleSheet,
            ...m
          }
        })
      });
      let eL = typeof __RRWEB_EXCLUDE_IFRAME__ == "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({
        mirror: rd,
        mutationCb: wrappedMutationEmit,
        stylesheetManager: eD,
        recordCrossOriginIframes: e_,
        wrappedEmit: eo
      });
      for (let m of eE || []) {
        if (m.getMirror) {
          m.getMirror({
            nodeMirror: rd,
            crossOriginIframeMirror: eL.crossOriginIframeMirror,
            crossOriginIframeStyleMirror: eL.crossOriginIframeStyleMirror
          });
        }
      }
      let eN = new ProcessedNodeManager();
      let eB = function (m, _) {
        try {
          if (m) {
            return m(_);
          } else {
            return new CanvasManagerNoop();
          }
        } catch (m) {
          console.warn("Unable to initialize CanvasManager");
          return new CanvasManagerNoop();
        }
      }(eC, {
        mirror: rd,
        win: window,
        mutationCb: m => eo({
          type: ri.IncrementalSnapshot,
          data: {
            source: ro.CanvasMutation,
            ...m
          }
        }),
        recordCanvas: ey,
        blockClass: B,
        blockSelector: F,
        unblockSelector: U,
        maxCanvasSize: ed,
        sampling: eh.canvas,
        dataURLOptions: ef,
        errorHandler: eI
      });
      let ej = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ == "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({
        mutationCb: wrappedMutationEmit,
        scrollCb: wrappedScrollEmit,
        bypassOptions: {
          onMutation: eO,
          blockClass: B,
          blockSelector: F,
          unblockSelector: U,
          maskAllText: V,
          maskTextClass: X,
          unmaskTextClass: K,
          maskTextSelector: Y,
          unmaskTextSelector: Q,
          inlineStylesheet: et,
          maskInputOptions: eA,
          dataURLOptions: ef,
          maskAttributeFn: ec,
          maskTextFn: eu,
          maskInputFn: el,
          recordCanvas: ey,
          inlineImages: ew,
          sampling: eh,
          slimDOMOptions: eR,
          iframeManager: eL,
          stylesheetManager: eD,
          canvasManager: eB,
          keepIframeSrcFn: ek,
          processedNodeManager: eN
        },
        mirror: rd
      });
      let takeFullSnapshot = (m = false) => {
        if (!eg) {
          return;
        }
        eo({
          type: ri.Meta,
          data: {
            href: window.location.href,
            width: getWindowWidth(),
            height: getWindowHeight()
          }
        }, m);
        eD.reset();
        ej.init();
        rc.forEach(m => m.lock());
        let _ = function (m, _) {
          let {
            mirror: C = new Mirror(),
            blockClass: R = "rr-block",
            blockSelector: L = null,
            unblockSelector: B = null,
            maskAllText: F = false,
            maskTextClass: U = "rr-mask",
            unmaskTextClass: H = null,
            maskTextSelector: q = null,
            unmaskTextSelector: V = null,
            inlineStylesheet: X = true,
            inlineImages: K = false,
            recordCanvas: Y = false,
            maskAllInputs: Q = false,
            maskAttributeFn: et,
            maskTextFn: er,
            maskInputFn: en,
            slimDOM: ei = false,
            dataURLOptions: eo,
            preserveWhiteSpace: ea,
            onSerialize: es,
            onIframeLoad: ec,
            iframeLoadTimeout: el,
            onStylesheetLoad: eu,
            stylesheetLoadTimeout: ed,
            keepIframeSrcFn: ep = () => false
          } = _ || {};
          let eh = Q === true ? {
            color: true,
            date: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true,
            textarea: true,
            select: true
          } : Q === false ? {} : Q;
          let ef = ei === true || ei === "all" ? {
            script: true,
            comment: true,
            headFavicon: true,
            headWhitespace: true,
            headMetaDescKeywords: ei === "all",
            headMetaSocial: true,
            headMetaRobots: true,
            headMetaHttpEquiv: true,
            headMetaAuthorship: true,
            headMetaVerification: true
          } : ei === false ? {} : ei;
          return serializeNodeWithId(m, {
            doc: m,
            mirror: C,
            blockClass: R,
            blockSelector: L,
            unblockSelector: B,
            maskAllText: F,
            maskTextClass: U,
            unmaskTextClass: H,
            maskTextSelector: q,
            unmaskTextSelector: V,
            skipChild: false,
            inlineStylesheet: X,
            maskInputOptions: eh,
            maskAttributeFn: et,
            maskTextFn: er,
            maskInputFn: en,
            slimDOMOptions: ef,
            dataURLOptions: eo,
            inlineImages: K,
            recordCanvas: Y,
            preserveWhiteSpace: ea,
            onSerialize: es,
            onIframeLoad: ec,
            iframeLoadTimeout: el,
            onStylesheetLoad: eu,
            stylesheetLoadTimeout: ed,
            keepIframeSrcFn: ep,
            newlyAddedElement: false
          });
        }(document, {
          mirror: rd,
          blockClass: B,
          blockSelector: F,
          unblockSelector: U,
          maskAllText: V,
          maskTextClass: X,
          unmaskTextClass: K,
          maskTextSelector: Y,
          unmaskTextSelector: Q,
          inlineStylesheet: et,
          maskAllInputs: eA,
          maskAttributeFn: ec,
          maskInputFn: el,
          maskTextFn: eu,
          slimDOM: eR,
          dataURLOptions: ef,
          recordCanvas: ey,
          inlineImages: ew,
          onSerialize: m => {
            if (isSerializedIframe(m, rd)) {
              eL.addIframe(m);
            }
            if (isSerializedStylesheet(m, rd)) {
              eD.trackLinkElement(m);
            }
            if (hasShadowRoot(m)) {
              ej.addShadowRoot(m.shadowRoot, document);
            }
          },
          onIframeLoad: (m, _) => {
            eL.attachIframe(m, _);
            if (m.contentWindow) {
              eB.addWindow(m.contentWindow);
            }
            ej.observeAttachShadow(m);
          },
          onStylesheetLoad: (m, _) => {
            eD.attachLinkElement(m, _);
          },
          keepIframeSrcFn: ek
        });
        if (!_) {
          return console.warn("Failed to snapshot the document");
        }
        eo({
          type: ri.FullSnapshot,
          data: {
            node: _,
            initialOffset: getWindowScroll(window)
          }
        });
        rc.forEach(m => m.unlock());
        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) {
          eD.adoptStyleSheets(document.adoptedStyleSheets, rd.getId(document));
        }
      };
      ea = takeFullSnapshot;
      try {
        let m = [];
        let observe = m => callbackWrapper(initObservers)({
          onMutation: eO,
          mutationCb: wrappedMutationEmit,
          mousemoveCb: (m, _) => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: _,
              positions: m
            }
          }),
          mouseInteractionCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.MouseInteraction,
              ...m
            }
          }),
          scrollCb: wrappedScrollEmit,
          viewportResizeCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.ViewportResize,
              ...m
            }
          }),
          inputCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.Input,
              ...m
            }
          }),
          mediaInteractionCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.MediaInteraction,
              ...m
            }
          }),
          styleSheetRuleCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.StyleSheetRule,
              ...m
            }
          }),
          styleDeclarationCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.StyleDeclaration,
              ...m
            }
          }),
          canvasMutationCb: wrappedCanvasMutationEmit,
          fontCb: m => eo({
            type: ri.IncrementalSnapshot,
            data: {
              source: ro.Font,
              ...m
            }
          }),
          selectionCb: m => {
            eo({
              type: ri.IncrementalSnapshot,
              data: {
                source: ro.Selection,
                ...m
              }
            });
          },
          customElementCb: m => {
            eo({
              type: ri.IncrementalSnapshot,
              data: {
                source: ro.CustomElement,
                ...m
              }
            });
          },
          blockClass: B,
          ignoreClass: H,
          ignoreSelector: q,
          maskAllText: V,
          maskTextClass: X,
          unmaskTextClass: K,
          maskTextSelector: Y,
          unmaskTextSelector: Q,
          maskInputOptions: eA,
          inlineStylesheet: et,
          sampling: eh,
          recordDOM: eg,
          recordCanvas: ey,
          inlineImages: ew,
          userTriggeredOnInput: eb,
          collectFonts: eS,
          doc: m,
          maskAttributeFn: ec,
          maskInputFn: el,
          maskTextFn: eu,
          keepIframeSrcFn: ek,
          blockSelector: F,
          unblockSelector: U,
          slimDOMOptions: eR,
          dataURLOptions: ef,
          mirror: rd,
          iframeManager: eL,
          stylesheetManager: eD,
          shadowDomManager: ej,
          processedNodeManager: eN,
          canvasManager: eB,
          ignoreCSSAttributes: ex,
          plugins: _optionalChain([eE, "optionalAccess", m => m.filter, "call", m => m(m => m.observer), "optionalAccess", m => m.map, "call", m => m(m => ({
            observer: m.observer,
            options: m.options,
            callback: _ => eo({
              type: ri.Plugin,
              data: {
                plugin: m.name,
                payload: _
              }
            })
          }))]) || []
        }, {});
        eL.addLoadListener(_ => {
          try {
            m.push(observe(_.contentDocument));
          } catch (m) {
            console.warn(m);
          }
        });
        let init = () => {
          takeFullSnapshot();
          m.push(observe(document));
        };
        if (document.readyState === "interactive" || document.readyState === "complete") {
          init();
        } else {
          m.push(on("DOMContentLoaded", () => {
            eo({
              type: ri.DomContentLoaded,
              data: {}
            });
            if (ev === "DOMContentLoaded") {
              init();
            }
          }));
          m.push(on("load", () => {
            eo({
              type: ri.Load,
              data: {}
            });
            if (ev === "load") {
              init();
            }
          }, window));
        }
        return () => {
          m.forEach(m => m());
          eN.destroy();
          ea = undefined;
          ei = undefined;
        };
      } catch (m) {
        console.warn(m);
      }
    }
    record.mirror = rd;
    record.takeFullSnapshot = function (m) {
      if (!ea) {
        throw Error("please take full snapshot after start recording");
      }
      ea(m);
    };
    let rp = ["info", "warn", "error", "log"];
    function timestampToMs(m) {
      if (m > 9999999999) {
        return m;
      } else {
        return m * 1000;
      }
    }
    function timestampToS(m) {
      if (m > 9999999999) {
        return m / 1000;
      } else {
        return m;
      }
    }
    function addBreadcrumbEvent(m, _) {
      if (_.category !== "sentry.transaction") {
        if (["ui.click", "ui.input"].includes(_.category)) {
          m.triggerUserActivity();
        } else {
          m.checkAndHandleExpiredSession();
        }
        m.addUpdate(() => {
          m.throttledAddEvent({
            type: ri.Custom,
            timestamp: (_.timestamp || 0) * 1000,
            data: {
              tag: "breadcrumb",
              payload: (0, eV.Fv)(_, 10, 1000)
            }
          });
          return _.category === "console";
        });
      }
    }
    function getClosestInteractive(m) {
      let _ = m.closest("button,a");
      return _ || m;
    }
    function getClickTargetNode(m) {
      let _ = getTargetNode(m);
      if (_ && _ instanceof Element) {
        return getClosestInteractive(_);
      } else {
        return _;
      }
    }
    function getTargetNode(m) {
      if (typeof m == "object" && m && "target" in m) {
        return m.target;
      } else {
        return m;
      }
    }
    (function () {
      let m = {
        exception: () => undefined,
        infoTick: () => undefined,
        setConfig: m => {
          m.captureExceptions;
          m.traceInternals;
        }
      };
      rp.forEach(_ => {
        m[_] = () => undefined;
      });
    })();
    let rh = new Set([ro.Mutation, ro.StyleSheetRule, ro.StyleDeclaration, ro.AdoptedStyleSheet, ro.CanvasMutation, ro.Selection, ro.MediaInteraction]);
    let ClickDetector = class ClickDetector {
      constructor(m, _, C = addBreadcrumbEvent) {
        this._lastMutation = 0;
        this._lastScroll = 0;
        this._clicks = [];
        this._timeout = _.timeout / 1000;
        this._threshold = _.threshold / 1000;
        this._scollTimeout = _.scrollTimeout / 1000;
        this._replay = m;
        this._ignoreSelector = _.ignoreSelector;
        this._addBreadcrumbEvent = C;
      }
      addListeners() {
        var m;
        m = () => {
          this._lastMutation = nowInSeconds();
        };
        if (!es) {
          es = [];
          (0, ex.hl)(tK, "open", function (m) {
            return function (..._) {
              if (es) {
                try {
                  es.forEach(m => m());
                } catch (m) {}
              }
              return m.apply(tK, _);
            };
          });
        }
        es.push(m);
        let _ = () => {
          let _ = es ? es.indexOf(m) : -1;
          if (_ > -1) {
            es.splice(_, 1);
          }
        };
        this._teardown = () => {
          _();
          this._clicks = [];
          this._lastMutation = 0;
          this._lastScroll = 0;
        };
      }
      removeListeners() {
        if (this._teardown) {
          this._teardown();
        }
        if (this._checkClickTimeout) {
          clearTimeout(this._checkClickTimeout);
        }
      }
      handleClick(m, _) {
        var C;
        C = this._ignoreSelector;
        if (!rf.includes(_.tagName) || _.tagName === "INPUT" && !["submit", "button"].includes(_.getAttribute("type") || "") || _.tagName === "A" && (_.hasAttribute("download") || _.hasAttribute("target") && _.getAttribute("target") !== "_self") || C && _.matches(C) || !m.data || typeof m.data.nodeId != "number" || !m.timestamp) {
          return;
        }
        let R = {
          timestamp: timestampToS(m.timestamp),
          clickBreadcrumb: m,
          clickCount: 0,
          node: _
        };
        if (!this._clicks.some(m => m.node === R.node && Math.abs(m.timestamp - R.timestamp) < 1)) {
          this._clicks.push(R);
          if (this._clicks.length === 1) {
            this._scheduleCheckClicks();
          }
        }
      }
      registerMutation(m = Date.now()) {
        this._lastMutation = timestampToS(m);
      }
      registerScroll(m = Date.now()) {
        this._lastScroll = timestampToS(m);
      }
      registerClick(m) {
        let _ = getClosestInteractive(m);
        this._handleMultiClick(_);
      }
      _handleMultiClick(m) {
        this._getClicks(m).forEach(m => {
          m.clickCount++;
        });
      }
      _getClicks(m) {
        return this._clicks.filter(_ => _.node === m);
      }
      _checkClicks() {
        let m = [];
        let _ = nowInSeconds();
        this._clicks.forEach(C => {
          if (!C.mutationAfter && this._lastMutation) {
            C.mutationAfter = C.timestamp <= this._lastMutation ? this._lastMutation - C.timestamp : undefined;
          }
          if (!C.scrollAfter && this._lastScroll) {
            C.scrollAfter = C.timestamp <= this._lastScroll ? this._lastScroll - C.timestamp : undefined;
          }
          if (C.timestamp + this._timeout <= _) {
            m.push(C);
          }
        });
        for (let C of m) {
          let m = this._clicks.indexOf(C);
          if (m > -1) {
            this._generateBreadcrumbs(C);
            this._clicks.splice(m, 1);
          }
        }
        if (this._clicks.length) {
          this._scheduleCheckClicks();
        }
      }
      _generateBreadcrumbs(m) {
        let _ = this._replay;
        let C = m.scrollAfter && m.scrollAfter <= this._scollTimeout;
        let R = m.mutationAfter && m.mutationAfter <= this._threshold;
        let {
          clickCount: L,
          clickBreadcrumb: B
        } = m;
        if (!C && !R) {
          let C = Math.min(m.mutationAfter || this._timeout, this._timeout) * 1000;
          let R = C < this._timeout * 1000 ? "mutation" : "timeout";
          let F = {
            type: "default",
            message: B.message,
            timestamp: B.timestamp,
            category: "ui.slowClickDetected",
            data: {
              ...B.data,
              url: tK.location.href,
              route: _.getCurrentRoute(),
              timeAfterClickMs: C,
              endReason: R,
              clickCount: L || 1
            }
          };
          this._addBreadcrumbEvent(_, F);
          return;
        }
        if (L > 1) {
          let m = {
            type: "default",
            message: B.message,
            timestamp: B.timestamp,
            category: "ui.multiClick",
            data: {
              ...B.data,
              url: tK.location.href,
              route: _.getCurrentRoute(),
              clickCount: L,
              metric: true
            }
          };
          this._addBreadcrumbEvent(_, m);
        }
      }
      _scheduleCheckClicks() {
        if (this._checkClickTimeout) {
          clearTimeout(this._checkClickTimeout);
        }
        this._checkClickTimeout = getNativeImplementation_setTimeout(() => this._checkClicks(), 1000);
      }
    };
    let rf = ["A", "BUTTON", "INPUT"];
    function nowInSeconds() {
      return Date.now() / 1000;
    }
    function createBreadcrumb(m) {
      return {
        timestamp: Date.now() / 1000,
        type: "default",
        ...m
      };
    }
    (eh = eg ||= {})[eh.Document = 0] = "Document";
    eh[eh.DocumentType = 1] = "DocumentType";
    eh[eh.Element = 2] = "Element";
    eh[eh.Text = 3] = "Text";
    eh[eh.CDATA = 4] = "CDATA";
    eh[eh.Comment = 5] = "Comment";
    let rm = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]);
    let handleDomListener = m => _ => {
      if (!m.isEnabled()) {
        return;
      }
      let C = function (m) {
        let {
          target: _,
          message: C
        } = function (m) {
          let _;
          let C = m.name === "click";
          let R = null;
          try {
            R = C ? getClickTargetNode(m.event) : getTargetNode(m.event);
            _ = (0, eY.Rt)(R, {
              maxStringLength: 200
            }) || "<unknown>";
          } catch (m) {
            _ = "<unknown>";
          }
          return {
            target: R,
            message: _
          };
        }(m);
        return createBreadcrumb({
          category: `ui.${m.name}`,
          ...getBaseDomBreadcrumb(_, C)
        });
      }(_);
      if (!C) {
        return;
      }
      let R = _.name === "click";
      let L = R ? _.event : undefined;
      if (R && m.clickDetector && L && L.target && !L.altKey && !L.metaKey && !L.ctrlKey && !L.shiftKey) {
        (function (m, _, C) {
          m.handleClick(_, C);
        })(m.clickDetector, C, getClickTargetNode(_.event));
      }
      addBreadcrumbEvent(m, C);
    };
    function getBaseDomBreadcrumb(m, _) {
      let C = record.mirror.getId(m);
      let R = C && record.mirror.getNode(C);
      let L = R && record.mirror.getMeta(R);
      let B = L && L.type === eg.Element ? L : null;
      return {
        message: _,
        data: B ? {
          nodeId: C,
          node: {
            id: C,
            tagName: B.tagName,
            textContent: Array.from(B.childNodes).map(m => m.type === eg.Text && m.textContent).filter(Boolean).map(m => m.trim()).join(""),
            attributes: function (m) {
              let _ = {};
              if (!m["data-sentry-component"] && m["data-sentry-element"]) {
                m["data-sentry-component"] = m["data-sentry-element"];
              }
              for (let C in m) {
                if (rm.has(C)) {
                  let R = C;
                  if (C === "data-testid" || C === "data-test-id") {
                    R = "testId";
                  }
                  _[R] = m[C];
                }
              }
              return _;
            }(B.attributes)
          }
        } : {}
      };
    }
    let rg = {
      resource: function (m) {
        let {
          entryType: _,
          initiatorType: C,
          name: R,
          responseEnd: L,
          startTime: B,
          decodedBodySize: F,
          encodedBodySize: U,
          responseStatus: H,
          transferSize: q
        } = m;
        if (["fetch", "xmlhttprequest"].includes(C)) {
          return null;
        } else {
          return {
            type: `${_}.${C}`,
            start: esm_getAbsoluteTime(B),
            end: esm_getAbsoluteTime(L),
            name: R,
            data: {
              size: q,
              statusCode: H,
              decodedBodySize: F,
              encodedBodySize: U
            }
          };
        }
      },
      paint: function (m) {
        let {
          duration: _,
          entryType: C,
          name: R,
          startTime: L
        } = m;
        let B = esm_getAbsoluteTime(L);
        return {
          type: C,
          name: R,
          start: B,
          end: B + _,
          data: undefined
        };
      },
      navigation: function (m) {
        let {
          entryType: _,
          name: C,
          decodedBodySize: R,
          duration: L,
          domComplete: B,
          encodedBodySize: F,
          domContentLoadedEventStart: U,
          domContentLoadedEventEnd: H,
          domInteractive: q,
          loadEventStart: V,
          loadEventEnd: X,
          redirectCount: K,
          startTime: Y,
          transferSize: Q,
          type: et
        } = m;
        if (L === 0) {
          return null;
        } else {
          return {
            type: `${_}.${et}`,
            start: esm_getAbsoluteTime(Y),
            end: esm_getAbsoluteTime(B),
            name: C,
            data: {
              size: Q,
              decodedBodySize: R,
              encodedBodySize: F,
              duration: L,
              domInteractive: q,
              domContentLoadedEventStart: U,
              domContentLoadedEventEnd: H,
              loadEventStart: V,
              loadEventEnd: X,
              domComplete: B,
              redirectCount: K
            }
          };
        }
      }
    };
    function webVitalHandler(m, _) {
      return ({
        metric: C
      }) => void _.replayPerformanceEntries.push(m(C));
    }
    function createPerformanceEntry(m) {
      let _ = rg[m.entryType];
      if (_) {
        return _(m);
      } else {
        return null;
      }
    }
    function esm_getAbsoluteTime(m) {
      return ((eU.Z1 || tK.performance.timeOrigin) + m) / 1000;
    }
    function getLargestContentfulPaint(m) {
      let _ = m.entries[m.entries.length - 1];
      let C = _ && _.element ? [_.element] : undefined;
      return getWebVital(m, "largest-contentful-paint", C);
    }
    function getCumulativeLayoutShift(m) {
      let _ = [];
      let C = [];
      for (let R of m.entries) {
        if (R.sources !== undefined) {
          let m = [];
          for (let _ of R.sources) {
            if (_.node) {
              C.push(_.node);
              let R = record.mirror.getId(_.node);
              if (R) {
                m.push(R);
              }
            }
          }
          _.push({
            value: R.value,
            nodeIds: m.length ? m : undefined
          });
        }
      }
      return getWebVital(m, "cumulative-layout-shift", C, _);
    }
    function getFirstInputDelay(m) {
      let _ = m.entries[m.entries.length - 1];
      let C = _ && _.target ? [_.target] : undefined;
      return getWebVital(m, "first-input-delay", C);
    }
    function getInteractionToNextPaint(m) {
      let _ = m.entries[m.entries.length - 1];
      let C = _ && _.target ? [_.target] : undefined;
      return getWebVital(m, "interaction-to-next-paint", C);
    }
    function getWebVital(m, _, C, R) {
      let L = m.value;
      let B = m.rating;
      let F = esm_getAbsoluteTime(L);
      return {
        type: "web-vital",
        name: _,
        start: F,
        end: F,
        data: {
          value: L,
          size: L,
          rating: B,
          nodeIds: C ? C.map(m => record.mirror.getId(m)) : undefined,
          attributions: R
        }
      };
    }
    let EventBufferSizeExceededError = class EventBufferSizeExceededError extends Error {
      constructor() {
        super("Event buffer exceeded maximum size of 20000000.");
      }
    };
    let EventBufferArray = class EventBufferArray {
      constructor() {
        this.events = [];
        this._totalSize = 0;
        this.hasCheckout = false;
      }
      get hasEvents() {
        return this.events.length > 0;
      }
      get type() {
        return "sync";
      }
      destroy() {
        this.events = [];
      }
      async addEvent(m) {
        let _ = JSON.stringify(m).length;
        this._totalSize += _;
        if (this._totalSize > 20000000) {
          throw new EventBufferSizeExceededError();
        }
        this.events.push(m);
      }
      finish() {
        return new Promise(m => {
          let _ = this.events;
          this.clear();
          m(JSON.stringify(_));
        });
      }
      clear() {
        this.events = [];
        this._totalSize = 0;
        this.hasCheckout = false;
      }
      getEarliestTimestamp() {
        let m = this.events.map(m => m.timestamp).sort()[0];
        if (m) {
          return timestampToMs(m);
        } else {
          return null;
        }
      }
    };
    let WorkerHandler = class WorkerHandler {
      constructor(m) {
        this._worker = m;
        this._id = 0;
      }
      ensureReady() {
        this._ensureReadyPromise ||= new Promise((m, _) => {
          this._worker.addEventListener("message", ({
            data: C
          }) => {
            if (C.success) {
              m();
            } else {
              _();
            }
          }, {
            once: true
          });
          this._worker.addEventListener("error", m => {
            _(m);
          }, {
            once: true
          });
        });
        return this._ensureReadyPromise;
      }
      destroy() {
        this._worker.terminate();
      }
      postMessage(m, _) {
        let C = this._getAndIncrementId();
        return new Promise((R, L) => {
          let listener = ({
            data: _
          }) => {
            if (_.method === m && _.id === C) {
              this._worker.removeEventListener("message", listener);
              if (!_.success) {
                L(Error("Error in compression worker"));
                return;
              }
              R(_.response);
            }
          };
          this._worker.addEventListener("message", listener);
          this._worker.postMessage({
            id: C,
            method: m,
            arg: _
          });
        });
      }
      _getAndIncrementId() {
        return this._id++;
      }
    };
    let EventBufferCompressionWorker = class EventBufferCompressionWorker {
      constructor(m) {
        this._worker = new WorkerHandler(m);
        this._earliestTimestamp = null;
        this._totalSize = 0;
        this.hasCheckout = false;
      }
      get hasEvents() {
        return !!this._earliestTimestamp;
      }
      get type() {
        return "worker";
      }
      ensureReady() {
        return this._worker.ensureReady();
      }
      destroy() {
        this._worker.destroy();
      }
      addEvent(m) {
        let _ = timestampToMs(m.timestamp);
        if (!this._earliestTimestamp || _ < this._earliestTimestamp) {
          this._earliestTimestamp = _;
        }
        let C = JSON.stringify(m);
        this._totalSize += C.length;
        if (this._totalSize > 20000000) {
          return Promise.reject(new EventBufferSizeExceededError());
        } else {
          return this._sendEventToWorker(C);
        }
      }
      finish() {
        return this._finishRequest();
      }
      clear() {
        this._earliestTimestamp = null;
        this._totalSize = 0;
        this.hasCheckout = false;
        this._worker.postMessage("clear").then(null, m => {});
      }
      getEarliestTimestamp() {
        return this._earliestTimestamp;
      }
      _sendEventToWorker(m) {
        return this._worker.postMessage("addEvent", m);
      }
      async _finishRequest() {
        let m = await this._worker.postMessage("finish");
        this._earliestTimestamp = null;
        this._totalSize = 0;
        return m;
      }
    };
    let EventBufferProxy = class EventBufferProxy {
      constructor(m) {
        this._fallback = new EventBufferArray();
        this._compression = new EventBufferCompressionWorker(m);
        this._used = this._fallback;
        this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();
      }
      get type() {
        return this._used.type;
      }
      get hasEvents() {
        return this._used.hasEvents;
      }
      get hasCheckout() {
        return this._used.hasCheckout;
      }
      set hasCheckout(m) {
        this._used.hasCheckout = m;
      }
      destroy() {
        this._fallback.destroy();
        this._compression.destroy();
      }
      clear() {
        return this._used.clear();
      }
      getEarliestTimestamp() {
        return this._used.getEarliestTimestamp();
      }
      addEvent(m) {
        return this._used.addEvent(m);
      }
      async finish() {
        await this.ensureWorkerIsLoaded();
        return this._used.finish();
      }
      ensureWorkerIsLoaded() {
        return this._ensureWorkerIsLoadedPromise;
      }
      async _ensureWorkerIsLoaded() {
        try {
          await this._compression.ensureReady();
        } catch (m) {
          return;
        }
        await this._switchToCompressionWorker();
      }
      async _switchToCompressionWorker() {
        let {
          events: m,
          hasCheckout: _
        } = this._fallback;
        let C = [];
        for (let _ of m) {
          C.push(this._compression.addEvent(_));
        }
        this._compression.hasCheckout = _;
        this._used = this._compression;
        try {
          await Promise.all(C);
          this._fallback.clear();
        } catch (m) {}
      }
    };
    function hasSessionStorage() {
      try {
        return "sessionStorage" in tK && !!tK.sessionStorage;
      } catch (m) {
        return false;
      }
    }
    function isSampled(m) {
      return m !== undefined && Math.random() < m;
    }
    function makeSession(m) {
      let _ = Date.now();
      let C = m.id || (0, eb.DM)();
      let R = m.started || _;
      let L = m.lastActivity || _;
      let B = m.segmentId || 0;
      let F = m.sampled;
      let U = m.previousSessionId;
      return {
        id: C,
        started: R,
        lastActivity: L,
        segmentId: B,
        sampled: F,
        previousSessionId: U
      };
    }
    function saveSession(m) {
      if (hasSessionStorage()) {
        try {
          tK.sessionStorage.setItem(tZ, JSON.stringify(m));
        } catch (m) {}
      }
    }
    function createSession({
      sessionSampleRate: m,
      allowBuffering: _,
      stickySession: C = false
    }, {
      previousSessionId: R
    } = {}) {
      let L = isSampled(m) ? "session" : !!_ && "buffer";
      let B = makeSession({
        sampled: L,
        previousSessionId: R
      });
      if (C) {
        saveSession(B);
      }
      return B;
    }
    function isExpired(m, _, C = +new Date()) {
      return m === null || _ === undefined || _ < 0 || _ !== 0 && m + _ <= C;
    }
    function isSessionExpired(m, {
      maxReplayDuration: _,
      sessionIdleExpire: C,
      targetTime: R = Date.now()
    }) {
      return isExpired(m.started, _, R) || isExpired(m.lastActivity, C, R);
    }
    function shouldRefreshSession(m, {
      sessionIdleExpire: _,
      maxReplayDuration: C
    }) {
      return !!isSessionExpired(m, {
        sessionIdleExpire: _,
        maxReplayDuration: C
      }) && (m.sampled !== "buffer" || m.segmentId !== 0);
    }
    function loadOrCreateSession({
      sessionIdleExpire: m,
      maxReplayDuration: _,
      previousSessionId: C
    }, R) {
      let L = R.stickySession && function () {
        if (!hasSessionStorage()) {
          return null;
        }
        try {
          let m = tK.sessionStorage.getItem(tZ);
          if (!m) {
            return null;
          }
          let _ = JSON.parse(m);
          return makeSession(_);
        } catch (m) {
          return null;
        }
      }();
      if (L) {
        if (shouldRefreshSession(L, {
          sessionIdleExpire: m,
          maxReplayDuration: _
        })) {
          return createSession(R, {
            previousSessionId: L.id
          });
        } else {
          return L;
        }
      } else {
        return createSession(R, {
          previousSessionId: C
        });
      }
    }
    function addEventSync(m, _, C) {
      return !!shouldAddEvent(m, _) && (_addEvent(m, _, C), true);
    }
    async function _addEvent(m, _, C) {
      if (!m.eventBuffer) {
        return null;
      }
      try {
        if (C && m.recordingMode === "buffer") {
          m.eventBuffer.clear();
        }
        if (C) {
          m.eventBuffer.hasCheckout = true;
        }
        let R = m.getOptions();
        let L = function (m, _) {
          try {
            if (typeof _ == "function" && m.type === ri.Custom) {
              return _(m);
            }
          } catch (m) {
            return null;
          }
          return m;
        }(_, R.beforeAddRecordingEvent);
        if (!L) {
          return;
        }
        return await m.eventBuffer.addEvent(L);
      } catch (R) {
        let _ = R && R instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent";
        m.handleException(R);
        await m.stop({
          reason: _
        });
        let C = (0, eI.s3)();
        if (C) {
          C.recordDroppedEvent("internal_sdk_error", "replay");
        }
      }
    }
    function shouldAddEvent(m, _) {
      if (!m.eventBuffer || m.isPaused() || !m.isEnabled()) {
        return false;
      }
      let C = timestampToMs(_.timestamp);
      return !(C + m.timeouts.sessionIdlePause < Date.now()) && !(C > m.getContext().initialTimestamp + m.getOptions().maxReplayDuration);
    }
    function esm_isTransactionEvent(m) {
      return m.type === "transaction";
    }
    function isFeedbackEvent(m) {
      return m.type === "feedback";
    }
    function isBreadcrumbWithCategory(m) {
      return !!m.category;
    }
    function createPerformanceSpans(m, _) {
      return _.map(({
        type: _,
        start: C,
        end: R,
        name: L,
        data: B
      }) => {
        let F = m.throttledAddEvent({
          type: ri.Custom,
          timestamp: C,
          data: {
            tag: "performanceSpan",
            payload: {
              op: _,
              description: L,
              startTimestamp: C,
              endTimestamp: R,
              data: B
            }
          }
        });
        if (typeof F == "string") {
          return Promise.resolve(null);
        } else {
          return F;
        }
      });
    }
    function addNetworkBreadcrumb(m, _) {
      if (m.isEnabled() && _ !== null && !function (m, _) {
        let C = _ && _.getDsn();
        let R = _ && _.getOptions().tunnel;
        return !!C && m.includes(C.host) || !!R && removeTrailingSlash(m) === removeTrailingSlash(R);
      }(_.name, (0, eI.s3)())) {
        m.addUpdate(() => {
          createPerformanceSpans(m, [_]);
          return true;
        });
      }
    }
    function getBodySize(m) {
      if (!m) {
        return;
      }
      let _ = new TextEncoder();
      try {
        if (typeof m == "string") {
          return _.encode(m).length;
        }
        if (m instanceof URLSearchParams) {
          return _.encode(m.toString()).length;
        }
        if (m instanceof FormData) {
          let C = _serializeFormData(m);
          return _.encode(C).length;
        }
        if (m instanceof Blob) {
          return m.size;
        }
        if (m instanceof ArrayBuffer) {
          return m.byteLength;
        }
      } catch (m) {}
    }
    function parseContentLengthHeader(m) {
      if (!m) {
        return;
      }
      let _ = parseInt(m, 10);
      if (isNaN(_)) {
        return undefined;
      } else {
        return _;
      }
    }
    function getBodyString(m) {
      try {
        if (typeof m == "string") {
          return [m];
        }
        if (m instanceof URLSearchParams) {
          return [m.toString()];
        }
        if (m instanceof FormData) {
          return [_serializeFormData(m)];
        }
        if (!m) {
          return [undefined];
        }
      } catch (m) {
        return [undefined, "BODY_PARSE_ERROR"];
      }
      return [undefined, "UNPARSEABLE_BODY_TYPE"];
    }
    function mergeWarning(m, _) {
      if (!m) {
        return {
          headers: {},
          size: undefined,
          _meta: {
            warnings: [_]
          }
        };
      }
      let C = {
        ...m._meta
      };
      let R = C.warnings || [];
      C.warnings = [...R, _];
      m._meta = C;
      return m;
    }
    function makeNetworkReplayBreadcrumb(m, _) {
      if (!_) {
        return null;
      }
      let {
        startTimestamp: C,
        endTimestamp: R,
        url: L,
        method: B,
        statusCode: F,
        request: U,
        response: H
      } = _;
      let q = {
        type: m,
        start: C / 1000,
        end: R / 1000,
        name: L,
        data: (0, ex.Jr)({
          method: B,
          statusCode: F,
          request: U,
          response: H
        })
      };
      return q;
    }
    function buildSkippedNetworkRequestOrResponse(m) {
      return {
        headers: {},
        size: m,
        _meta: {
          warnings: ["URL_SKIPPED"]
        }
      };
    }
    function buildNetworkRequestOrResponse(m, _, C) {
      if (!_ && Object.keys(m).length === 0) {
        return;
      }
      if (!_) {
        return {
          headers: m
        };
      }
      if (!C) {
        return {
          headers: m,
          size: _
        };
      }
      let R = {
        headers: m,
        size: _
      };
      let {
        body: L,
        warnings: B
      } = function (m) {
        if (!m || typeof m != "string") {
          return {
            body: m
          };
        }
        let _ = m.length > 150000;
        let C = function (m) {
          let _ = m[0];
          let C = m[m.length - 1];
          return _ === "[" && C === "]" || _ === "{" && C === "}";
        }(m);
        if (_) {
          let _ = m.slice(0, 150000);
          if (C) {
            return {
              body: _,
              warnings: ["MAYBE_JSON_TRUNCATED"]
            };
          } else {
            return {
              body: `${_}`,
              warnings: ["TEXT_TRUNCATED"]
            };
          }
        }
        if (C) {
          try {
            let _ = JSON.parse(m);
            return {
              body: _
            };
          } catch (m) {}
        }
        return {
          body: m
        };
      }(C);
      R.body = L;
      if (B && B.length > 0) {
        R._meta = {
          warnings: B
        };
      }
      return R;
    }
    function getAllowedHeaders(m, _) {
      return Object.entries(m).reduce((C, [R, L]) => {
        let B = R.toLowerCase();
        if (_.includes(B) && m[R]) {
          C[B] = L;
        }
        return C;
      }, {});
    }
    function _serializeFormData(m) {
      return new URLSearchParams(m).toString();
    }
    function urlMatches(m, _) {
      let C = function (m, _ = tK.document.baseURI) {
        if (m.startsWith("http://") || m.startsWith("https://") || m.startsWith(tK.location.origin)) {
          return m;
        }
        let C = new URL(m, _);
        if (C.origin !== new URL(_).origin) {
          return m;
        }
        let R = C.href;
        if (!m.endsWith("/") && R.endsWith("/")) {
          return R.slice(0, -1);
        } else {
          return R;
        }
      }(m);
      return (0, eS.U0)(C, _);
    }
    async function captureFetchBreadcrumbToReplay(m, _, C) {
      try {
        let R = await _prepareFetchData(m, _, C);
        let L = makeNetworkReplayBreadcrumb("resource.fetch", R);
        addNetworkBreadcrumb(C.replay, L);
      } catch (m) {}
    }
    async function _prepareFetchData(m, _, C) {
      let R = Date.now();
      let {
        startTimestamp: L = R,
        endTimestamp: B = R
      } = _;
      let {
        url: F,
        method: U,
        status_code: H = 0,
        request_body_size: q,
        response_body_size: V
      } = m.data;
      let X = urlMatches(F, C.networkDetailAllowUrls) && !urlMatches(F, C.networkDetailDenyUrls);
      let K = X ? function ({
        networkCaptureBodies: m,
        networkRequestHeaders: _
      }, C, R) {
        let L = C ? C.length === 1 && typeof C[0] != "string" ? getHeadersFromOptions(C[0], _) : C.length === 2 ? getHeadersFromOptions(C[1], _) : {} : {};
        if (!m) {
          return buildNetworkRequestOrResponse(L, R, undefined);
        }
        let B = _getFetchRequestArgBody(C);
        let [F, U] = getBodyString(B);
        let H = buildNetworkRequestOrResponse(L, R, F);
        if (U) {
          return mergeWarning(H, U);
        } else {
          return H;
        }
      }(C, _.input, q) : buildSkippedNetworkRequestOrResponse(q);
      let Y = await _getResponseInfo(X, C, _.response, V);
      return {
        startTimestamp: L,
        endTimestamp: B,
        url: F,
        method: U,
        statusCode: H,
        request: K,
        response: Y
      };
    }
    async function _getResponseInfo(m, {
      networkCaptureBodies: _,
      networkResponseHeaders: C
    }, R, L) {
      if (!m && L !== undefined) {
        return buildSkippedNetworkRequestOrResponse(L);
      }
      let B = R ? getAllHeaders(R.headers, C) : {};
      if (!R || !_ && L !== undefined) {
        return buildNetworkRequestOrResponse(B, L, undefined);
      }
      let [F, U] = await _parseFetchResponseBody(R);
      let H = function (m, {
        networkCaptureBodies: _,
        responseBodySize: C,
        captureDetails: R,
        headers: L
      }) {
        try {
          let B = m && m.length && C === undefined ? getBodySize(m) : C;
          if (!R) {
            return buildSkippedNetworkRequestOrResponse(B);
          }
          if (_) {
            return buildNetworkRequestOrResponse(L, B, m);
          }
          return buildNetworkRequestOrResponse(L, B, undefined);
        } catch (m) {
          return buildNetworkRequestOrResponse(L, C, undefined);
        }
      }(F, {
        networkCaptureBodies: _,
        responseBodySize: L,
        captureDetails: m,
        headers: B
      });
      if (U) {
        return mergeWarning(H, U);
      } else {
        return H;
      }
    }
    async function _parseFetchResponseBody(m) {
      let _ = function (m) {
        try {
          return m.clone();
        } catch (m) {}
      }(m);
      if (!_) {
        return [undefined, "BODY_PARSE_ERROR"];
      }
      try {
        let m = await new Promise((m, C) => {
          let R = getNativeImplementation_setTimeout(() => C(Error("Timeout while trying to read response body")), 500);
          _getResponseText(_).then(_ => m(_), m => C(m)).finally(() => clearTimeout(R));
        });
        return [m];
      } catch (m) {
        return [undefined, "BODY_PARSE_ERROR"];
      }
    }
    function _getFetchRequestArgBody(m = []) {
      if (m.length === 2 && typeof m[1] == "object") {
        return m[1].body;
      }
    }
    function getAllHeaders(m, _) {
      let C = {};
      _.forEach(_ => {
        if (m.get(_)) {
          C[_] = m.get(_);
        }
      });
      return C;
    }
    function getHeadersFromOptions(m, _) {
      if (!m) {
        return {};
      }
      let C = m.headers;
      if (C) {
        if (C instanceof Headers) {
          return getAllHeaders(C, _);
        } else if (Array.isArray(C)) {
          return {};
        } else {
          return getAllowedHeaders(C, _);
        }
      } else {
        return {};
      }
    }
    async function _getResponseText(m) {
      return await m.text();
    }
    async function captureXhrBreadcrumbToReplay(m, _, C) {
      try {
        let R = function (m, _, C) {
          let R = Date.now();
          let {
            startTimestamp: L = R,
            endTimestamp: B = R,
            input: F,
            xhr: U
          } = _;
          let {
            url: H,
            method: q,
            status_code: V = 0,
            request_body_size: X,
            response_body_size: K
          } = m.data;
          if (!H) {
            return null;
          }
          if (!U || !urlMatches(H, C.networkDetailAllowUrls) || urlMatches(H, C.networkDetailDenyUrls)) {
            let m = buildSkippedNetworkRequestOrResponse(X);
            let _ = buildSkippedNetworkRequestOrResponse(K);
            return {
              startTimestamp: L,
              endTimestamp: B,
              url: H,
              method: q,
              statusCode: V,
              request: m,
              response: _
            };
          }
          let Y = U[eZ];
          let Q = Y ? getAllowedHeaders(Y.request_headers, C.networkRequestHeaders) : {};
          let et = getAllowedHeaders(function (m) {
            let _ = m.getAllResponseHeaders();
            if (_) {
              return _.split("\r\n").reduce((m, _) => {
                let [C, R] = _.split(": ");
                if (R) {
                  m[C.toLowerCase()] = R;
                }
                return m;
              }, {});
            } else {
              return {};
            }
          }(U), C.networkResponseHeaders);
          let [er, en] = C.networkCaptureBodies ? getBodyString(F) : [undefined];
          let [ei, eo] = C.networkCaptureBodies ? function (m) {
            let _ = [];
            try {
              return [m.responseText];
            } catch (m) {
              _.push(m);
            }
            try {
              return function (m, _) {
                try {
                  if (typeof m == "string") {
                    return [m];
                  }
                  if (m instanceof Document) {
                    return [m.body.outerHTML];
                  }
                  if (_ === "json" && m && typeof m == "object") {
                    return [JSON.stringify(m)];
                  }
                  if (!m) {
                    return [undefined];
                  }
                } catch (m) {
                  return [undefined, "BODY_PARSE_ERROR"];
                }
                return [undefined, "UNPARSEABLE_BODY_TYPE"];
              }(m.response, m.responseType);
            } catch (m) {
              _.push(m);
            }
            return [undefined];
          }(U) : [undefined];
          let ea = buildNetworkRequestOrResponse(Q, X, er);
          let es = buildNetworkRequestOrResponse(et, K, ei);
          return {
            startTimestamp: L,
            endTimestamp: B,
            url: H,
            method: q,
            statusCode: V,
            request: en ? mergeWarning(ea, en) : ea,
            response: eo ? mergeWarning(es, eo) : es
          };
        }(m, _, C);
        let L = makeNetworkReplayBreadcrumb("resource.xhr", R);
        addNetworkBreadcrumb(C.replay, L);
      } catch (m) {}
    }
    async function addMemoryEntry(m) {
      try {
        return Promise.all(createPerformanceSpans(m, [function (m) {
          let {
            jsHeapSizeLimit: _,
            totalJSHeapSize: C,
            usedJSHeapSize: R
          } = m;
          let L = Date.now() / 1000;
          return {
            type: "memory",
            name: "memory",
            start: L,
            end: L,
            data: {
              memory: {
                jsHeapSizeLimit: _,
                totalJSHeapSize: C,
                usedJSHeapSize: R
              }
            }
          };
        }(tK.performance.memory)]));
      } catch (m) {
        return [];
      }
    }
    async function prepareReplayEvent({
      client: m,
      scope: _,
      replayId: C,
      event: R
    }) {
      let L = typeof m._integrations != "object" || m._integrations === null || Array.isArray(m._integrations) ? undefined : Object.keys(m._integrations);
      let B = {
        event_id: C,
        integrations: L
      };
      m.emit("preprocessEvent", R, B);
      let F = await (0, eG.R)(m.getOptions(), R, B, _, m, (0, eI.aF)());
      if (!F) {
        return null;
      }
      F.platform = F.platform || "javascript";
      let U = m.getSdkMetadata();
      let {
        name: H,
        version: q
      } = U && U.sdk || {};
      F.sdk = {
        ...F.sdk,
        name: H || "sentry.javascript.unknown",
        version: q || "0.0.0"
      };
      return F;
    }
    async function sendReplayRequest({
      recordingData: m,
      replayId: _,
      segmentId: C,
      eventContext: R,
      timestamp: L,
      session: B
    }) {
      var F;
      let U;
      let H = function ({
        recordingData: m,
        headers: _
      }) {
        let C;
        let R = `${JSON.stringify(_)}
`;
        if (typeof m == "string") {
          C = `${R}${m}`;
        } else {
          let _ = new TextEncoder();
          let L = _.encode(R);
          (C = new Uint8Array(L.length + m.length)).set(L);
          C.set(m, L.length);
        }
        return C;
      }({
        recordingData: m,
        headers: {
          segment_id: C
        }
      });
      let {
        urls: q,
        errorIds: V,
        traceIds: X,
        initialTimestamp: K
      } = R;
      let Y = (0, eI.s3)();
      let Q = (0, eI.nZ)();
      let et = Y && Y.getTransport();
      let er = Y && Y.getDsn();
      if (!Y || !et || !er || !B.sampled) {
        return (0, ej.WD)({});
      }
      let en = {
        type: "replay_event",
        replay_start_timestamp: K / 1000,
        timestamp: L / 1000,
        error_ids: V,
        trace_ids: X,
        urls: q,
        replay_id: _,
        segment_id: C,
        replay_type: B.sampled
      };
      let ei = await prepareReplayEvent({
        scope: Q,
        client: Y,
        replayId: _,
        event: en
      });
      if (!ei) {
        Y.recordDroppedEvent("event_processor", "replay", en);
        return (0, ej.WD)({});
      }
      delete ei.sdkProcessingMetadata;
      F = Y.getOptions().tunnel;
      let eo = (0, eF.Jd)((0, eF.Cd)(ei, (0, eF.HY)(ei), F, er), [[{
        type: "replay_event"
      }, ei], [{
        type: "replay_recording",
        length: typeof H == "string" ? new TextEncoder().encode(H).length : H.length
      }, H]]);
      try {
        U = await et.send(eo);
      } catch (_) {
        let m = Error(tY);
        try {
          m.cause = _;
        } catch (m) {}
        throw m;
      }
      if (typeof U.statusCode == "number" && (U.statusCode < 200 || U.statusCode >= 300)) {
        throw new TransportStatusCodeError(U.statusCode);
      }
      let ea = updateRateLimits({}, U);
      if (isRateLimited(ea, "replay")) {
        throw new RateLimitError(ea);
      }
      return U;
    }
    let TransportStatusCodeError = class TransportStatusCodeError extends Error {
      constructor(m) {
        super(`Transport returned status code ${m}`);
      }
    };
    let RateLimitError = class RateLimitError extends Error {
      constructor(m) {
        super("Rate limit hit");
        this.rateLimits = m;
      }
    };
    async function sendReplay(m, _ = {
      count: 0,
      interval: 5000
    }) {
      let {
        recordingData: C,
        onError: R
      } = m;
      if (C.length) {
        try {
          await sendReplayRequest(m);
          return true;
        } catch (C) {
          if (C instanceof TransportStatusCodeError || C instanceof RateLimitError) {
            throw C;
          }
          (0, e_.v)("Replays", {
            _retryCount: _.count
          });
          if (R) {
            R(C);
          }
          if (_.count >= 3) {
            let m = Error(`${tY} - max retries exceeded`);
            try {
              m.cause = C;
            } catch (m) {}
            throw m;
          }
          _.interval *= ++_.count;
          return new Promise((C, R) => {
            getNativeImplementation_setTimeout(async () => {
              try {
                await sendReplay(m, _);
                C(true);
              } catch (m) {
                R(m);
              }
            }, _.interval);
          });
        }
      }
    }
    let ry = "__THROTTLED";
    let ReplayContainer = class ReplayContainer {
      constructor({
        options: m,
        recordingOptions: _
      }) {
        ReplayContainer.prototype.__init.call(this);
        ReplayContainer.prototype.__init2.call(this);
        ReplayContainer.prototype.__init3.call(this);
        ReplayContainer.prototype.__init4.call(this);
        ReplayContainer.prototype.__init5.call(this);
        ReplayContainer.prototype.__init6.call(this);
        this.eventBuffer = null;
        this.performanceEntries = [];
        this.replayPerformanceEntries = [];
        this.recordingMode = "session";
        this.timeouts = {
          sessionIdlePause: 300000,
          sessionIdleExpire: 900000
        };
        this._lastActivity = Date.now();
        this._isEnabled = false;
        this._isPaused = false;
        this._requiresManualStart = false;
        this._hasInitializedCoreListeners = false;
        this._context = {
          errorIds: new Set(),
          traceIds: new Set(),
          urls: [],
          initialTimestamp: Date.now(),
          initialUrl: ""
        };
        this._recordingOptions = _;
        this._options = m;
        this._debouncedFlush = function (m, _, C) {
          let R;
          let L;
          let B;
          let F = C && C.maxWait ? Math.max(C.maxWait, _) : 0;
          function invokeFunc() {
            cancelTimers();
            return R = m();
          }
          function cancelTimers() {
            if (L !== undefined) {
              clearTimeout(L);
            }
            if (B !== undefined) {
              clearTimeout(B);
            }
            L = B = undefined;
          }
          function debounced() {
            if (L) {
              clearTimeout(L);
            }
            L = getNativeImplementation_setTimeout(invokeFunc, _);
            if (F && B === undefined) {
              B = getNativeImplementation_setTimeout(invokeFunc, F);
            }
            return R;
          }
          debounced.cancel = cancelTimers;
          debounced.flush = function () {
            if (L !== undefined || B !== undefined) {
              return invokeFunc();
            } else {
              return R;
            }
          };
          return debounced;
        }(() => this._flush(), this._options.flushMinDelay, {
          maxWait: this._options.flushMaxDelay
        });
        this._throttledAddEvent = function (m, _, C) {
          let R = new Map();
          let _cleanup = m => {
            let _ = m - 5;
            R.forEach((m, C) => {
              if (C < _) {
                R.delete(C);
              }
            });
          };
          let _getTotalCount = () => [...R.values()].reduce((m, _) => m + _, 0);
          let L = false;
          return (..._) => {
            let C = Math.floor(Date.now() / 1000);
            _cleanup(C);
            if (_getTotalCount() >= 300) {
              let m = L;
              L = true;
              if (m) {
                return "__SKIPPED";
              } else {
                return ry;
              }
            }
            L = false;
            let B = R.get(C) || 0;
            R.set(C, B + 1);
            return m(..._);
          };
        }((m, _) => shouldAddEvent(this, m) ? _addEvent(this, m, _) : Promise.resolve(null), 0, 0);
        let {
          slowClickTimeout: C,
          slowClickIgnoreSelectors: R
        } = this.getOptions();
        let L = C ? {
          threshold: Math.min(3000, C),
          timeout: C,
          scrollTimeout: 300,
          ignoreSelector: R ? R.join(",") : ""
        } : undefined;
        if (L) {
          this.clickDetector = new ClickDetector(this, L);
        }
      }
      getContext() {
        return this._context;
      }
      isEnabled() {
        return this._isEnabled;
      }
      isPaused() {
        return this._isPaused;
      }
      isRecordingCanvas() {
        return !!this._canvas;
      }
      getOptions() {
        return this._options;
      }
      handleException(m) {
        if (this._options.onError) {
          this._options.onError(m);
        }
      }
      initializeSampling(m) {
        let {
          errorSampleRate: _,
          sessionSampleRate: C
        } = this._options;
        let R = _ <= 0 && C <= 0;
        this._requiresManualStart = R;
        if (!R && (this._initializeSessionForSampling(m), this.session) && this.session.sampled !== false) {
          this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session";
          this._initializeRecording();
        }
      }
      start() {
        if (this._isEnabled && this.recordingMode === "session" || this._isEnabled && this.recordingMode === "buffer") {
          return;
        }
        this._updateUserActivity();
        let m = loadOrCreateSession({
          maxReplayDuration: this._options.maxReplayDuration,
          sessionIdleExpire: this.timeouts.sessionIdleExpire
        }, {
          stickySession: this._options.stickySession,
          sessionSampleRate: 1,
          allowBuffering: false
        });
        this.session = m;
        this._initializeRecording();
      }
      startBuffering() {
        if (this._isEnabled) {
          return;
        }
        let m = loadOrCreateSession({
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          maxReplayDuration: this._options.maxReplayDuration
        }, {
          stickySession: this._options.stickySession,
          sessionSampleRate: 0,
          allowBuffering: true
        });
        this.session = m;
        this.recordingMode = "buffer";
        this._initializeRecording();
      }
      startRecording() {
        try {
          var m;
          let _;
          let C = this._canvas;
          this._stopRecording = record({
            ...this._recordingOptions,
            ...(this.recordingMode === "buffer" ? {
              checkoutEveryNms: 60000
            } : this._options._experiments.continuousCheckout && {
              checkoutEveryNms: Math.max(360000, this._options._experiments.continuousCheckout)
            }),
            emit: (m = this, _ = false, (C, R) => {
              if (!m.checkAndHandleExpiredSession()) {
                return;
              }
              let L = R || !_;
              _ = true;
              if (m.clickDetector) {
                (function (m, _) {
                  try {
                    if (_.type !== 3) {
                      return;
                    }
                    let {
                      source: C
                    } = _.data;
                    if (rh.has(C)) {
                      m.registerMutation(_.timestamp);
                    }
                    if (C === ro.Scroll) {
                      m.registerScroll(_.timestamp);
                    }
                    if (_.data.source === ro.MouseInteraction) {
                      let {
                        type: C,
                        id: R
                      } = _.data;
                      let L = record.mirror.getNode(R);
                      if (L instanceof HTMLElement && C === ra.Click) {
                        m.registerClick(L);
                      }
                    }
                  } catch (m) {}
                })(m.clickDetector, C);
              }
              m.addUpdate(() => {
                if (m.recordingMode === "buffer" && L) {
                  m.setInitialState();
                }
                if (!addEventSync(m, C, L)) {
                  return true;
                }
                if (!L) {
                  return false;
                }
                let _ = m.session;
                if (L && m.session && m.session.segmentId === 0) {
                  addEventSync(m, function (m) {
                    let _ = m.getOptions();
                    return {
                      type: ri.Custom,
                      timestamp: Date.now(),
                      data: {
                        tag: "options",
                        payload: {
                          shouldRecordCanvas: m.isRecordingCanvas(),
                          sessionSampleRate: _.sessionSampleRate,
                          errorSampleRate: _.errorSampleRate,
                          useCompressionOption: _.useCompression,
                          blockAllMedia: _.blockAllMedia,
                          maskAllText: _.maskAllText,
                          maskAllInputs: _.maskAllInputs,
                          useCompression: !!m.eventBuffer && m.eventBuffer.type === "worker",
                          networkDetailHasUrls: _.networkDetailAllowUrls.length > 0,
                          networkCaptureBodies: _.networkCaptureBodies,
                          networkRequestHasHeaders: _.networkRequestHeaders.length > 0,
                          networkResponseHasHeaders: _.networkResponseHeaders.length > 0
                        }
                      }
                    };
                  }(m), false);
                }
                if (_ && _.previousSessionId) {
                  return true;
                }
                if (m.recordingMode === "buffer" && _ && m.eventBuffer) {
                  let C = m.eventBuffer.getEarliestTimestamp();
                  if (C) {
                    _.started = C;
                    if (m.getOptions().stickySession) {
                      saveSession(_);
                    }
                  }
                }
                if (m.recordingMode === "session") {
                  m.flush();
                }
                return true;
              });
            }),
            onMutation: this._onMutationHandler,
            ...(C ? {
              recordCanvas: C.recordCanvas,
              getCanvasManager: C.getCanvasManager,
              sampling: C.sampling,
              dataURLOptions: C.dataURLOptions
            } : {})
          });
        } catch (m) {
          this.handleException(m);
        }
      }
      stopRecording() {
        try {
          if (this._stopRecording) {
            this._stopRecording();
            this._stopRecording = undefined;
          }
          return true;
        } catch (m) {
          this.handleException(m);
          return false;
        }
      }
      async stop({
        forceFlush: m = false,
        reason: _
      } = {}) {
        if (this._isEnabled) {
          this._isEnabled = false;
          try {
            (function () {
              let m = (0, eI.nZ)().getPropagationContext().dsc;
              if (m) {
                delete m.replay_id;
              }
              let _ = (0, ti.HN)();
              if (_) {
                let m = (0, e$.jC)(_);
                delete m.replay_id;
              }
            })();
            this._removeListeners();
            this.stopRecording();
            this._debouncedFlush.cancel();
            if (m) {
              await this._flush({
                force: true
              });
            }
            if (this.eventBuffer) {
              this.eventBuffer.destroy();
            }
            this.eventBuffer = null;
            (function () {
              if (hasSessionStorage()) {
                try {
                  tK.sessionStorage.removeItem(tZ);
                } catch (m) {}
              }
            })();
            this.session = undefined;
          } catch (m) {
            this.handleException(m);
          }
        }
      }
      pause() {
        if (!this._isPaused) {
          this._isPaused = true;
          this.stopRecording();
        }
      }
      resume() {
        if (this._isPaused && this._checkSession()) {
          this._isPaused = false;
          this.startRecording();
        }
      }
      async sendBufferedReplayOrFlush({
        continueRecording: m = true
      } = {}) {
        if (this.recordingMode === "session") {
          return this.flushImmediate();
        }
        let _ = Date.now();
        await this.flushImmediate();
        let C = this.stopRecording();
        if (m && C && this.recordingMode !== "session") {
          this.recordingMode = "session";
          if (this.session) {
            this._updateUserActivity(_);
            this._updateSessionActivity(_);
            this._maybeSaveSession();
          }
          this.startRecording();
        }
      }
      addUpdate(m) {
        let _ = m();
        if (this.recordingMode !== "buffer" && _ !== true) {
          this._debouncedFlush();
        }
      }
      triggerUserActivity() {
        this._updateUserActivity();
        if (!this._stopRecording) {
          if (!this._checkSession()) {
            return;
          }
          this.resume();
          return;
        }
        this.checkAndHandleExpiredSession();
        this._updateSessionActivity();
      }
      updateUserActivity() {
        this._updateUserActivity();
        this._updateSessionActivity();
      }
      conditionalFlush() {
        if (this.recordingMode === "buffer") {
          return Promise.resolve();
        } else {
          return this.flushImmediate();
        }
      }
      flush() {
        return this._debouncedFlush();
      }
      flushImmediate() {
        this._debouncedFlush();
        return this._debouncedFlush.flush();
      }
      cancelFlush() {
        this._debouncedFlush.cancel();
      }
      getSessionId() {
        return this.session && this.session.id;
      }
      checkAndHandleExpiredSession() {
        if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
          this.pause();
          return;
        }
        return !!this._checkSession();
      }
      setInitialState() {
        let m = `${tK.location.pathname}${tK.location.hash}${tK.location.search}`;
        let _ = `${tK.location.origin}${m}`;
        this.performanceEntries = [];
        this.replayPerformanceEntries = [];
        this._clearContext();
        this._context.initialUrl = _;
        this._context.initialTimestamp = Date.now();
        this._context.urls.push(_);
      }
      throttledAddEvent(m, _) {
        let C = this._throttledAddEvent(m, _);
        if (C === ry) {
          let m = createBreadcrumb({
            category: "replay.throttled"
          });
          this.addUpdate(() => !addEventSync(this, {
            type: 5,
            timestamp: m.timestamp || 0,
            data: {
              tag: "breadcrumb",
              payload: m,
              metric: true
            }
          }));
        }
        return C;
      }
      getCurrentRoute() {
        let m = this.lastActiveSpan || (0, ti.HN)();
        let _ = m && (0, ti.Gx)(m);
        let C = _ && (0, ti.XU)(_).data || {};
        let R = C[ta.Zj];
        if (_ && R && ["route", "custom"].includes(R)) {
          return (0, ti.XU)(_).description;
        }
      }
      _initializeRecording() {
        this.setInitialState();
        this._updateSessionActivity();
        this.eventBuffer = function ({
          useCompression: m,
          workerUrl: _
        }) {
          if (m && window.Worker) {
            let m = function (m) {
              try {
                let _ = m || (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ != "undefined" && __SENTRY_EXCLUDE_REPLAY_WORKER__ ? "" : function () {
                  let m = new Blob(["var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J=\"undefined\"!=typeof TextEncoder&&new TextEncoder,K=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&\"function\"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});"]);
                  return URL.createObjectURL(m);
                }());
                if (!_) {
                  return;
                }
                let C = new Worker(_);
                return new EventBufferProxy(C);
              } catch (m) {}
            }(_);
            if (m) {
              return m;
            }
          }
          return new EventBufferArray();
        }({
          useCompression: this._options.useCompression,
          workerUrl: this._options.workerUrl
        });
        this._removeListeners();
        this._addListeners();
        this._isEnabled = true;
        this._isPaused = false;
        this.startRecording();
      }
      _initializeSessionForSampling(m) {
        let _ = this._options.errorSampleRate > 0;
        let C = loadOrCreateSession({
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          maxReplayDuration: this._options.maxReplayDuration,
          previousSessionId: m
        }, {
          stickySession: this._options.stickySession,
          sessionSampleRate: this._options.sessionSampleRate,
          allowBuffering: _
        });
        this.session = C;
      }
      _checkSession() {
        if (!this.session) {
          return false;
        }
        let m = this.session;
        return !shouldRefreshSession(m, {
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          maxReplayDuration: this._options.maxReplayDuration
        }) || (this._refreshSession(m), false);
      }
      async _refreshSession(m) {
        if (this._isEnabled) {
          await this.stop({
            reason: "refresh session"
          });
          this.initializeSampling(m.id);
        }
      }
      _addListeners() {
        try {
          tK.document.addEventListener("visibilitychange", this._handleVisibilityChange);
          tK.addEventListener("blur", this._handleWindowBlur);
          tK.addEventListener("focus", this._handleWindowFocus);
          tK.addEventListener("keydown", this._handleKeyboardEvent);
          if (this.clickDetector) {
            this.clickDetector.addListeners();
          }
          if (!this._hasInitializedCoreListeners) {
            (function (m) {
              let _ = (0, eI.s3)();
              addClickKeypressInstrumentationHandler(handleDomListener(m));
              addHistoryInstrumentationHandler(_ => {
                if (!m.isEnabled()) {
                  return;
                }
                let C = function (m) {
                  let {
                    from: _,
                    to: C
                  } = m;
                  let R = Date.now() / 1000;
                  return {
                    type: "navigation.push",
                    start: R,
                    end: R,
                    name: C,
                    data: {
                      previous: _
                    }
                  };
                }(_);
                if (C !== null) {
                  m.getContext().urls.push(C.name);
                  m.triggerUserActivity();
                  m.addUpdate(() => {
                    createPerformanceSpans(m, [C]);
                    return false;
                  });
                }
              });
              (function (m) {
                let _ = (0, eI.s3)();
                if (_) {
                  _.on("beforeAddBreadcrumb", _ => function (m, _) {
                    if (!m.isEnabled() || !isBreadcrumbWithCategory(_)) {
                      return;
                    }
                    let C = !isBreadcrumbWithCategory(_) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(_.category) || _.category.startsWith("ui.") ? null : _.category === "console" ? function (m) {
                      let _ = m.data && m.data.arguments;
                      if (!Array.isArray(_) || _.length === 0) {
                        return createBreadcrumb(m);
                      }
                      let C = false;
                      let R = _.map(m => {
                        if (!m) {
                          return m;
                        }
                        if (typeof m == "string") {
                          if (m.length > 5000) {
                            C = true;
                            return `${m.slice(0, 5000)}`;
                          } else {
                            return m;
                          }
                        }
                        if (typeof m == "object") {
                          try {
                            let _ = (0, eV.Fv)(m, 7);
                            let R = JSON.stringify(_);
                            if (R.length > 5000) {
                              C = true;
                              return `${JSON.stringify(_, null, 2).slice(0, 5000)}`;
                            }
                            return _;
                          } catch (m) {}
                        }
                        return m;
                      });
                      return createBreadcrumb({
                        ...m,
                        data: {
                          ...m.data,
                          arguments: R,
                          ...(C ? {
                            _meta: {
                              warnings: ["CONSOLE_ARG_TRUNCATED"]
                            }
                          } : {})
                        }
                      });
                    }(_) : createBreadcrumb(_);
                    if (C) {
                      addBreadcrumbEvent(m, C);
                    }
                  }(m, _));
                }
              })(m);
              (function (m) {
                let _ = (0, eI.s3)();
                try {
                  let {
                    networkDetailAllowUrls: C,
                    networkDetailDenyUrls: R,
                    networkCaptureBodies: L,
                    networkRequestHeaders: B,
                    networkResponseHeaders: F
                  } = m.getOptions();
                  let U = {
                    replay: m,
                    networkDetailAllowUrls: C,
                    networkDetailDenyUrls: R,
                    networkCaptureBodies: L,
                    networkRequestHeaders: B,
                    networkResponseHeaders: F
                  };
                  if (_) {
                    _.on("beforeAddBreadcrumb", (m, _) => function (m, _, C) {
                      if (_.data) {
                        try {
                          var R;
                          var L;
                          if (_.category === "xhr" && (R = C) && R.xhr) {
                            (function (m, _) {
                              let {
                                xhr: C,
                                input: R
                              } = _;
                              if (!C) {
                                return;
                              }
                              let L = getBodySize(R);
                              let B = C.getResponseHeader("content-length") ? parseContentLengthHeader(C.getResponseHeader("content-length")) : function (m, _) {
                                try {
                                  let C = _ === "json" && m && typeof m == "object" ? JSON.stringify(m) : m;
                                  return getBodySize(C);
                                } catch (m) {
                                  return;
                                }
                              }(C.response, C.responseType);
                              if (L !== undefined) {
                                m.data.request_body_size = L;
                              }
                              if (B !== undefined) {
                                m.data.response_body_size = B;
                              }
                            })(_, C);
                            captureXhrBreadcrumbToReplay(_, C, m);
                          }
                          if (_.category === "fetch" && (L = C) && L.response) {
                            (function (m, _) {
                              let {
                                input: C,
                                response: R
                              } = _;
                              let L = C ? _getFetchRequestArgBody(C) : undefined;
                              let B = getBodySize(L);
                              let F = R ? parseContentLengthHeader(R.headers.get("content-length")) : undefined;
                              if (B !== undefined) {
                                m.data.request_body_size = B;
                              }
                              if (F !== undefined) {
                                m.data.response_body_size = F;
                              }
                            })(_, C);
                            captureFetchBreadcrumbToReplay(_, C, m);
                          }
                        } catch (m) {}
                      }
                    }(U, m, _));
                  }
                } catch (m) {}
              })(m);
              let C = Object.assign((_, C) => {
                if (!m.isEnabled() || m.isPaused()) {
                  return _;
                }
                if (_.type === "replay_event") {
                  delete _.breadcrumbs;
                  return _;
                }
                if (_.type && !esm_isTransactionEvent(_) && !isFeedbackEvent(_)) {
                  return _;
                }
                let R = m.checkAndHandleExpiredSession();
                if (!R) {
                  return _;
                }
                if (isFeedbackEvent(_)) {
                  m.flush();
                  _.contexts.feedback.replay_id = m.getSessionId();
                  m.triggerUserActivity();
                  m.addUpdate(() => !_.timestamp || (m.throttledAddEvent({
                    type: ri.Custom,
                    timestamp: _.timestamp * 1000,
                    data: {
                      tag: "breadcrumb",
                      payload: {
                        timestamp: _.timestamp,
                        type: "default",
                        category: "sentry.feedback",
                        data: {
                          feedbackId: _.event_id
                        }
                      }
                    }
                  }), false));
                  return _;
                }
                if (!_.type && _.exception && _.exception.values && _.exception.values.length && C.originalException && C.originalException.__rrweb__ && !m.getOptions()._experiments.captureExceptions) {
                  return null;
                }
                let L = m.recordingMode === "buffer" && _.message !== tY && !!_.exception && !_.type && isSampled(m.getOptions().errorSampleRate);
                let B = L || m.recordingMode === "session";
                if (B) {
                  _.tags = {
                    ..._.tags,
                    replayId: m.getSessionId()
                  };
                }
                return _;
              }, {
                id: "Replay"
              });
              (0, e_.Qy)(C);
              if (_) {
                _.on("beforeSendEvent", _ => {
                  if (m.isEnabled() && !_.type) {
                    (function (m, _) {
                      let C = _.exception && _.exception.values && _.exception.values[0] && _.exception.values[0].value;
                      if (typeof C == "string" && (C.match(/(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/) || C.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
                        let _ = createBreadcrumb({
                          category: "replay.hydrate-error",
                          data: {
                            url: (0, eY.l4)()
                          }
                        });
                        addBreadcrumbEvent(m, _);
                      }
                    })(m, _);
                  }
                });
                _.on("afterSendEvent", (_, C) => {
                  if (!m.isEnabled() || _.type && !esm_isTransactionEvent(_)) {
                    return;
                  }
                  let R = C && C.statusCode;
                  if (R && !(R < 200) && !(R >= 300)) {
                    if (esm_isTransactionEvent(_)) {
                      (function (m, _) {
                        let C = m.getContext();
                        if (_.contexts && _.contexts.trace && _.contexts.trace.trace_id && C.traceIds.size < 100) {
                          C.traceIds.add(_.contexts.trace.trace_id);
                        }
                      })(m, _);
                      return;
                    }
                    (function (m, _) {
                      let C = m.getContext();
                      if (_.event_id && C.errorIds.size < 100) {
                        C.errorIds.add(_.event_id);
                      }
                      if (m.recordingMode !== "buffer" || !_.tags || !_.tags.replayId) {
                        return;
                      }
                      let {
                        beforeErrorSampling: R
                      } = m.getOptions();
                      if (typeof R != "function" || R(_)) {
                        getNativeImplementation_setTimeout(async () => {
                          try {
                            await m.sendBufferedReplayOrFlush();
                          } catch (_) {
                            m.handleException(_);
                          }
                        });
                      }
                    })(m, _);
                  }
                });
                _.on("createDsc", _ => {
                  let C = m.getSessionId();
                  if (C && m.isEnabled() && m.recordingMode === "session") {
                    let R = m.checkAndHandleExpiredSession();
                    if (R) {
                      _.replay_id = C;
                    }
                  }
                });
                _.on("spanStart", _ => {
                  m.lastActiveSpan = _;
                });
                _.on("spanEnd", _ => {
                  m.lastActiveSpan = _;
                });
                _.on("beforeSendFeedback", (_, C) => {
                  let R = m.getSessionId();
                  if (C && C.includeReplay && m.isEnabled() && R && _.contexts && _.contexts.feedback) {
                    _.contexts.feedback.replay_id = R;
                  }
                });
              }
            })(this);
            this._hasInitializedCoreListeners = true;
          }
        } catch (m) {
          this.handleException(m);
        }
        this._performanceCleanupCallback = function (m) {
          function addPerformanceEntry(_) {
            if (!m.performanceEntries.includes(_)) {
              m.performanceEntries.push(_);
            }
          }
          function onEntries({
            entries: m
          }) {
            m.forEach(addPerformanceEntry);
          }
          let _ = [];
          ["navigation", "paint", "resource"].forEach(m => {
            _.push(addPerformanceInstrumentationHandler(m, onEntries));
          });
          _.push(addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, m)), addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, m)), addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, m)), addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, m)));
          return () => {
            _.forEach(m => m());
          };
        }(this);
      }
      _removeListeners() {
        try {
          tK.document.removeEventListener("visibilitychange", this._handleVisibilityChange);
          tK.removeEventListener("blur", this._handleWindowBlur);
          tK.removeEventListener("focus", this._handleWindowFocus);
          tK.removeEventListener("keydown", this._handleKeyboardEvent);
          if (this.clickDetector) {
            this.clickDetector.removeListeners();
          }
          if (this._performanceCleanupCallback) {
            this._performanceCleanupCallback();
          }
        } catch (m) {
          this.handleException(m);
        }
      }
      __init() {
        this._handleVisibilityChange = () => {
          if (tK.document.visibilityState === "visible") {
            this._doChangeToForegroundTasks();
          } else {
            this._doChangeToBackgroundTasks();
          }
        };
      }
      __init2() {
        this._handleWindowBlur = () => {
          let m = createBreadcrumb({
            category: "ui.blur"
          });
          this._doChangeToBackgroundTasks(m);
        };
      }
      __init3() {
        this._handleWindowFocus = () => {
          let m = createBreadcrumb({
            category: "ui.focus"
          });
          this._doChangeToForegroundTasks(m);
        };
      }
      __init4() {
        this._handleKeyboardEvent = m => {
          (function (m, _) {
            if (!m.isEnabled()) {
              return;
            }
            m.updateUserActivity();
            let C = function (m) {
              var _;
              let {
                metaKey: C,
                shiftKey: R,
                ctrlKey: L,
                altKey: B,
                key: F,
                target: U
              } = m;
              if (!U || (_ = U).tagName === "INPUT" || _.tagName === "TEXTAREA" || _.isContentEditable || !F) {
                return null;
              }
              let H = F.length === 1;
              if (!C && !L && !B && H) {
                return null;
              }
              let q = (0, eY.Rt)(U, {
                maxStringLength: 200
              }) || "<unknown>";
              let V = getBaseDomBreadcrumb(U, q);
              return createBreadcrumb({
                category: "ui.keyDown",
                message: q,
                data: {
                  ...V.data,
                  metaKey: C,
                  shiftKey: R,
                  ctrlKey: L,
                  altKey: B,
                  key: F
                }
              });
            }(_);
            if (C) {
              addBreadcrumbEvent(m, C);
            }
          })(this, m);
        };
      }
      _doChangeToBackgroundTasks(m) {
        if (!this.session) {
          return;
        }
        let _ = isSessionExpired(this.session, {
          maxReplayDuration: this._options.maxReplayDuration,
          sessionIdleExpire: this.timeouts.sessionIdleExpire
        });
        if (!_) {
          if (m) {
            this._createCustomBreadcrumb(m);
          }
          this.conditionalFlush();
        }
      }
      _doChangeToForegroundTasks(m) {
        if (!this.session) {
          return;
        }
        let _ = this.checkAndHandleExpiredSession();
        if (_ && m) {
          this._createCustomBreadcrumb(m);
        }
      }
      _updateUserActivity(m = Date.now()) {
        this._lastActivity = m;
      }
      _updateSessionActivity(m = Date.now()) {
        if (this.session) {
          this.session.lastActivity = m;
          this._maybeSaveSession();
        }
      }
      _createCustomBreadcrumb(m) {
        this.addUpdate(() => {
          this.throttledAddEvent({
            type: ri.Custom,
            timestamp: m.timestamp || 0,
            data: {
              tag: "breadcrumb",
              payload: m
            }
          });
        });
      }
      _addPerformanceEntries() {
        let m = this.performanceEntries.map(createPerformanceEntry).filter(Boolean).concat(this.replayPerformanceEntries);
        this.performanceEntries = [];
        this.replayPerformanceEntries = [];
        return Promise.all(createPerformanceSpans(this, m));
      }
      _clearContext() {
        this._context.errorIds.clear();
        this._context.traceIds.clear();
        this._context.urls = [];
      }
      _updateInitialTimestampFromEventBuffer() {
        let {
          session: m,
          eventBuffer: _
        } = this;
        if (!m || !_ || this._requiresManualStart || m.segmentId) {
          return;
        }
        let C = _.getEarliestTimestamp();
        if (C && C < this._context.initialTimestamp) {
          this._context.initialTimestamp = C;
        }
      }
      _popEventContext() {
        let m = {
          initialTimestamp: this._context.initialTimestamp,
          initialUrl: this._context.initialUrl,
          errorIds: Array.from(this._context.errorIds),
          traceIds: Array.from(this._context.traceIds),
          urls: this._context.urls
        };
        this._clearContext();
        return m;
      }
      async _runFlush() {
        let m = this.getSessionId();
        if (this.session && this.eventBuffer && m && (await this._addPerformanceEntries(), this.eventBuffer && this.eventBuffer.hasEvents) && (await addMemoryEntry(this), this.eventBuffer && m === this.getSessionId())) {
          try {
            this._updateInitialTimestampFromEventBuffer();
            let _ = Date.now();
            if (_ - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {
              throw Error("Session is too long, not sending replay");
            }
            let C = this._popEventContext();
            let R = this.session.segmentId++;
            this._maybeSaveSession();
            let L = await this.eventBuffer.finish();
            await sendReplay({
              replayId: m,
              recordingData: L,
              segmentId: R,
              eventContext: C,
              session: this.session,
              timestamp: _,
              onError: m => this.handleException(m)
            });
          } catch (_) {
            this.handleException(_);
            this.stop({
              reason: "sendReplay"
            });
            let m = (0, eI.s3)();
            if (m) {
              let C = _ instanceof RateLimitError ? "ratelimit_backoff" : "send_error";
              m.recordDroppedEvent(C, "replay");
            }
          }
        }
      }
      __init5() {
        this._flush = async ({
          force: m = false
        } = {}) => {
          if (!this._isEnabled && !m || !this.checkAndHandleExpiredSession() || !this.session) {
            return;
          }
          let _ = this.session.started;
          let C = Date.now();
          let R = C - _;
          this._debouncedFlush.cancel();
          let L = R < this._options.minReplayDuration;
          let B = R > this._options.maxReplayDuration + 5000;
          if (L || B) {
            if (L) {
              this._debouncedFlush();
            }
            return;
          }
          let F = this.eventBuffer;
          if (F && this.session.segmentId === 0) {
            F.hasCheckout;
          }
          let U = !!this._flushLock;
          this._flushLock ||= this._runFlush();
          try {
            await this._flushLock;
          } catch (m) {
            this.handleException(m);
          } finally {
            this._flushLock = undefined;
            if (U) {
              this._debouncedFlush();
            }
          }
        };
      }
      _maybeSaveSession() {
        if (this.session && this._options.stickySession) {
          saveSession(this.session);
        }
      }
      __init6() {
        this._onMutationHandler = m => {
          let _ = m.length;
          let C = this._options.mutationLimit;
          let R = this._options.mutationBreadcrumbLimit;
          let L = C && _ > C;
          if (_ > R || L) {
            let m = createBreadcrumb({
              category: "replay.mutations",
              data: {
                count: _,
                limit: L
              }
            });
            this._createCustomBreadcrumb(m);
          }
          return !L || (this.stop({
            reason: "mutationLimit",
            forceFlush: this.recordingMode === "session"
          }), false);
        };
      }
    };
    function getOption(m, _) {
      return [...m, ..._].join(",");
    }
    let r_ = "img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]";
    let rv = ["content-length", "content-type", "accept"];
    let rb = false;
    let Replay = class Replay {
      static __initStatic() {
        this.id = "Replay";
      }
      constructor({
        flushMinDelay: m = 5000,
        flushMaxDelay: _ = 5500,
        minReplayDuration: C = 4999,
        maxReplayDuration: R = 3600000,
        stickySession: L = true,
        useCompression: B = true,
        workerUrl: F,
        _experiments: U = {},
        maskAllText: H = true,
        maskAllInputs: q = true,
        blockAllMedia: V = true,
        mutationBreadcrumbLimit: X = 750,
        mutationLimit: K = 10000,
        slowClickTimeout: Y = 7000,
        slowClickIgnoreSelectors: Q = [],
        networkDetailAllowUrls: et = [],
        networkDetailDenyUrls: er = [],
        networkCaptureBodies: en = true,
        networkRequestHeaders: ei = [],
        networkResponseHeaders: eo = [],
        mask: ea = [],
        maskAttributes: es = ["title", "placeholder"],
        unmask: ec = [],
        block: el = [],
        unblock: eu = [],
        ignore: ed = [],
        maskFn: ep,
        beforeAddRecordingEvent: eh,
        beforeErrorSampling: ef
      } = {}) {
        this.name = Replay.id;
        let em = function ({
          mask: m,
          unmask: _,
          block: C,
          unblock: R,
          ignore: L
        }) {
          let B = getOption(m, [".sentry-mask", "[data-sentry-mask]"]);
          let F = getOption(_, []);
          let U = {
            maskTextSelector: B,
            unmaskTextSelector: F,
            blockSelector: getOption(C, [".sentry-block", "[data-sentry-block]", "base[href=\"/\"]"]),
            unblockSelector: getOption(R, []),
            ignoreSelector: getOption(L, [".sentry-ignore", "[data-sentry-ignore]", "input[type=\"file\"]"])
          };
          return U;
        }({
          mask: ea,
          unmask: ec,
          block: el,
          unblock: eu,
          ignore: ed
        });
        this._recordingOptions = {
          maskAllInputs: q,
          maskAllText: H,
          maskInputOptions: {
            password: true
          },
          maskTextFn: ep,
          maskInputFn: ep,
          maskAttributeFn: (m, _, C) => function ({
            el: m,
            key: _,
            maskAttributes: C,
            maskAllText: R,
            privacyOptions: L,
            value: B
          }) {
            if (!R || L.unmaskTextSelector && m.matches(L.unmaskTextSelector)) {
              return B;
            } else if (C.includes(_) || _ === "value" && m.tagName === "INPUT" && ["submit", "button"].includes(m.getAttribute("type") || "")) {
              return B.replace(/[\S]/g, "*");
            } else {
              return B;
            }
          }({
            maskAttributes: es,
            maskAllText: H,
            privacyOptions: em,
            key: m,
            value: _,
            el: C
          }),
          ...em,
          slimDOMOptions: "all",
          inlineStylesheet: true,
          inlineImages: false,
          collectFonts: true,
          errorHandler: m => {
            try {
              m.__rrweb__ = true;
            } catch (m) {}
          }
        };
        this._initialOptions = {
          flushMinDelay: m,
          flushMaxDelay: _,
          minReplayDuration: Math.min(C, 15000),
          maxReplayDuration: Math.min(R, 3600000),
          stickySession: L,
          useCompression: B,
          workerUrl: F,
          blockAllMedia: V,
          maskAllInputs: q,
          maskAllText: H,
          mutationBreadcrumbLimit: X,
          mutationLimit: K,
          slowClickTimeout: Y,
          slowClickIgnoreSelectors: Q,
          networkDetailAllowUrls: et,
          networkDetailDenyUrls: er,
          networkCaptureBodies: en,
          networkRequestHeaders: _getMergedNetworkHeaders(ei),
          networkResponseHeaders: _getMergedNetworkHeaders(eo),
          beforeAddRecordingEvent: eh,
          beforeErrorSampling: ef,
          _experiments: U
        };
        if (this._initialOptions.blockAllMedia) {
          this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${r_}` : r_;
        }
        if (this._isInitialized && isBrowser()) {
          throw Error("Multiple Sentry Session Replay instances are not supported");
        }
        this._isInitialized = true;
      }
      get _isInitialized() {
        return rb;
      }
      set _isInitialized(m) {
        rb = m;
      }
      afterAllSetup(m) {
        if (isBrowser() && !this._replay) {
          this._setup(m);
          this._initialize(m);
        }
      }
      start() {
        if (this._replay) {
          this._replay.start();
        }
      }
      startBuffering() {
        if (this._replay) {
          this._replay.startBuffering();
        }
      }
      stop() {
        if (this._replay) {
          return this._replay.stop({
            forceFlush: this._replay.recordingMode === "session"
          });
        } else {
          return Promise.resolve();
        }
      }
      flush(m) {
        if (this._replay) {
          if (this._replay.isEnabled()) {
            return this._replay.sendBufferedReplayOrFlush(m);
          } else {
            this._replay.start();
            return Promise.resolve();
          }
        } else {
          return Promise.resolve();
        }
      }
      getReplayId() {
        if (this._replay && this._replay.isEnabled()) {
          return this._replay.getSessionId();
        }
      }
      _initialize(m) {
        if (this._replay) {
          this._maybeLoadFromReplayCanvasIntegration(m);
          this._replay.initializeSampling();
        }
      }
      _setup(m) {
        let _ = function (m, _) {
          let C = _.getOptions();
          let R = {
            sessionSampleRate: 0,
            errorSampleRate: 0,
            ...(0, ex.Jr)(m)
          };
          let L = (0, eq.o)(C.replaysSessionSampleRate);
          let B = (0, eq.o)(C.replaysOnErrorSampleRate);
          if (L == null && B == null) {
            (0, ev.Cf)(() => {
              console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.");
            });
          }
          if (L != null) {
            R.sessionSampleRate = L;
          }
          if (B != null) {
            R.errorSampleRate = B;
          }
          return R;
        }(this._initialOptions, m);
        this._replay = new ReplayContainer({
          options: _,
          recordingOptions: this._recordingOptions
        });
      }
      _maybeLoadFromReplayCanvasIntegration(m) {
        try {
          let _ = m.getIntegrationByName("ReplayCanvas");
          if (!_) {
            return;
          }
          this._replay._canvas = _.getOptions();
        } catch (m) {}
      }
    };
    function _getMergedNetworkHeaders(m) {
      return [...rv, ...m.map(m => m.toLowerCase())];
    }
    Replay.__initStatic();
    globalThis.__sentryRewritesTunnelPath__ = "/monitoring";
    globalThis.SENTRY_RELEASE = {
      id: "09d95c2f9ec5c044f6bd298a4116538ef074d2bd"
    };
    globalThis.__sentryBasePath = undefined;
    globalThis.__rewriteFramesAssetPrefixPath__ = "";
    (function (m) {
      let _ = {
        environment: function (m) {
          let _ = m ? tn.env.NEXT_PUBLIC_VERCEL_ENV : tn.env.VERCEL_ENV;
          if (_) {
            return `vercel-${_}`;
          } else {
            return undefined;
          }
        }(true) || "production",
        defaultIntegrations: function (m) {
          let _ = getDefaultIntegrations(m);
          if (typeof __SENTRY_TRACING__ == "undefined" || __SENTRY_TRACING__) {
            _.push(function (m = {}) {
              let _ = browserTracingIntegration({
                ...m,
                instrumentNavigation: false,
                instrumentPageLoad: false
              });
              let {
                instrumentPageLoad: C = true,
                instrumentNavigation: R = true
              } = m;
              return {
                ..._,
                afterAllSetup(m) {
                  if (R) {
                    (function (m) {
                      let _ = !eX.document.getElementById("__NEXT_DATA__");
                      if (_) {
                        (function (m) {
                          let _;
                          eX.addEventListener("popstate", () => {
                            if (_ && _.isRecording()) {
                              _.updateName(eX.location.pathname);
                            } else {
                              _ = startBrowserTracingNavigationSpan(m, {
                                name: eX.location.pathname,
                                attributes: {
                                  [ta.$J]: "navigation",
                                  [ta.S3]: "auto.navigation.nextjs.app_router_instrumentation",
                                  [ta.Zj]: "url",
                                  "navigation.type": "browser.popstate"
                                }
                              });
                            }
                          });
                          let C = false;
                          let R = 0;
                          let L = setInterval(() => {
                            R++;
                            let F = _optionalChain([tW, "optionalAccess", m => m.next, "optionalAccess", m => m.router]) ?? _optionalChain([tW, "optionalAccess", m => m.nd, "optionalAccess", m => m.router]);
                            if (C || R > 500) {
                              clearInterval(L);
                            } else if (F) {
                              clearInterval(L);
                              C = true;
                              ["back", "forward", "push", "replace"].forEach(C => {
                                if (_optionalChain([F, "optionalAccess", m => m[C]])) {
                                  F[C] = new Proxy(F[C], {
                                    apply(R, L, B) {
                                      let F = startBrowserTracingNavigationSpan(m, {
                                        name: tH,
                                        attributes: {
                                          [ta.$J]: "navigation",
                                          [ta.S3]: "auto.navigation.nextjs.app_router_instrumentation",
                                          [ta.Zj]: "url"
                                        }
                                      });
                                      _ = F;
                                      if (C === "push") {
                                        _optionalChain([F, "optionalAccess", m => m.updateName, "call", m => m(transactionNameifyRouterArgument(B[0]))]);
                                        _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.push")]);
                                      } else if (C === "replace") {
                                        _optionalChain([F, "optionalAccess", m => m.updateName, "call", m => m(transactionNameifyRouterArgument(B[0]))]);
                                        _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.replace")]);
                                      } else if (C === "back") {
                                        _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.back")]);
                                      } else if (C === "forward") {
                                        _optionalChain([F, "optionalAccess", m => m.setAttribute, "call", m => m("navigation.type", "router.forward")]);
                                      }
                                      return R.apply(L, B);
                                    }
                                  });
                                }
                              });
                            }
                          }, 20);
                        })(m);
                      } else {
                        tG.events.on("routeChangeStart", _ => {
                          let C;
                          let R;
                          let L = _.split(/[?#]/, 1)[0];
                          let B = function (m) {
                            let _ = (eX.__BUILD_MANIFEST || {}).sortedPages;
                            if (_) {
                              return _.find(_ => {
                                let C = function (m) {
                                  let _ = m.split("/");
                                  let C = "";
                                  if (_optionalChain([_, "access", m => m[_.length - 1], "optionalAccess", m => m.match, "call", m => m(/^\[\[\.\.\..+\]\]$/)])) {
                                    _.pop();
                                    C = "(?:/(.+?))?";
                                  }
                                  let R = _.map(m => m.replace(/^\[\.\.\..+\]$/, "(.+?)").replace(/^\[.*\]$/, "([^/]+?)")).join("/");
                                  return RegExp(`^${R}${C}(?:/)?$`);
                                }(_);
                                return m.match(C);
                              });
                            }
                          }(L);
                          if (B) {
                            C = B;
                            R = "route";
                          } else {
                            C = L;
                            R = "url";
                          }
                          startBrowserTracingNavigationSpan(m, {
                            name: C,
                            attributes: {
                              [ta.$J]: "navigation",
                              [ta.S3]: "auto.navigation.nextjs.pages_router_instrumentation",
                              [ta.Zj]: R
                            }
                          });
                        });
                      }
                    })(m);
                  }
                  _.afterAllSetup(m);
                  if (C) {
                    (function (m) {
                      let _ = !eX.document.getElementById("__NEXT_DATA__");
                      if (_) {
                        startBrowserTracingPageLoadSpan(m, {
                          name: eX.location.pathname,
                          startTime: eU.Z1 ? eU.Z1 / 1000 : undefined,
                          attributes: {
                            [ta.$J]: "pageload",
                            [ta.S3]: "auto.pageload.nextjs.app_router_instrumentation",
                            [ta.Zj]: "url"
                          }
                        });
                      } else {
                        (function (m) {
                          let {
                            route: _,
                            params: C,
                            sentryTrace: R,
                            baggage: L
                          } = function () {
                            let m;
                            let _ = eX.document.getElementById("__NEXT_DATA__");
                            if (_ && _.innerHTML) {
                              try {
                                m = JSON.parse(_.innerHTML);
                              } catch (m) {
                                if (tq.X) {
                                  ev.kg.warn("Could not extract __NEXT_DATA__");
                                }
                              }
                            }
                            if (!m) {
                              return {};
                            }
                            let C = {};
                            let {
                              page: R,
                              query: L,
                              props: B
                            } = m;
                            C.route = R;
                            C.params = L;
                            if (B && B.pageProps) {
                              C.sentryTrace = B.pageProps._sentryTraceData;
                              C.baggage = B.pageProps._sentryBaggage;
                            }
                            return C;
                          }();
                          let B = _ || eX.location.pathname;
                          startBrowserTracingPageLoadSpan(m, {
                            name: B,
                            startTime: eU.Z1 ? eU.Z1 / 1000 : undefined,
                            attributes: {
                              [ta.$J]: "pageload",
                              [ta.S3]: "auto.pageload.nextjs.pages_router_instrumentation",
                              [ta.Zj]: _ ? "route" : "url",
                              ...(C && m.getOptions().sendDefaultPii && {
                                ...C
                              })
                            }
                          }, {
                            sentryTrace: R,
                            baggage: L
                          });
                        })(m);
                      }
                    })(m);
                  }
                }
              };
            }());
          }
          let C = tJ.__rewriteFramesAssetPrefixPath__ || "";
          _.push(nextjsClientStackFrameNormalizationIntegration({
            assetPrefixPath: C
          }));
          return _;
        }(m),
        ...m
      };
      (function (m) {
        let _ = tV.__sentryRewritesTunnelPath__;
        if (_ && m.dsn) {
          let C = (0, eN.U4)(m.dsn);
          if (!C) {
            return;
          }
          let R = C.host.match(/^o(\d+)\.ingest(?:\.([a-z]{2}))?\.sentry\.io$/);
          if (R) {
            let L = R[1];
            let B = R[2];
            let F = `${_}?o=${L}&p=${C.projectId}`;
            if (B) {
              F += `&r=${B}`;
            }
            m.tunnel = F;
            if (tq.X) {
              ev.kg.info(`Tunneling events to "${F}"`);
            }
          } else if (tq.X) {
            ev.kg.warn("Provided DSN is not a Sentry SaaS DSN. Will not tunnel events.");
          }
        }
      })(_);
      applySdkMetadata(_, "nextjs", ["nextjs", "react"]);
      (function (m) {
        let _ = {
          ...m
        };
        applySdkMetadata(_, "react");
        (0, e_.v)("react", {
          version: tr.version
        });
        (function (m = {}) {
          let _ = function (m = {}) {
            let _ = {
              defaultIntegrations: getDefaultIntegrations(),
              release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : eX.SENTRY_RELEASE && eX.SENTRY_RELEASE.id ? eX.SENTRY_RELEASE.id : undefined,
              autoSessionTracking: true,
              sendClientReports: true
            };
            if (m.defaultIntegrations == null) {
              delete m.defaultIntegrations;
            }
            return {
              ..._,
              ...m
            };
          }(m);
          if (function () {
            let m = eX.window !== undefined && eX;
            if (!m) {
              return false;
            }
            let _ = m.chrome ? "chrome" : "browser";
            let C = m[_];
            let R = C && C.runtime && C.runtime.id;
            let L = eX.location && eX.location.href || "";
            let B = !!R && eX === eX.top && ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"].some(m => L.startsWith(`${m}//`));
            let F = m.nw !== undefined;
            return !!R && !B && !F;
          }()) {
            (0, ev.Cf)(() => {
              console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/");
            });
            return;
          }
          let C = {
            ..._,
            stackParser: (0, eC.Sq)(_.stackParser || te),
            integrations: function (m) {
              let _;
              let C = m.defaultIntegrations || [];
              let R = m.integrations;
              C.forEach(m => {
                m.isDefaultInstance = true;
              });
              _ = Array.isArray(R) ? [...C, ...R] : typeof R == "function" ? (0, eb.lE)(R(C)) : C;
              let L = function (m) {
                let _ = {};
                m.forEach(m => {
                  let {
                    name: C
                  } = m;
                  let R = _[C];
                  if (!R || !!R.isDefaultInstance || !m.isDefaultInstance) {
                    _[C] = m;
                  }
                });
                return Object.values(_);
              }(_);
              let B = L.findIndex(m => m.name === "Debug");
              if (B > -1) {
                let [m] = L.splice(B, 1);
                L.push(m);
              }
              return L;
            }(_),
            transport: _.transport || makeFetchTransport
          };
          (function (m, _) {
            if (_.debug === true) {
              if (ew.X) {
                ev.kg.enable();
              } else {
                (0, ev.Cf)(() => {
                  console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
                });
              }
            }
            let C = (0, eI.nZ)();
            C.update(_.initialScope);
            let R = new m(_);
            (0, eI.nZ)().setClient(R);
            R.init();
          })(BrowserClient, C);
          if (_.autoSessionTracking && eX.document !== undefined) {
            (0, e_.yj)({
              ignoreDuration: true
            });
            (0, e_.cg)();
            addHistoryInstrumentationHandler(({
              from: m,
              to: _
            }) => {
              if (m !== undefined && m !== _) {
                (0, e_.yj)({
                  ignoreDuration: true
                });
                (0, e_.cg)();
              }
            });
          }
        })(_);
      })(_);
      let filterTransactions = m => m.type === "transaction" && m.transaction === "/404" ? null : m;
      filterTransactions.id = "NextClient404Filter";
      (0, e_.Qy)(filterTransactions);
      let filterIncompleteNavigationTransactions = m => m.type === "transaction" && m.transaction === tH ? null : m;
      filterIncompleteNavigationTransactions.id = "IncompleteTransactionFilter";
      (0, e_.Qy)(filterIncompleteNavigationTransactions);
    })({
      dsn: "https://96cd2ecfae2ef16c7727bed1a3db75e4@o4507852651954176.ingest.de.sentry.io/4508136210169936",
      integrations: [(ef = {
        maskAllText: false,
        blockAllMedia: false,
        maskAllInputs: false,
        networkDetailAllowUrls: [window.location.origin, "https://api.bloxflip.com", "https://ws.bloxflip.com", "https://api.bflip.com", "https://ws.bflip.com"]
      }, new Replay(ef))],
      tracePropagationTargets: ["api.bloxflip.com", "ws.bloxflip.com", "localhost"],
      tracesSampleRate: 0.01,
      replaysSessionSampleRate: 0.01,
      replaysOnErrorSampleRate: 0.5,
      debug: false
    });
  },
  4595: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z: function () {
        return Button;
      }
    });
    var R = C(85893);
    var L = C(93967);
    var B = C.n(L);
    var F = C(67294);
    var U = C(63811);
    var H = C.n(U);
    function Button(m) {
      let {
        children: _,
        variant: C = "default",
        isActive: L = false,
        as: U,
        className: q,
        ...V
      } = m;
      let X = U || "button";
      let [K, Y] = (0, F.useState)(false);
      return (0, R.jsx)(R.Fragment, {
        children: (0, R.jsx)(X, {
          className: B()(H().button, H()[C], L && H().isActive, q, K && H().clicked),
          ...V,
          onMouseDown: () => Y(true),
          onMouseUp: () => Y(false),
          onMouseOut: () => Y(false),
          "data-sentry-element": "TagName",
          "data-sentry-source-file": "button.tsx",
          children: _
        })
      });
    }
  },
  76723: function (m, _, C) {
    "use strict";

    C.r(_);
    C.d(_, {
      ACCESS_KEY_TIKTOK: function () {
        return eu;
      },
      default: function () {
        return _app;
      },
      growthbook: function () {
        return ed;
      }
    });
    var R = C(85893);
    C(12732);
    var L = C(67294);
    C(91326);
    C(34385);
    C(24106);
    var B = C(49089);
    var F = C(11163);
    var U = C(25074);
    var H = C(27243);
    C(83079);
    var q = C(2181);
    var V = C(62961);
    var X = C(54847);
    var K = C(52969);
    var Y = C.n(K);
    var Q = C(4595);
    let ErrorContent = m => {
      let {
        message: _,
        title: C
      } = m;
      return (0, R.jsxs)("div", {
        className: Y().errorPage,
        "data-sentry-component": "ErrorContent",
        "data-sentry-source-file": "ErrorDom.tsx",
        children: [(0, R.jsx)("h1", {
          children: C ?? "Site under maintenance"
        }), (0, R.jsx)("p", {
          children: _ ?? "We're sorry! Site under maintenance. We'll be back soon! Thank you for your patience."
        }), (0, R.jsx)("br", {}), (0, R.jsx)("br", {}), (0, R.jsx)(Q.Z, {
          variant: "primary",
          onClick: () => location.reload(),
          "data-sentry-element": "Button",
          "data-sentry-source-file": "ErrorDom.tsx",
          children: "Try again?"
        })]
      });
    };
    let ErrorBoundary = class ErrorBoundary extends L.Component {
      static getDerivedStateFromError(m) {
        return {
          hasError: true
        };
      }
      componentDidCatch(m, _) {
        console.log({
          error: m,
          errorInfo: _
        });
      }
      render() {
        if (this.state.hasError) {
          return (0, R.jsx)(ErrorContent, {
            title: "Oops, something went wrong",
            message: "There are technical issues. Our team working on fix. Apologies for inconvenience.",
            "data-sentry-element": "ErrorContent",
            "data-sentry-component": "ErrorBoundary",
            "data-sentry-source-file": "index.tsx"
          });
        } else {
          return this.props.children;
        }
      }
      constructor(m) {
        super(m);
        this.state = {
          hasError: false
        };
      }
    };
    var et = C(27188);
    var er = C.n(et);
    var en = C(93967);
    var ei = C.n(en);
    let LoadingScreen = m => {
      return (0, R.jsx)("div", {
        ...m,
        className: ei()(er().loaderScreen, m.className ?? null),
        "data-sentry-component": "LoadingScreen",
        "data-sentry-source-file": "LoaderScreen.tsx",
        children: (0, R.jsx)("div", {
          className: er().loaderScreenCenter,
          children: (0, R.jsx)("img", {
            src: "/logotype.svg",
            alt: "bloxflip logo"
          })
        })
      });
    };
    var eo = C(6428);
    var ea = C(81361);
    let nanoid = (m = 21) => crypto.getRandomValues(new Uint8Array(m)).reduce((m, _) => {
      if ((_ &= 63) < 36) {
        m += _.toString(36);
      } else if (_ < 62) {
        m += (_ - 26).toString(36).toUpperCase();
      } else if (_ > 62) {
        m += "-";
      } else {
        m += "_";
      }
      return m;
    }, "");
    var es = C(83198);
    var ec = C(25387);
    var el = C(38178);
    let eu = "ea70247f8e7befdbf58568f6594c556306c99618";
    let ed = new ea.Gr({
      apiHost: "https://cdn.growthbook.io",
      clientKey: "key_prod_559ede01dcb3b310",
      trackingCallback: (m, _) => {
        console.log({
          experimentId: m.key,
          variationId: _.variationId
        });
      }
    });
    ec.d.configure();
    function _app(m) {
      let {
        Component: _,
        pageProps: C
      } = m;
      let K = (0, F.useRouter)();
      let Y = (0, eo.Z)();
      let [Q, et] = (0, L.useState)(false);
      let [er, en] = (0, L.useState)(false);
      let updateIpAddress = async () => {
        try {
          let m = await (0, q.I_R)();
          if (!m || !("ip" in m)) {
            throw Error("no ip address");
          }
          window.ipAddress = m.ip;
          if (X.Z) {
            X.Z.dispatch({
              type: V.QU,
              payload: m.ip
            });
          }
        } catch (m) {
          console.log(m);
        }
      };
      let handleGrowBook = async () => {
        try {
          await ed.loadFeatures();
          let m = localStorage.getItem("visitorId");
          if (!m) {
            m = nanoid();
            localStorage.setItem("visitorId", m);
          }
          let _ = !!X.Z.getState().auth.user;
          ed.setAttributes({
            id: m,
            loggedIn: _,
            url: document.location.href
          });
        } catch (m) {
          console.log(m);
        }
      };
      let handleHashs = () => {
        let m = location.hash.trim();
        if (m.includes("#giveaway")) {
          X.Z.dispatch({
            type: V.IP
          });
        }
      };
      (0, L.useEffect)(() => {
        let handleRouteChange = m => {
          console.log("routing to " + m);
          if (ed.getFeatures().fe_ga_enabled) {
            B.ZP.send({
              hitType: "pageview",
              page: location.pathname + location.search
            });
          }
          if (ed.getFeatures().fe_mixpanel_enabled) {
            es.Z.track("pageview", {
              page: location.pathname + location.search
            });
          }
        };
        K.events.on("routeChangeComplete", handleRouteChange);
        return () => {
          K.events.off("routeChangeComplete", handleRouteChange);
        };
      }, [K.events]);
      (0, L.useEffect)(() => {
        if (navigator.serviceWorker) {
          navigator.serviceWorker.register(`${self.origin}/OneSignalSDKWorker.js`).then(m => console.log(m)).catch(m => console.log(m));
        }
      }, []);
      (0, L.useEffect)(() => {
        (0, el.aG)();
        handleHashs();
        handleGrowBook();
        updateIpAddress();
        U.Z.init({
          appId: "c8fbda32-4568-4342-9ac1-2a9f5c996546"
        }).then(async () => {
          et(true);
          await Promise.race([U.Z.isPushNotificationsEnabled, () => new Promise(m => setTimeout(() => m(true), 1000))].map(m => m()));
          U.Z.showSlidedownPrompt().then(() => {
            console.log("one signal prompted");
          });
        });
        let handleRouteChange = () => {
          if (ed.getFeatures().fe_ga_enabled) {
            console.log("ga4 !!up");
          }
        };
        K.events.on("routeChangeComplete", handleRouteChange);
        (0, q.vK9)();
        sessionStorage.setItem("timeJoined", new Date().getTime().toString());
        H.Z.init(3100154, 6);
        es.Z.init("0c9266b8cede669e4a7bd3bfb2c8e6e4");
        B.ZP.initialize("G-7QWC8W9ECE");
        B.ZP.ga(m => {
          window.ga4ClientId = m.get("clientId");
        });
        window.intercomSettings = {
          api_base: "https://api-iam.intercom.io",
          app_id: "ze033am6"
        };
        (function () {
          let m = window;
          let _ = m.Intercom;
          if (typeof _ == "function") {
            _("reattach_activator");
            _("update", m.intercomSettings);
          } else {
            let _ = document;
            let i = function () {
              i.c(arguments);
            };
            i.q = [];
            i.c = function (m) {
              i.q.push(m);
            };
            m.Intercom = i;
            let l = function () {
              let m = _.createElement("script");
              m.type = "text/javascript";
              m.async = true;
              m.src = "https://widget.intercom.io/widget/ze033am6";
              let C = _.getElementsByTagName("script")[0];
              C.parentNode.insertBefore(m, C);
            };
            if (document.readyState === "complete") {
              l();
            } else if (m.attachEvent) {
              m.attachEvent("onload", l);
            } else {
              m.addEventListener("load", l, false);
            }
          }
        })();
        return () => {
          K.events.off("routeChangeComplete", handleRouteChange);
        };
      }, []);
      (0, L.useEffect)(() => {
        setTimeout(() => {
          if (document.querySelector("script[src=\"https://cdn.deviceinf.com/js/v6/agent.umd.js\"]")) {
            if (window.seon) {
              window.seon.init();
            }
          } else {
            let m = document.createElement("script");
            m.async = true;
            m.defer = true;
            m.type = "text/javascript";
            m.src = "https://cdn.deviceinf.com/js/v6/agent.umd.js";
            m.onload = () => {
              console.log("seon is", window.seon);
              window.seon.init();
            };
            m.onerror = () => {
              console.error("Failed to load the seon script.");
            };
            document.body.appendChild(m);
            return () => {
              document.body.removeChild(m);
            };
          }
        }, 5000);
      }, []);
      let ei = _.getLayout || (m => m);
      (0, L.useEffect)(() => {
        let handleRouteChange = () => {
          try {
            let {
              firstLoaded: m
            } = X.Z.getState().auth;
            if (m) {
              return;
            }
            en(true);
          } catch (m) {
            console.log(m);
          }
        };
        let handleRouteChangeComplete = () => {
          en(false);
        };
        try {
          let {
            firstLoaded: m
          } = X.Z.getState().auth;
          if (!m) {
            X.Z.dispatch({
              type: V.bO,
              payload: true
            });
          }
        } catch (m) {
          console.log(m);
        }
        K.events.on("routeChangeStart", handleRouteChange);
        K.events.on("routeChangeComplete", handleRouteChangeComplete);
        K.events.on("routeChangeError", handleRouteChangeComplete);
        return () => {
          K.events.off("routeChangeStart", handleRouteChange);
          K.events.off("routeChangeError", handleRouteChangeComplete);
          K.events.off("routeChangeComplete", handleRouteChangeComplete);
        };
      }, [K.events]);
      return (0, R.jsxs)(ErrorBoundary, {
        "data-sentry-element": "ErrorBoundary",
        "data-sentry-component": "MyApp",
        "data-sentry-source-file": "_app.tsx",
        children: [(0, R.jsx)(LoadingScreen, {
          className: !er && Y.width > 0 ? "fadeout" : undefined,
          "data-sentry-element": "LoadingScreen",
          "data-sentry-source-file": "_app.tsx"
        }), (0, R.jsx)(ea.Ny, {
          growthbook: ed,
          "data-sentry-element": "GrowthBookProvider",
          "data-sentry-source-file": "_app.tsx",
          children: ei((0, R.jsx)(_, {
            ...C,
            oneSignalInitialized: Q
          }))
        })]
      });
    }
  },
  2181: function (m, _, C) {
    "use strict";

    C.d(_, {
      $NM: function () {
        return loginWithCookie;
      },
      $Oj: function () {
        return loginWithUserPass;
      },
      $P3: function () {
        return changNotiSettings;
      },
      $wS: function () {
        return playBlackjackV2Action;
      },
      AHC: function () {
        return rollRewardCase;
      },
      Ab4: function () {
        return createTowersGame;
      },
      B4p: function () {
        return setWithdrawalTarget;
      },
      BYP: function () {
        return getCaseBattles;
      },
      C6: function () {
        return getRobux;
      },
      CZg: function () {
        return getSellixHistory;
      },
      DA_: function () {
        return getRaffleDrawingResults;
      },
      Dqh: function () {
        return InitRblxAgeCheck;
      },
      EXI: function () {
        return getGameHistory;
      },
      EXV: function () {
        return loginWithRedemptionToken;
      },
      FOM: function () {
        return setAttemptPayment;
      },
      FSK: function () {
        return createDiceGame;
      },
      Fo_: function () {
        return loginWithUserPassAndSecondFactor;
      },
      FzF: function () {
        return getUserCrashData;
      },
      G8W: function () {
        return getFflags;
      },
      GSw: function () {
        return getBigRollPlayers;
      },
      GVV: function () {
        return showListedLimited;
      },
      Gio: function () {
        return upgradeMultipleCase;
      },
      H_Z: function () {
        return getWalletHistory;
      },
      HtC: function () {
        return claimUserAffiliateEarnings;
      },
      HtV: function () {
        return completeSecurityQuestion;
      },
      Hvh: function () {
        return getRaceInformation;
      },
      I80: function () {
        return launchExternalGame;
      },
      IBG: function () {
        return testAuth;
      },
      ICb: function () {
        return getAuthenticatedUser;
      },
      IQh: function () {
        return getAllRewards;
      },
      ITX: function () {
        return getVideoCompetitions;
      },
      I_R: function () {
        return getIpAddress;
      },
      It1: function () {
        return confirmEmailCode;
      },
      J6H: function () {
        return doTowersAction;
      },
      J_T: function () {
        return doMinesAction;
      },
      Jbu: function () {
        return getSingleCase;
      },
      JmF: function () {
        return getDiceGame;
      },
      KX5: function () {
        return depositStripeWithPaymentIntent;
      },
      Kbv: function () {
        return getVideoCompetitionsWinners;
      },
      Lti: function () {
        return getUserProfileData;
      },
      MAM: function () {
        return unlinkPhone;
      },
      MS6: function () {
        return loginWithUserPassAndToken;
      },
      MeR: function () {
        return fetchCryptoInfo;
      },
      N4q: function () {
        return completeTradeFrictionChallenge;
      },
      NPu: function () {
        return getCrashSchema;
      },
      NXu: function () {
        return unlinkEmail;
      },
      Ne5: function () {
        return createBlackjackV2Game;
      },
      NfL: function () {
        return rollItemsCase;
      },
      Nhe: function () {
        return createMinesGame;
      },
      NxJ: function () {
        return getAllItems;
      },
      OIx: function () {
        return confirmSmsCode;
      },
      PlH: function () {
        return depositBloxBillGooglePay;
      },
      Plg: function () {
        return getMinesGame;
      },
      Q2H: function () {
        return purchaseLimited;
      },
      QZi: function () {
        return listForSale;
      },
      Qiv: function () {
        return checkPayGardenDailyDepositLimit;
      },
      QnB: function () {
        return loginWithLinkRealm;
      },
      Qy1: function () {
        return solve2FA;
      },
      RZ0: function () {
        return liquidateRbx;
      },
      SCO: function () {
        return getUserCards;
      },
      Sv1: function () {
        return loginwithpassWeblogin;
      },
      U0J: function () {
        return getRaffleLatestGame;
      },
      URt: function () {
        return getDepositDiscounts;
      },
      VD: function () {
        return getCCMethodsAllowed;
      },
      W4R: function () {
        return getSlideSchema;
      },
      WOK: function () {
        return fetchSwapped;
      },
      WcZ: function () {
        return createNewBattle;
      },
      XMO: function () {
        return ChangeUserPrivacy;
      },
      Y8w: function () {
        return createCommunityCase;
      },
      Z5X: function () {
        return depositStripeWithPaymentMethod;
      },
      ZO7: function () {
        return redeemGiftcard;
      },
      ZYU: function () {
        return initiateGameAuth;
      },
      _De: function () {
        return attachPhoneNumber;
      },
      _Fc: function () {
        return getCommunityCase;
      },
      _Lf: function () {
        return findCaseItem;
      },
      _Lu: function () {
        return depositBloxBill;
      },
      _Mv: function () {
        return unlistItem;
      },
      __8: function () {
        return ssoSync;
      },
      _yt: function () {
        return upgradeCase;
      },
      a4R: function () {
        return getCaseBattle;
      },
      aKb: function () {
        return updateUserAffiliateCode;
      },
      bIn: function () {
        return claimRakebackBalance;
      },
      bUA: function () {
        return loginWithInstant;
      },
      blP: function () {
        return q;
      },
      cdK: function () {
        return deleteCommunityCase;
      },
      cru: function () {
        return getRecentBets;
      },
      foq: function () {
        return getJackpotGame;
      },
      gfS: function () {
        return getRaffleWinners;
      },
      guP: function () {
        return updateCommunityCase;
      },
      hI4: function () {
        return getAllSlotGames;
      },
      ihh: function () {
        return getGamepasses;
      },
      ikH: function () {
        return getTowersGame;
      },
      jPb: function () {
        return getChatData;
      },
      jS6: function () {
        return getRates;
      },
      jTS: function () {
        return getUserAffiliatesData;
      },
      kr6: function () {
        return loginWithRobloxSSO;
      },
      lrf: function () {
        return getProvablyFairData;
      },
      mUe: function () {
        return ssoLink;
      },
      mXL: function () {
        return getBigRollGame;
      },
      nSh: function () {
        return checkKinguinGiftcard;
      },
      nTd: function () {
        return getAllCommunityCases;
      },
      nXh: function () {
        return getAuthUser;
      },
      oib: function () {
        return getSiteSchema;
      },
      orI: function () {
        return rollPlinkoGame;
      },
      oux: function () {
        return claimCouponCode;
      },
      pQW: function () {
        return deleteUserCard;
      },
      pxG: function () {
        return prepareTwoFactoredTrade;
      },
      q0g: function () {
        return FinishMLAgeCheck;
      },
      q59: function () {
        return checkGameAuth;
      },
      q6B: function () {
        return getCommunityCases;
      },
      qAr: function () {
        return lookupUser;
      },
      rMC: function () {
        return attachEmail;
      },
      reb: function () {
        return getLimiteds;
      },
      rtJ: function () {
        return completeTradeFrictionChallengeV2;
      },
      sIj: function () {
        return updateClientSeed;
      },
      sjs: function () {
        return showListedLimiteds;
      },
      spc: function () {
        return getPlinkoMultipliers;
      },
      sxD: function () {
        return solveCaptcha;
      },
      t9F: function () {
        return get10percentBonus;
      },
      vK9: function () {
        return changeSourceHeader;
      },
      vRJ: function () {
        return InitMLAgeCheck;
      },
      ve9: function () {
        return handle2fa;
      },
      vuG: function () {
        return depositBloxBillApplePay;
      },
      wAH: function () {
        return enterLinkUrl;
      },
      wCQ: function () {
        return joinBigRollGame;
      },
      wLO: function () {
        return getAllCases;
      },
      wjJ: function () {
        return getAuthMethods;
      },
      x$_: function () {
        return depositRbxFromBloxland;
      },
      y7t: function () {
        return getCurrentBlackjackV2Game;
      },
      yDX: function () {
        return deleteCurrentBlackjackV2Game;
      },
      yI8: function () {
        return getUserVipData;
      },
      ylq: function () {
        return handleBlackjackV2Insurance;
      },
      zO2: function () {
        return rollCommunityCase;
      },
      zXi: function () {
        return initializeTradeFrictionChallenge;
      },
      zeD: function () {
        return getActiveCupsGames;
      }
    });
    var L = C(9669);
    var B = C.n(L);
    C(76723);
    var F = C(86501);
    var U = C(11530);
    let H = "";
    H = "/darianAPI"
    let q = B().create({
      baseURL: H,
      headers: B().defaults.headers.common
    });
    let getFflags = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("https://cdn.growthbook.io/api/features/key_prod_559ede01dcb3b310");
        let C = {};
        for (let m in _.data.features) {
          C[m] = _.data.features[m].defaultValue;
        }
        m(C);
      } catch (m) {
        _(m);
      }
    });
    let changeSourceHeader = (m, _) => {
      if (["rain", "rakeback", "daily"].includes(_)) {
        if (new Date().getTime() - sessionStorage.getItem("timeJoined") < (window.sourceRetentionInt ?? 120000)) {
          q.defaults.headers.common.source = _ + "Retention";
          return;
        }
      }
    };
    let InitRblxAgeCheck = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/rblx-agecheck", {});
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let InitMLAgeCheck = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/ml-agecheck", {});
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let FinishMLAgeCheck = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/ml-agecheck", {
          sessionId: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let ChangeUserPrivacy = async m => new Promise(async (_, C) => {
      try {
        let C = await q.put("/user/update-privacy-enabled", {
          privacyEnabled: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getSiteSchema = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/site");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let loginWithRobloxSSO = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/login?oauth=true&clientId=" + C, {
          affiliateCode: _,
          codeToken: m
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let ssoLink = async m => {
      let {
        externalToken: _,
        redirectUrl: C
      } = m;
      return new Promise(async (m, R) => {
        try {
          let R = await q.post("/user/link-sso", {
            externalToken: _,
            redirectUrl: C
          }, {
            headers: {
              "x-auth-token": localStorage.getItem("_DO_NOT_SHARE_BLOXFLIP_TOKEN")
            }
          });
          m(R.data);
        } catch (m) {
          R(m);
        }
      });
    };
    let ssoSync = async m => {
      let {
        externalToken: _,
        redirectUrl: C
      } = m;
      return new Promise(async (m, R) => {
        try {
          let R = await q.post("/user/link-bgame", {
            externalToken: _,
            redirectUrl: C
          });
          m(R.data);
        } catch (m) {
          R(m);
        }
      });
    };
    let checkGameAuth = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/bio-auth/check", {
          resumeKey: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let launchExternalGame = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/games/external/launch", {
          slug: m,
          demo: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let initiateGameAuth = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/user/bio-auth", {
          username: m,
          resumeKey: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getAuthUser = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getWalletHistory = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.get("/user/wallet-history?size=" + _ + "&page=" + m);
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getSellixHistory = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.get("/user/sellix-history?size=" + _ + "&page=" + m);
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getAuthMethods = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.get("/user/auth-methods/" + m + "?uniqueDeviceId=" + _);
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getGameHistory = async (m, _, C) => {
      console.log(m);
      return new Promise(async (R, L) => {
        try {
          let L = await q.get(`/games/${m}/history?size=${C}&page=${_}`);
          R(L.data);
        } catch (m) {
          L(m);
        }
      });
    };
    let getGamepasses = async m => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/gamepasses");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getAuthenticatedUser = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/user?cache=" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getRobux = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/inventory/viewRbx");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let showListedLimiteds = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/limiteds");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let showListedLimited = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/limiteds/show/" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getLimiteds = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/inventory/viewRoblox");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let testAuth = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/isAuthenticated");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getChatData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/chat/history");
        _.data.messages.forEach(uwu=>window.chat.push(uwu))
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getUserProfileData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let lookupUser = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/user/lookup/" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let unlistItem = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/limiteds/unlist", {
          userAssetId: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let createTowersGame = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/games/towers/create", {
          difficulty: m,
          betAmount: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let doTowersAction = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/games/towers/action", {
          cashout: m,
          tile: _,
          towerLevel: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let getTowersGame = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/towers");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let createMinesGame = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/games/mines/create", {
          mines: m,
          betAmount: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let doMinesAction = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/games/mines/action", {
          cashout: m,
          mine: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getMinesGame = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/mines");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let rollPlinkoGame = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/games/plinko/roll", {
          rows: m,
          risk: _,
          amount: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let purchaseLimited = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/limiteds/purchase", {
          userAssetId: m,
          itemPrice: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let initializeTradeFrictionChallenge = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.post("/limiteds/challenge/initialize", {});
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let prepareTwoFactoredTrade = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/limiteds/challenge/initialize", {
          tId: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let completeSecurityQuestion = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/complete-question", {
          sessionId: m,
          userId: _,
          answer: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let completeTradeFrictionChallengeV2 = async (m, _, C, R, L, B) => new Promise(async (F, U) => {
      try {
        let U = await q.post("/limiteds/challenge/complete", {
          challengeType: m,
          challengeId: _,
          code: C,
          challengeMetadata: R,
          challengeExtType: L,
          tId: B
        });
        F(U.data);
      } catch (m) {
        U(m);
      }
    });
    let completeTradeFrictionChallenge = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/limiteds/challenge/complete", {
          challengeType: m,
          challengeId: _,
          code: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let listForSale = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/limiteds/list", {
          userAssetId: m,
          itemPrice: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let handle2fa = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/limiteds/2fa", {
          code: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let redeemGiftcard = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/redeem", {
          code: m,
          fp: _,
          clientId: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let depositRbxFromBloxland = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/bloxLandDeposit", {
          amount: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let setWithdrawalTarget = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/withdrawTarget", {
          amount: m,
          deliveryType: _,
          session: C
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let liquidateRbx = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/liquidate", {
          amount: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let depositStripeWithPaymentMethod = async (m, _, C, R, L) => new Promise(async (B, F) => {
      try {
        let F = await q.post("/user/depositCC?newPricingV2=true", {
          rbxAmount: m,
          paymentMethod: _,
          sponsorCode: C,
          clientId: R,
          token: L
        });
        B(F.data);
      } catch (m) {
        F(m);
      }
    });
    let getCCMethodsAllowed = () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/depositCC");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let depositBloxBill = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
          bloxBillToken: m,
          saveCard: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let depositBloxBillGooglePay = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
          googlePayData: m,
          usdAmount: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let depositBloxBillApplePay = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/user/depositCC/bloxbill?newPricingV2=true", {
          applePayData: m,
          usdAmount: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let depositStripeWithPaymentIntent = async (m, _, C, R, L) => new Promise(async (B, F) => {
      try {
        let F = await q.post("/user/depositCC?newPricingV2=true", {
          rbxAmount: m,
          paymentIntentId: _,
          sponsorCode: C,
          clientId: R,
          token: L
        });
        B(F.data);
      } catch (m) {
        F(m);
      }
    });
    let getRates = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/depositCC?newPricingV2=true", {
          rbxAmount: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let fetchSwapped = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/swapped", {});
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let fetchCryptoInfo = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/crypto-info", {
          assetId: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getRecentBets = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/live-feed/" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getUserAffiliatesData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/affiliates");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let updateUserAffiliateCode = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/affiliates/update-code", {
          code: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let claimUserAffiliateEarnings = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.post("/user/affiliates/claim", {});
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let claimCouponCode = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/coupon/redeem", {
          code: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let setAttemptPayment = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post(`/user/depositCC/attempt?depositMethod=${m}`, {});
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getActiveCupsGames = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/cups");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getRaceInformation = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/race");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getCaseBattle = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/games/case-battles?_id=" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getCaseBattles = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/case-battles");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let createCommunityCase = async m => {
      let {
        items: _,
        commission: C
      } = m;
      return new Promise(async (m, R) => {
        try {
          let R = await q.post("/games/community-cases/create", {
            items: _,
            commission: C
          });
          m(R.data);
        } catch (m) {
          R(m);
        }
      });
    };
    let createNewBattle = async function (m, _, C, R = "SOLO_1V1", L, B, F) {
      return new Promise(async (U, H) => {
        try {
          let H = await q.post("/games/case-battles/create", {
            caseItems: m,
            expectedPrice: _,
            quickOpening: C,
            gameMode: R,
            crazyMode: L,
            sharedMode: B,
            terminalMode: F
          });
          U(H.data);
        } catch (m) {
          H(m);
        }
      });
    };
    let rollRewardCase = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/rewards/roll", {
          slug: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let rollItemsCase = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/games/cases/roll", {
          slug: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let rollCommunityCase = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post("/games/cases/roll", {
          uuid: m,
          directPlay: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let upgradeCase = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post(`games/${_}/upgrade`, {
          gameId: m
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let upgradeMultipleCase = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.post(`games/${_}/upgrade/bulk`, {
          gameIds: m
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let findCaseItem = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/games/community-cases/find-item", {
          value: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getCommunityCase = async m => new Promise(async (_, C) => {
      try {
        var L;
        let C = await q.get("/games/community-cases/" + m);
        _((L = C.data) === null || L === undefined ? undefined : L.cases?.[0]);
      } catch (m) {
        C(m);
      }
    });
    let deleteCommunityCase = async m => new Promise(async (_, C) => {
      try {
        let C = await q.delete("/games/community-cases/" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let updateCommunityCase = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.patch("/games/community-cases/" + m, {
          displayName: _
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getSingleCase = async m => new Promise(async (_, C) => {
      try {
        var L;
        let C = await q.get("/games/cases/" + m);
        _((L = C.data) === null || L === undefined ? undefined : L.cases?.[0]);
      } catch (m) {
        C(m);
      }
    });
    let getAllRewards = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/rewards?cache=" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getAllCases = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/cases");
        m(_.data.cases);
      } catch (m) {
        _(m);
      }
    });
    let getAllSlotGames = async (m, _, C, R) => new Promise(async (L, B) => {
      try {
        let B = await q.get("/games/external?page=" + m + "&size=100&provider=" + R + "&sort=" + C + "&search=" + _);
        L(B.data);
      } catch (m) {
        B(m);
      }
    });
    let getCommunityCases = async m => {
      let {
        search: _,
        minPrice: C,
        maxPrice: R
      } = m;
      let L = new URLSearchParams();
      if (_ && _.length > 2) {
        L.append("searchTerm", _);
      }
      if (C) {
        L.append("minPrice", C);
      }
      if (R) {
        L.append("maxPrice", R);
      }
      try {
        let m = await q.get("/games/community-cases", {
          params: L
        });
        return m.data.cases;
      } catch (m) {
        F.Am.error(m.response.data.message ?? "Something went wrong");
      }
    };
    let getAllCommunityCases = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get(`/games/community-cases${m ? "?filter=my" : ""}`);
        _(C.data.cases);
      } catch (m) {
        F.Am.error(m.response.data.message ?? "Something went wrong");
        C(m);
      }
    });
    let getAllItems = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.get("/games/community-cases/items?page=" + m + "&limit=" + _ + "&query=" + C);
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let getPlinkoMultipliers = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/plinko/multipliers");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getUserVipData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/vip");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let claimRakebackBalance = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.post("/vip/claim");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getProvablyFairData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/provably-fair");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let updateClientSeed = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/provably-fair/clientSeed", {
          clientSeed: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let loginWithUserPass = async (m, _, C, R) => new Promise(async (L, B) => {
      try {
        let B = await q.post("/user/login?userpass=true&clientId=" + R, {
          affiliateCode: C,
          username: m,
          password: _
        });
        L(B.data);
      } catch (m) {
        B(m);
      }
    });
    let loginWithLinkRealm = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/login?linkrealm=true&clientId=" + C, {
          affiliateCode: _,
          token: m
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let loginWithInstant = async (m, _, C, R) => new Promise(async (L, B) => {
      try {
        let B = await q.post("/user/login?instant=true&clientId=" + R, {
          affiliateCode: _,
          username: m,
          deviceId: C
        });
        L(B.data);
      } catch (m) {
        B(m);
      }
    });
    let loginWithUserPassAndToken = async (m, _, C, R, L, B, F, U) => new Promise(async (H, V) => {
      try {
        let V = await q.post("/user/login?userpass=true&preAuth=false&clientId=" + B, {
          affiliateCode: L,
          username: m,
          password: _,
          captchaId: C,
          captchaToken: R,
          securityQuestionRedemptionToken: F,
          securityQuestionSessionId: U
        });
        H(V.data);
      } catch (m) {
        V(m);
      }
    });
    let loginWithUserPassAndSecondFactor = async (m, _, C, R, L, B, F) => new Promise(async (U, H) => {
      try {
        let H = await q.post("/user/login?userpass=true&clientId=" + F, {
          affiliateCode: B,
          challengeId: m,
          userId: _,
          code: L,
          challengeType: C,
          password: R
        });
        U(H.data);
      } catch (m) {
        H(m);
      }
    });
    let loginWithRedemptionToken = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/login?bioauth=true&clientId=" + C, {
          affiliateCode: _,
          redemptionToken: m
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let loginWithCookie = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/login?clientId=" + C, {
          cookie: m,
          affiliateCode: _
        });
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let getSlideSchema = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/roulette");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getCrashSchema = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/crash");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getUserCrashData = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/crash/me");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getJackpotGame = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/jackpot");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let joinBigRollGame = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/games/bigroll/join", {
          betAmount: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getBigRollGame = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/bigroll/game");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getBigRollPlayers = async (m, _) => new Promise(async (C, R) => {
      try {
        let R = await q.get("/games/bigroll/players", {
          params: {
            page: m,
            pageSize: _
          }
        });
        C(R.data);
      } catch (m) {
        R(m);
      }
    });
    let getRaffleDrawingResults = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/games/raffle/drawing-results");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let attachEmail = async m => new Promise(async (_, C) => {
      try {
        let C = await q.put("/user/init-change-email", {
          email: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let confirmEmailCode = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/confirm-change-email", {
          code: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let attachPhoneNumber = async m => new Promise(async (_, C) => {
      try {
        let C = await q.put("/user/init-change-phone", {
          phoneNumber: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let unlinkPhone = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.delete("/user/remove-phone");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let unlinkEmail = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.delete("/user/remove-email");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let confirmSmsCode = async m => new Promise(async (_, C) => {
      try {
        let C = await q.post("/user/confirm-change-phone", {
          code: m
        });
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let changNotiSettings = async m => new Promise(async (_, C) => {
      let R = {
        ...m
      };
      R.rainNotificationSettings.rainMinimum = R.rainNotificationSettings.rainMinimum * 1000;
      try {
        let m = await q.put("/user/notification-settings", R);
        _(m.data);
      } catch (m) {
        C(m);
      }
    });
    let getRaffleWinners = async function (m = null) {
      return new Promise(async (_, C) => {
        try {
          let C = await q.get("/games/raffle/latest-winners" + (m ? "?limit=" + m : ""));
          _(C.data);
        } catch (m) {
          C(m);
        }
      });
    };
    let getRaffleLatestGame = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/games/raffle/latest-game" + (m ? "?gameId=" + m : ""));
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getDepositDiscounts = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/user/promotion/deposits/active");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getVideoCompetitions = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("user/video-competition/active-competition?competitionType=" + m);
        _(C.data);
      } catch (m) {
        C(m);
      }
    });
    let getVideoCompetitionsWinners = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.get(`user/video-competition/recent-winners?competitionType=${m}&pageIndex=${_}&pageSize=${C}`);
        R(L.data);
      } catch (m) {
        L(m);
      }
    });
    let enterLinkUrl = async m => {
      let {
        captchaToken: _,
        competitionType: C,
        videoUrl: R
      } = m;
      return new Promise(async (m, L) => {
        try {
          let L = await q.post("/user/video-competition/join", {
            captchaToken: _,
            competitionType: C,
            videoUrl: R
          });
          m(L.data);
        } catch (m) {
          L(m);
        }
      });
    };
    let getIpAddress = async () => new Promise(async (m, _) => {
      try {
        let _ = await window.fetch("https://api.ipify.org?format=json", {
          mode: "cors"
        });
        let C = await _.json();
        m(C);
      } catch (m) {
        _(m);
      }
    });
    let checkKinguinGiftcard = async m => new Promise(async (_, C) => {
      try {
        let C = await q.get("/825adace-b454-11ec-b909-0242ac120002/external/check/d439985f-5b59-43bb-ac59-238307e17f78", {
          params: {
            code: m
          }
        });
        let R = await C.data;
        _(R);
      } catch (m) {
        C(m);
      }
    });
    let loginwithpassWeblogin = async (m, _, C) => new Promise(async (R, L) => {
      try {
        let L = await q.post("/user/login?weblogin=true&clientId=" + C, {
          username: m,
          password: _
        });
        R(L);
      } catch (m) {
        L(m);
      }
    });
    let solveCaptcha = async (m, _, C, R) => new Promise(async (L, B) => {
      try {
        let B = await q.post("/user/login?weblogin=true&clientId=" + C, {
          instanceId: m,
          sessionId: _,
          inputChoice: R
        });
        L(B);
      } catch (m) {
        B(m);
      }
    });
    let solve2FA = async (m, _, C, R) => new Promise(async (L, B) => {
      try {
        let B = await q.post("/user/login?weblogin=true&clientId=" + C, {
          instanceId: m,
          sessionId: _,
          code: R
        });
        L(B.data);
      } catch (m) {
        B(m);
      }
    });
    let get10percentBonus = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.request({
          method: "POST",
          url: "/user/promotion/promocodes/affiliate",
          headers: {
            "Content-Type": "application/json"
          }
        });
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
    let getDiceGame = m => q.get(`/games/dice/${m}`).then(m => m.data);
    let createDiceGame = (m, _, C, R, L) => q.post("/games/dice/roll", {
      bet: m,
      ranges: [{
        min: C ? 0 : _,
        max: C ? _ : 99.99
      }],
      multiplier: R,
      payout: L
    }).then(m => m.data);
    let createBlackjackV2Game = m => new Promise(async (_, C) => {
      var F;
      try {
        let B = await q.post("games/blackjackv2/join-game", {
          bet: m
        });
        let F = B.data?.success ? _ : C;
        let U = B.data?.success ? B.data.game : B.data.message;
        F(U);
      } catch (_) {
        let m = (F = _.response) === null || F === undefined ? undefined : F.data?.msg;
        C((m || "Something went wrong!").slice(0, 100));
      }
    });
    let playBlackjackV2Action = m => {
      let {
        gameId: _,
        action: C,
        handIndex: R
      } = m;
      return new Promise(async (m, L) => {
        var H;
        try {
          let U = await q.post("games/blackjackv2/action", {
            gameId: _,
            action: C,
            handIndex: R
          });
          let H = U.data?.success ? m : L;
          let V = U.data?.success ? U.data.game : U.data.message;
          H(V);
        } catch (_) {
          let m = (H = _.response) === null || H === undefined ? undefined : H.data?.message;
          L((m || "Something went wrong!").slice(0, 100));
        }
      });
    };
    let handleBlackjackV2Insurance = (m, _) => new Promise(async (C, R) => {
      var U;
      try {
        let F = await q.post("games/blackjackv2/insurance", {
          gameId: m,
          taken: _
        });
        let U = F.data?.success ? C : R;
        let H = F.data?.success ? F.data.game : F.data.message;
        U(H);
      } catch (_) {
        let m = (U = _.response) === null || U === undefined ? undefined : U.data?.message;
        R((m || "Something went wrong!").slice(0, 100));
      }
    });
    let getUserCards = m => q.get("/user/cards").then(m => m.data);
    let deleteUserCard = m => q.delete("/user/cards", {
      data: {
        uuid: m
      }
    }).then(m => m.data);
    let getCurrentBlackjackV2Game = () => new Promise(async (m, _) => {
      var F;
      try {
        let L = await q.get("games/blackjackv2/my-game");
        let B = L.data?.success ? m : _;
        let F = L.data?.success ? L.data.game : L.data.message;
        B(F);
      } catch (C) {
        let m = C.response?.status === 404 ? "404" : (F = C.response) === null || F === undefined ? undefined : F.data?.message;
        _((m || "Something went wrong!").slice(0, 100));
      }
    });
    let deleteCurrentBlackjackV2Game = () => new Promise(async (m, _) => {
      var B;
      try {
        let L = await q.delete("games/blackjackv2/my-game");
        let B = L.data?.success ? m : _;
        let F = L.data?.success ? L.data.game : L.data.message;
        B(F);
      } catch (C) {
        let m = (B = C.response) === null || B === undefined ? undefined : B.data?.message;
        _((m || "Something went wrong!").slice(0, 100));
      }
    });
    let checkPayGardenDailyDepositLimit = async () => new Promise(async (m, _) => {
      try {
        let _ = await q.get("/paygarden/limit-check");
        m(_.data);
      } catch (m) {
        _(m);
      }
    });
  },
  11530: function (m, _, C) {
    "use strict";

    C.d(_, {
      p: function () {
        return R;
      }
    });
    // rape sex
    let R = [{
      name: "Nflip (darian was here UwU)",
      wsUrl: "wss://bf-staging-ws.bazooki-infra.dev",
      restUrl: "/darianAPI"
    }]
  },
  40400: function (m, _) {
    "use strict";

    _.Z = m => {
      return String(m).match(/^-?\d+(?:\.\d{0,2})?/)?.[0];
    };
  },
  38178: function (m, _, C) {
    "use strict";

    C.d(_, {
      Tc: function () {
        return R;
      },
      _Q: function () {
        return playSoundEffect;
      },
      aG: function () {
        return preloadAllSounds;
      }
    });
    let R = {
      BLACKJACK: {
        CARD_SLIDE: {
          url: "../sounds/blackjackv2/card-slide-2.wav",
          speed: 2
        },
        CARD_SLIDE_ALT: {
          url: "../sounds/blackjackv2/card-slide-1.wav",
          speed: 1.5
        },
        CARD_FLIP: {
          url: "../sounds/blackjackv2/card-flip.wav"
        },
        CLICK: {
          url: "../sounds/blackjackv2/click.wav",
          volume: 1,
          speed: 0.5
        },
        COIN: {
          url: "../sounds/blackjackv2/coin-drop.wav",
          volume: 0.2
        },
        COINS_SCATTER: {
          url: "../sounds/blackjackv2/coins-scatter.wav",
          delay: 0.4,
          volume: 0.7
        },
        HINT: {
          url: "../sounds/blackjackv2/hint.mp3",
          volume: 0.5
        },
        WIN: {
          url: "../sounds/blackjackv2/win.mp3",
          speed: 1.2
        }
      },
      DICE: {
        ROLL: {
          url: "../sounds/dice-roll.wav"
        },
        WIN: {
          url: "../sounds/dice-win.mp3"
        }
      },
      UPGRADER: {
        UPGRADE: {
          url: "../sounds/upgrader-sound.mp3",
          volume: 0.4
        }
      },
      CASES: {
        TICK: {
          url: "../sounds/wheel_tick.mp3",
          volume: 0.4
        },
        WIN: {
          url: "../sounds/wheel_win.mp3"
        }
      },
      MINES: {
        SUSPENSE: {
          url: "../sounds/suspense.mp3",
          volume: 0.15
        },
        EXPLOSION: {
          url: "../sounds/explosion.mp3",
          volume: 0.4
        },
        GOOD: {
          url: "../sounds/good.mp3",
          volume: 0.3
        },
        BIG_CASHOUT: {
          url: "../sounds/big_cashout.mp3",
          volume: 0.2
        }
      },
      TOWERS: {
        BREAK: {
          url: "../sounds/break.mp3",
          volume: 0.2
        },
        STOMP: {
          url: "../sounds/stomp.mp3",
          volume: 0.2
        },
        BIG_CASHOUT: {
          url: "../sounds/big_cashout.mp3",
          volume: 0.2
        }
      }
    };
    let playSoundEffect = m => {
      let _ = new Audio(m.url);
      _.currentTime = m.start || 0;
      _.volume = m.volume || 1;
      _.playbackRate = m.speed || 1;
      setTimeout(() => {
        _.play().catch(m => console.warn("Sound Effect Error:", m));
      }, (m.delay || 0) * 1000);
      if (m.end) {
        let C = setTimeout(() => {
          _.pause();
          _.currentTime = 0;
          clearTimeout(C);
        }, m.end * 1000);
      }
      return _;
    };
    let preloadAllSounds = () => {
      let m = {};
      for (let _ in R) {
        let C = R[_];
        m[_] = {};
        for (let R in C) {
          let L = C[R];
          let B = new Audio(L.url);
          B.preload = "auto";
          B.load();
          m[_][R] = B;
        }
      }
    };
  },
  83079: function () {},
  24106: function () {},
  91326: function () {},
  34385: function () {},
  12732: function () {},
  63811: function (m) {
    m.exports = {
      flash: "button_flash__afMd3",
      pulse: "button_pulse__JIqIt",
      button: "button_button__dZRSb",
      primary: "button_primary__LXFHi",
      danger: "button_danger__yRxCm",
      secondary: "button_secondary__Fa_lP",
      square: "button_square__fMSa0",
      ingame: "button_ingame__9oa_7",
      gameControl: "button_gameControl__ElkRq",
      tab: "button_tab__RC45L",
      liveFeedTab: "button_liveFeedTab__Bqsl_",
      pagination: "button_pagination__pIaaC",
      inputButton: "button_inputButton__B2DPv",
      betOption: "button_betOption__yOLYh",
      betOptionCompact: "button_betOptionCompact__Gmzj8",
      autoReset: "button_autoReset__R33EV",
      autoIncrease: "button_autoIncrease__uD_yX",
      isActive: "button_isActive__tpT2u",
      clicked: "button_clicked___FpNk",
      selected: "button_selected__AhHIr",
      functional: "button_functional__S9rty",
      amount: "button_amount__0xcbw",
      debug: "button_debug___BL_z",
      debugActive: "button_debugActive__83d10",
      bottomTop: "button_bottomTop__hxrHI",
      flipCard: "button_flipCard__FYCma",
      bottomTopFlip: "button_bottomTopFlip__0gtbi",
      fade: "button_fade__c1wD8",
      rotate: "button_rotate__xWMdt",
      cupOut: "button_cupOut__jkXra",
      gloss: "button_gloss__crMdU",
      shake: "button_shake__M2koe",
      rotateY: "button_rotateY__r_4ca",
      animateArrow: "button_animateArrow__5kBOs",
      selectionArrowRight: "button_selectionArrowRight__R7ufs",
      selectionArrowLeft: "button_selectionArrowLeft__nFgGy",
      coinExplode: "button_coinExplode__FGeck"
    };
  },
  52969: function (m) {
    m.exports = {
      errorPage: "error_errorPage__6vGAy"
    };
  },
  27188: function (m) {
    m.exports = {
      loaderScreen: "loader_loaderScreen__fVbjK",
      loaderScreenCenter: "loader_loaderScreenCenter__0fFJX",
      loaderScreenCenterLoader: "loader_loaderScreenCenterLoader__a3gD5"
    };
  },
  11163: function (m, _, C) {
    m.exports = C(32059);
  },
  34155: function (m) {
    var _;
    var C;
    var R;
    var L = m.exports = {};
    function defaultSetTimout() {
      throw Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw Error("clearTimeout has not been defined");
    }
    function runTimeout(m) {
      if (_ === setTimeout) {
        return setTimeout(m, 0);
      }
      if ((_ === defaultSetTimout || !_) && setTimeout) {
        _ = setTimeout;
        return setTimeout(m, 0);
      }
      try {
        return _(m, 0);
      } catch (C) {
        try {
          return _.call(null, m, 0);
        } catch (C) {
          return _.call(this, m, 0);
        }
      }
    }
    (function () {
      try {
        _ = typeof setTimeout == "function" ? setTimeout : defaultSetTimout;
      } catch (m) {
        _ = defaultSetTimout;
      }
      try {
        C = typeof clearTimeout == "function" ? clearTimeout : defaultClearTimeout;
      } catch (m) {
        C = defaultClearTimeout;
      }
    })();
    var B = [];
    var F = false;
    var U = -1;
    function cleanUpNextTick() {
      if (F && R) {
        F = false;
        if (R.length) {
          B = R.concat(B);
        } else {
          U = -1;
        }
        if (B.length) {
          drainQueue();
        }
      }
    }
    function drainQueue() {
      if (!F) {
        var m = runTimeout(cleanUpNextTick);
        F = true;
        for (var _ = B.length; _;) {
          R = B;
          B = [];
          while (++U < _) {
            if (R) {
              R[U].run();
            }
          }
          U = -1;
          _ = B.length;
        }
        R = null;
        F = false;
        (function (m) {
          if (C === clearTimeout) {
            return clearTimeout(m);
          }
          if ((C === defaultClearTimeout || !C) && clearTimeout) {
            C = clearTimeout;
            return clearTimeout(m);
          }
          try {
            C(m);
          } catch (_) {
            try {
              return C.call(null, m);
            } catch (_) {
              return C.call(this, m);
            }
          }
        })(m);
      }
    }
    function Item(m, _) {
      this.fun = m;
      this.array = _;
    }
    function noop() {}
    L.nextTick = function (m) {
      var _ = Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var C = 1; C < arguments.length; C++) {
          _[C - 1] = arguments[C];
        }
      }
      B.push(new Item(m, _));
      if (B.length === 1 && !F) {
        runTimeout(drainQueue);
      }
    };
    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };
    L.title = "browser";
    L.browser = true;
    L.env = {};
    L.argv = [];
    L.version = "";
    L.versions = {};
    L.on = noop;
    L.addListener = noop;
    L.once = noop;
    L.off = noop;
    L.removeListener = noop;
    L.removeAllListeners = noop;
    L.emit = noop;
    L.prependListener = noop;
    L.prependOnceListener = noop;
    L.listeners = function (m) {
      return [];
    };
    L.binding = function (m) {
      throw Error("process.binding is not supported");
    };
    L.cwd = function () {
      return "/";
    };
    L.chdir = function (m) {
      throw Error("process.chdir is not supported");
    };
    L.umask = function () {
      return 0;
    };
  },
  49559: function (m, _) {
    "use strict";

    Object.defineProperty(_, "__esModule", {
      value: true
    });
    _.default = function () {
      var m;
      var _;
      var R = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var L = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
      var B = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
      var F = R || "";
      if (L) {
        F = R.toString().trim().replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function (m, _, R) {
          if (_ > 0 && _ + m.length !== R.length && m.search(C) > -1 && R.charAt(_ - 2) !== ":" && (R.charAt(_ + m.length) !== "-" || R.charAt(_ - 1) === "-") && R.charAt(_ - 1).search(/[^\s-]/) < 0) {
            return m.toLowerCase();
          } else if (m.substr(1).search(/[A-Z]|\../) > -1) {
            return m;
          } else {
            return m.charAt(0).toUpperCase() + m.substr(1);
          }
        });
      }
      if (B) {
        F = typeof (_ = m = F) == "string" && _.indexOf("@") !== -1 ? (console.warn("This arg looks like an email address, redacting."), "REDACTED (Potential Email Address)") : m;
      }
      return F;
    };
    var C = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
  },
  41638: function (m, _, C) {
    "use strict";

    Object.defineProperty(_, "__esModule", {
      value: true
    });
    _.default = _.GA4 = undefined;
    var R = _interopRequireDefault(C(76161));
    var L = _interopRequireDefault(C(49559));
    var B = ["eventCategory", "eventAction", "eventLabel", "eventValue", "hitType"];
    var F = ["title", "location"];
    var U = ["page", "hitType"];
    var H = ["action", "category", "label", "value", "nonInteraction", "transport"];
    function _interopRequireDefault(m) {
      if (m && m.__esModule) {
        return m;
      } else {
        return {
          default: m
        };
      }
    }
    function _objectWithoutProperties(m, _) {
      if (m == null) {
        return {};
      }
      var C;
      var R;
      var L = function (m, _) {
        if (m == null) {
          return {};
        }
        var C;
        var R;
        var L = {};
        var B = Object.keys(m);
        for (R = 0; R < B.length; R++) {
          C = B[R];
          if (!(_.indexOf(C) >= 0)) {
            L[C] = m[C];
          }
        }
        return L;
      }(m, _);
      if (Object.getOwnPropertySymbols) {
        var B = Object.getOwnPropertySymbols(m);
        for (R = 0; R < B.length; R++) {
          C = B[R];
          if (!(_.indexOf(C) >= 0) && Object.prototype.propertyIsEnumerable.call(m, C)) {
            L[C] = m[C];
          }
        }
      }
      return L;
    }
    function _typeof(m) {
      return (_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (m) {
        return typeof m;
      } : function (m) {
        if (m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof m;
        }
      })(m);
    }
    function _toConsumableArray(m) {
      return function (m) {
        if (Array.isArray(m)) {
          return _arrayLikeToArray(m);
        }
      }(m) || function (m) {
        if (typeof Symbol != "undefined" && m[Symbol.iterator] != null || m["@@iterator"] != null) {
          return Array.from(m);
        }
      }(m) || _unsupportedIterableToArray(m) || function () {
        throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function ownKeys(m, _) {
      var C = Object.keys(m);
      if (Object.getOwnPropertySymbols) {
        var R = Object.getOwnPropertySymbols(m);
        if (_) {
          R = R.filter(function (_) {
            return Object.getOwnPropertyDescriptor(m, _).enumerable;
          });
        }
        C.push.apply(C, R);
      }
      return C;
    }
    function _objectSpread(m) {
      for (var _ = 1; _ < arguments.length; _++) {
        var C = arguments[_] ?? {};
        if (_ % 2) {
          ownKeys(Object(C), true).forEach(function (_) {
            _defineProperty(m, _, C[_]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(m, Object.getOwnPropertyDescriptors(C));
        } else {
          ownKeys(Object(C)).forEach(function (_) {
            Object.defineProperty(m, _, Object.getOwnPropertyDescriptor(C, _));
          });
        }
      }
      return m;
    }
    function _unsupportedIterableToArray(m, _) {
      if (m) {
        if (typeof m == "string") {
          return _arrayLikeToArray(m, _);
        }
        var C = Object.prototype.toString.call(m).slice(8, -1);
        if (C === "Object" && m.constructor) {
          C = m.constructor.name;
        }
        if (C === "Map" || C === "Set") {
          return Array.from(m);
        }
        if (C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C)) {
          return _arrayLikeToArray(m, _);
        }
      }
    }
    function _arrayLikeToArray(m, _) {
      if (_ == null || _ > m.length) {
        _ = m.length;
      }
      for (var C = 0, R = Array(_); C < _; C++) {
        R[C] = m[C];
      }
      return R;
    }
    function _defineProperties(m, _) {
      for (var C = 0; C < _.length; C++) {
        var R = _[C];
        R.enumerable = R.enumerable || false;
        R.configurable = true;
        if ("value" in R) {
          R.writable = true;
        }
        Object.defineProperty(m, R.key, R);
      }
    }
    function _defineProperty(m, _, C) {
      if (_ in m) {
        Object.defineProperty(m, _, {
          value: C,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        m[_] = C;
      }
      return m;
    }
    var q = function () {
      var m;
      var _;
      function GA4() {
        var m = this;
        (function (m, _) {
          if (!(m instanceof _)) {
            throw TypeError("Cannot call a class as a function");
          }
        })(this, GA4);
        _defineProperty(this, "reset", function () {
          m.isInitialized = false;
          m._testMode = false;
          m._currentMeasurementId;
          m._hasLoadedGA = false;
          m._isQueuing = false;
          m._queueGtag = [];
        });
        _defineProperty(this, "_gtag", function () {
          for (var _ = arguments.length, C = Array(_), L = 0; L < _; L++) {
            C[L] = arguments[L];
          }
          if (m._testMode) {
            m._queueGtag.push(C);
          } else if (m._isQueuing) {
            m._queueGtag.push(C);
          } else {
            R.default.apply(undefined, C);
          }
        });
        _defineProperty(this, "_loadGA", function (_, C) {
          if (typeof window != "undefined" && typeof document != "undefined" && !m._hasLoadedGA) {
            var R = document.createElement("script");
            R.async = true;
            R.src = `https://www.googletagmanager.com/gtag/js?id=${_}`;
            if (C) {
              R.setAttribute("nonce", C);
            }
            document.body.appendChild(R);
            window.dataLayer = window.dataLayer || [];
            window.gtag = function () {
              window.dataLayer.push(arguments);
            };
            m._hasLoadedGA = true;
          }
        });
        _defineProperty(this, "_toGtagOptions", function (m) {
          if (m) {
            var _ = {
              cookieUpdate: "cookie_update",
              cookieExpires: "cookie_expires",
              cookieDomain: "cookie_domain",
              cookieFlags: "cookie_flags",
              userId: "user_id",
              clientId: "client_id",
              anonymizeIp: "anonymize_ip",
              contentGroup1: "content_group1",
              contentGroup2: "content_group2",
              contentGroup3: "content_group3",
              contentGroup4: "content_group4",
              contentGroup5: "content_group5",
              allowAdFeatures: "allow_google_signals",
              allowAdPersonalizationSignals: "allow_ad_personalization_signals",
              nonInteraction: "non_interaction",
              page: "page_path",
              hitCallback: "event_callback"
            };
            return Object.entries(m).reduce(function (m, C) {
              var R = function (m) {
                if (Array.isArray(m)) {
                  return m;
                }
              }(C) || function (m, _) {
                var C;
                var R;
                var L = m == null ? null : typeof Symbol != "undefined" && m[Symbol.iterator] || m["@@iterator"];
                if (L != null) {
                  var B = [];
                  var F = true;
                  var U = false;
                  try {
                    for (L = L.call(m); !(F = (C = L.next()).done) && (B.push(C.value), !_ || B.length !== _); F = true);
                  } catch (m) {
                    U = true;
                    R = m;
                  } finally {
                    try {
                      if (!F && L.return != null) {
                        L.return();
                      }
                    } finally {
                      if (U) {
                        throw R;
                      }
                    }
                  }
                  return B;
                }
              }(C, 2) || _unsupportedIterableToArray(C, 2) || function () {
                throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }();
              var L = R[0];
              var B = R[1];
              if (_[L]) {
                m[_[L]] = B;
              } else {
                m[L] = B;
              }
              return m;
            }, {});
          }
        });
        _defineProperty(this, "initialize", function (_, C = {}) {
          if (!_) {
            throw Error("Require GA_MEASUREMENT_ID");
          }
          var R = typeof _ == "string" ? [{
            trackingId: _
          }] : _;
          m._currentMeasurementId = R[0].trackingId;
          var L = C.gaOptions;
          var B = C.gtagOptions;
          var F = C.legacyDimensionMetric;
          var U = F === undefined || F;
          var H = C.nonce;
          var q = C.testMode;
          var V = q !== undefined && q;
          m._testMode = V;
          if (!V) {
            m._loadGA(m._currentMeasurementId, H);
          }
          if (!m.isInitialized) {
            m._gtag("js", new Date());
            R.forEach(function (_) {
              var C = m._appendCustomMap(_objectSpread(_objectSpread(_objectSpread({
                send_page_view: false
              }, m._toGtagOptions(_objectSpread(_objectSpread({}, L), _.gaOptions))), B), _.gtagOptions), U);
              m._gtag("config", _.trackingId, C);
            });
          }
          m.isInitialized = true;
          if (!V) {
            var X = _toConsumableArray(m._queueGtag);
            m._queueGtag = [];
            m._isQueuing = false;
            while (X.length) {
              var K = X.shift();
              m._gtag.apply(m, _toConsumableArray(K));
              if (K[0] === "get") {
                m._isQueuing = true;
              }
            }
          }
        });
        _defineProperty(this, "set", function (_) {
          if (!_) {
            console.warn("`fieldsObject` is required in .set()");
            return;
          }
          if (_typeof(_) !== "object") {
            console.warn("Expected `fieldsObject` arg to be an Object");
            return;
          }
          if (Object.keys(_).length === 0) {
            console.warn("empty `fieldsObject` given to .set()");
          }
          m._gaCommand("set", _);
        });
        _defineProperty(this, "_gaCommandSendEvent", function (_, C, R, L, B) {
          m._gtag("event", C, _objectSpread(_objectSpread({
            event_category: _,
            event_label: R,
            value: L
          }, B && {
            non_interaction: B.nonInteraction
          }), m._toGtagOptions(B)));
        });
        _defineProperty(this, "_gaCommandSendEventParameters", function () {
          for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
            C[R] = arguments[R];
          }
          if (typeof C[0] == "string") {
            m._gaCommandSendEvent.apply(m, _toConsumableArray(C.slice(1)));
          } else {
            var L = C[0];
            var F = L.eventCategory;
            var U = L.eventAction;
            var H = L.eventLabel;
            var q = L.eventValue;
            L.hitType;
            var V = _objectWithoutProperties(L, B);
            m._gaCommandSendEvent(F, U, H, q, V);
          }
        });
        _defineProperty(this, "_gaCommandSendTiming", function (_, C, R, L) {
          m._gtag("event", "timing_complete", {
            name: C,
            value: R,
            event_category: _,
            event_label: L
          });
        });
        _defineProperty(this, "_gaCommandSendPageview", function (_, C) {
          if (C && Object.keys(C).length) {
            var R = m._toGtagOptions(C);
            var L = R.title;
            var B = R.location;
            var U = _objectWithoutProperties(R, F);
            m._gtag("event", "page_view", _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _ && {
              page_path: _
            }), L && {
              page_title: L
            }), B && {
              page_location: B
            }), U));
          } else if (_) {
            m._gtag("event", "page_view", {
              page_path: _
            });
          } else {
            m._gtag("event", "page_view");
          }
        });
        _defineProperty(this, "_gaCommandSendPageviewParameters", function () {
          for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
            C[R] = arguments[R];
          }
          if (typeof C[0] == "string") {
            m._gaCommandSendPageview.apply(m, _toConsumableArray(C.slice(1)));
          } else {
            var L = C[0];
            var B = L.page;
            L.hitType;
            var F = _objectWithoutProperties(L, U);
            m._gaCommandSendPageview(B, F);
          }
        });
        _defineProperty(this, "_gaCommandSend", function () {
          for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
            C[R] = arguments[R];
          }
          var L = typeof C[0] == "string" ? C[0] : C[0].hitType;
          switch (L) {
            case "event":
              m._gaCommandSendEventParameters.apply(m, C);
              break;
            case "pageview":
              m._gaCommandSendPageviewParameters.apply(m, C);
              break;
            case "timing":
              m._gaCommandSendTiming.apply(m, _toConsumableArray(C.slice(1)));
              break;
            case "screenview":
            case "transaction":
            case "item":
            case "social":
            case "exception":
              console.warn(`Unsupported send command: ${L}`);
              break;
            default:
              console.warn(`Send command doesn't exist: ${L}`);
          }
        });
        _defineProperty(this, "_gaCommandSet", function () {
          for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
            C[R] = arguments[R];
          }
          if (typeof C[0] == "string") {
            C[0] = _defineProperty({}, C[0], C[1]);
          }
          m._gtag("set", m._toGtagOptions(C[0]));
        });
        _defineProperty(this, "_gaCommand", function (_) {
          for (var C = arguments.length, R = Array(C > 1 ? C - 1 : 0), L = 1; L < C; L++) {
            R[L - 1] = arguments[L];
          }
          switch (_) {
            case "send":
              m._gaCommandSend.apply(m, R);
              break;
            case "set":
              m._gaCommandSet.apply(m, R);
              break;
            default:
              console.warn(`Command doesn't exist: ${_}`);
          }
        });
        _defineProperty(this, "ga", function () {
          for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
            C[R] = arguments[R];
          }
          if (typeof C[0] == "string") {
            m._gaCommand.apply(m, C);
          } else {
            var L = C[0];
            m._gtag("get", m._currentMeasurementId, "client_id", function (_) {
              m._isQueuing = false;
              var C = m._queueGtag;
              for (L({
                get: function (C) {
                  if (C === "clientId") {
                    return _;
                  } else if (C === "trackingId") {
                    return m._currentMeasurementId;
                  } else if (C === "apiVersion") {
                    return "1";
                  } else {
                    return undefined;
                  }
                }
              }); C.length;) {
                var R = C.shift();
                m._gtag.apply(m, _toConsumableArray(R));
              }
            });
            m._isQueuing = true;
          }
          return m.ga;
        });
        _defineProperty(this, "event", function (_, C) {
          if (typeof _ == "string") {
            m._gtag("event", _, m._toGtagOptions(C));
          } else {
            var R = _.action;
            var B = _.category;
            var F = _.label;
            var U = _.value;
            var q = _.nonInteraction;
            var V = _.transport;
            var X = _objectWithoutProperties(_, H);
            if (!B || !R) {
              console.warn("args.category AND args.action are required in event()");
              return;
            }
            var K = {
              hitType: "event",
              eventCategory: (0, L.default)(B),
              eventAction: (0, L.default)(R)
            };
            if (F) {
              K.eventLabel = (0, L.default)(F);
            }
            if (U !== undefined) {
              if (typeof U != "number") {
                console.warn("Expected `args.value` arg to be a Number.");
              } else {
                K.eventValue = U;
              }
            }
            if (q !== undefined) {
              if (typeof q != "boolean") {
                console.warn("`args.nonInteraction` must be a boolean.");
              } else {
                K.nonInteraction = q;
              }
            }
            if (V !== undefined) {
              if (typeof V != "string") {
                console.warn("`args.transport` must be a string.");
              } else {
                if (["beacon", "xhr", "image"].indexOf(V) === -1) {
                  console.warn("`args.transport` must be either one of these values: `beacon`, `xhr` or `image`");
                }
                K.transport = V;
              }
            }
            Object.keys(X).filter(function (m) {
              return m.substr(0, 9) === "dimension";
            }).forEach(function (m) {
              K[m] = X[m];
            });
            Object.keys(X).filter(function (m) {
              return m.substr(0, 6) === "metric";
            }).forEach(function (m) {
              K[m] = X[m];
            });
            m._gaCommand("send", K);
          }
        });
        _defineProperty(this, "send", function (_) {
          m._gaCommand("send", _);
        });
        _defineProperty(this, "pageview", function (_, C, R) {
          var L = _ == null ? undefined : _.trim();
          if (L === "") {
            console.warn("path cannot be an empty string in .pageview()");
            return;
          }
          m._gaCommand("send", "pageview", L, {
            title: R
          });
        });
        this.reset();
      }
      m = [{
        key: "gtag",
        value: function () {
          this._gtag.apply(this, arguments);
        }
      }, {
        key: "_appendCustomMap",
        value: function (m) {
          var _ = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
          if (!_) {
            return m;
          }
          m.custom_map ||= {};
          for (var C = 1; C <= 200; C++) {
            if (!m.custom_map[`dimension${C}`]) {
              m.custom_map[`dimension${C}`] = `dimension${C}`;
            }
            if (!m.custom_map[`metric${C}`]) {
              m.custom_map[`metric${C}`] = `metric${C}`;
            }
          }
          return m;
        }
      }, {
        key: "outboundLink",
        value: function (m, _) {
          var C = m.label;
          if (typeof _ != "function") {
            console.warn("hitCallback function is required");
            return;
          }
          if (!C) {
            console.warn("args.label is required in outboundLink()");
            return;
          }
          var R = {
            hitType: "event",
            eventCategory: "Outbound",
            eventAction: "Click",
            eventLabel: (0, L.default)(C)
          };
          var B = false;
          var F = setTimeout(function () {
            B = true;
            _();
          }, 250);
          R.hitCallback = function () {
            clearTimeout(F);
            if (!B) {
              _();
            }
          };
          this._gaCommand("send", R);
        }
      }];
      _defineProperties(GA4.prototype, m);
      if (_) {
        _defineProperties(GA4, _);
      }
      return GA4;
    }();
    _.GA4 = q;
    var V = new q();
    _.default = V;
  },
  76161: function (m, _) {
    "use strict";

    Object.defineProperty(_, "__esModule", {
      value: true
    });
    _.default = undefined;
    _.default = function () {
      var m;
      for (var _ = arguments.length, C = Array(_), R = 0; R < _; R++) {
        C[R] = arguments[R];
      }
      if (typeof window != "undefined") {
        if (window.gtag === undefined) {
          window.dataLayer = window.dataLayer || [];
          window.gtag = function () {
            window.dataLayer.push(arguments);
          };
        }
        (m = window).gtag.apply(m, C);
      }
    };
  },
  49089: function (m, _, C) {
    "use strict";

    function _typeof(m) {
      return (_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (m) {
        return typeof m;
      } : function (m) {
        if (m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof m;
        }
      })(m);
    }
    _.ZP = undefined;
    var R = function (m, _) {
      if (!_ && m && m.__esModule) {
        return m;
      }
      if (m === null || _typeof(m) !== "object" && typeof m != "function") {
        return {
          default: m
        };
      }
      var C = _getRequireWildcardCache(_);
      if (C && C.has(m)) {
        return C.get(m);
      }
      var R = {};
      var L = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var B in m) {
        if (B !== "default" && Object.prototype.hasOwnProperty.call(m, B)) {
          var F = L ? Object.getOwnPropertyDescriptor(m, B) : null;
          if (F && (F.get || F.set)) {
            Object.defineProperty(R, B, F);
          } else {
            R[B] = m[B];
          }
        }
      }
      R.default = m;
      if (C) {
        C.set(m, R);
      }
      return R;
    }(C(41638));
    function _getRequireWildcardCache(m) {
      if (typeof WeakMap != "function") {
        return null;
      }
      var _ = new WeakMap();
      var C = new WeakMap();
      return (_getRequireWildcardCache = function (m) {
        if (m) {
          return C;
        } else {
          return _;
        }
      })(m);
    }
    R.GA4;
    var L = R.default;
    _.ZP = L;
  },
  25074: function (m, _) {
    "use strict";

    let C = [];
    let R = false;
    let L = false;
    let doesOneSignalExist = () => !!window.OneSignal;
    let handleOnLoad = (m, _) => {
      R = true;
      window.OneSignal = window.OneSignal || [];
      window.OneSignal.push(() => {
        window.OneSignal.init(_);
      });
      window.OneSignal.push(() => {
        processQueuedOneSignalFunctions();
        m();
      });
    };
    let handleOnError = m => {
      L = true;
      processQueuedOneSignalFunctions();
      m();
    };
    let processQueuedOneSignalFunctions = () => {
      C.forEach(m => {
        let {
          name: _,
          args: C,
          promiseResolver: R
        } = m;
        if (R) {
          B[_](...C).then(m => {
            R(m);
          });
        } else {
          B[_](...C);
        }
      });
    };
    let B = {
      init: m => new Promise(_ => {
        if (R) {
          _();
          return;
        }
        if (!m || !m.appId) {
          throw Error("You need to provide your OneSignal appId.");
        }
        if (!document) {
          _();
          return;
        }
        let C = document.createElement("script");
        C.id = "onesignal-sdk";
        C.src = "https://cdn.onesignal.com/sdks/OneSignalSDK.js";
        C.async = true;
        C.onload = () => {
          handleOnLoad(_, m);
        };
        C.onerror = () => {
          handleOnError(_);
        };
        document.head.appendChild(C);
      }),
      on: function (m, _) {
        if (!doesOneSignalExist()) {
          C.push({
            name: "on",
            args: arguments
          });
          return;
        }
        window.OneSignal.push(() => {
          window.OneSignal.on(m, _);
        });
      },
      off: function (m, _) {
        if (!doesOneSignalExist()) {
          C.push({
            name: "off",
            args: arguments
          });
          return;
        }
        window.OneSignal.push(() => {
          window.OneSignal.off(m, _);
        });
      },
      once: function (m, _) {
        if (!doesOneSignalExist()) {
          C.push({
            name: "once",
            args: arguments
          });
          return;
        }
        window.OneSignal.push(() => {
          window.OneSignal.once(m, _);
        });
      },
      isPushNotificationsEnabled: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "isPushNotificationsEnabled",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.isPushNotificationsEnabled(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showHttpPrompt: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showHttpPrompt",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showHttpPrompt(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      registerForPushNotifications: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "registerForPushNotifications",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.registerForPushNotifications(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      setDefaultNotificationUrl: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setDefaultNotificationUrl",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setDefaultNotificationUrl(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      setDefaultTitle: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setDefaultTitle",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setDefaultTitle(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getTags: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getTags",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getTags(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      sendTag: function (m, _, R) {
        return new Promise((B, F) => {
          if (L) {
            B();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "sendTag",
              args: arguments,
              promiseResolver: B
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.sendTag(m, _, R).then(m => B(m)).catch(m => F(m));
            });
          } catch (m) {
            F(m);
          }
        });
      },
      sendTags: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "sendTags",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.sendTags(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      },
      deleteTag: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "deleteTag",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.deleteTag(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      deleteTags: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "deleteTags",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.deleteTags(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      },
      addListenerForNotificationOpened: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "addListenerForNotificationOpened",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.addListenerForNotificationOpened(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      setSubscription: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setSubscription",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setSubscription(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showHttpPermissionRequest: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showHttpPermissionRequest",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showHttpPermissionRequest(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showNativePrompt: function () {
        return new Promise((m, _) => {
          if (L) {
            m();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showNativePrompt",
              args: arguments,
              promiseResolver: m
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showNativePrompt().then(_ => m(_)).catch(m => _(m));
            });
          } catch (m) {
            _(m);
          }
        });
      },
      showSlidedownPrompt: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showSlidedownPrompt",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showSlidedownPrompt(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showCategorySlidedown: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showCategorySlidedown",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showCategorySlidedown(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showSmsSlidedown: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showSmsSlidedown",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showSmsSlidedown(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showEmailSlidedown: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showEmailSlidedown",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showEmailSlidedown(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      showSmsAndEmailSlidedown: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "showSmsAndEmailSlidedown",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.showSmsAndEmailSlidedown(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getNotificationPermission: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getNotificationPermission",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getNotificationPermission(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getUserId: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getUserId",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getUserId(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getSubscription: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getSubscription",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getSubscription(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      setEmail: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setEmail",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setEmail(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      },
      setSMSNumber: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setSMSNumber",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setSMSNumber(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      },
      logoutEmail: function () {
        return new Promise((m, _) => {
          if (L) {
            m();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "logoutEmail",
              args: arguments,
              promiseResolver: m
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.logoutEmail().then(_ => m(_)).catch(m => _(m));
            });
          } catch (m) {
            _(m);
          }
        });
      },
      logoutSMS: function () {
        return new Promise((m, _) => {
          if (L) {
            m();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "logoutSMS",
              args: arguments,
              promiseResolver: m
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.logoutSMS().then(_ => m(_)).catch(m => _(m));
            });
          } catch (m) {
            _(m);
          }
        });
      },
      setExternalUserId: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "setExternalUserId",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.setExternalUserId(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      },
      removeExternalUserId: function () {
        return new Promise((m, _) => {
          if (L) {
            m();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "removeExternalUserId",
              args: arguments,
              promiseResolver: m
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.removeExternalUserId().then(_ => m(_)).catch(m => _(m));
            });
          } catch (m) {
            _(m);
          }
        });
      },
      getExternalUserId: function () {
        return new Promise((m, _) => {
          if (L) {
            m();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getExternalUserId",
              args: arguments,
              promiseResolver: m
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getExternalUserId().then(_ => m(_)).catch(m => _(m));
            });
          } catch (m) {
            _(m);
          }
        });
      },
      provideUserConsent: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "provideUserConsent",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.provideUserConsent(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getEmailId: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getEmailId",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getEmailId(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      getSMSId: function (m) {
        return new Promise((_, R) => {
          if (L) {
            _();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "getSMSId",
              args: arguments,
              promiseResolver: _
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.getSMSId(m).then(m => _(m)).catch(m => R(m));
            });
          } catch (m) {
            R(m);
          }
        });
      },
      sendOutcome: function (m, _) {
        return new Promise((R, B) => {
          if (L) {
            R();
            return;
          }
          if (!doesOneSignalExist()) {
            C.push({
              name: "sendOutcome",
              args: arguments,
              promiseResolver: R
            });
            return;
          }
          try {
            window.OneSignal.push(() => {
              window.OneSignal.sendOutcome(m, _).then(m => R(m)).catch(m => B(m));
            });
          } catch (m) {
            B(m);
          }
        });
      }
    };
    _.Z = B;
  },
  93967: function (m, _) {
    var C; /*!
           Copyright (c) 2018 Jed Watson.
           Licensed under the MIT License (MIT), see
           http://jedwatson.github.io/classnames
           */
    (function () {
      "use strict";

      var R = {}.hasOwnProperty;
      function classNames() {
        var m = "";
        for (var _ = 0; _ < arguments.length; _++) {
          var C = arguments[_];
          if (C) {
            m = appendClass(m, function (m) {
              if (typeof m == "string" || typeof m == "number") {
                return m;
              }
              if (typeof m != "object") {
                return "";
              }
              if (Array.isArray(m)) {
                return classNames.apply(null, m);
              }
              if (m.toString !== Object.prototype.toString && !m.toString.toString().includes("[native code]")) {
                return m.toString();
              }
              var _ = "";
              for (var C in m) {
                if (R.call(m, C) && m[C]) {
                  _ = appendClass(_, C);
                }
              }
              return _;
            }(C));
          }
        }
        return m;
      }
      function appendClass(m, _) {
        if (_) {
          if (m) {
            return m + " " + _;
          } else {
            return m + _;
          }
        } else {
          return m;
        }
      }
      if (m.exports) {
        classNames.default = classNames;
        m.exports = classNames;
      } else if ((C = function () {
        return classNames;
      }.apply(_, [])) !== undefined) {
        m.exports = C;
      }
    })();
  },
  4942: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z: function () {
        return _defineProperty;
      }
    });
    var R = C(83997);
    function _defineProperty(m, _, C) {
      if ((_ = (0, R.Z)(_)) in m) {
        Object.defineProperty(m, _, {
          value: C,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        m[_] = C;
      }
      return m;
    }
  },
  1413: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z: function () {
        return _objectSpread2;
      }
    });
    var R = C(4942);
    function ownKeys(m, _) {
      var C = Object.keys(m);
      if (Object.getOwnPropertySymbols) {
        var R = Object.getOwnPropertySymbols(m);
        if (_) {
          R = R.filter(function (_) {
            return Object.getOwnPropertyDescriptor(m, _).enumerable;
          });
        }
        C.push.apply(C, R);
      }
      return C;
    }
    function _objectSpread2(m) {
      for (var _ = 1; _ < arguments.length; _++) {
        var C = arguments[_] ?? {};
        if (_ % 2) {
          ownKeys(Object(C), true).forEach(function (_) {
            (0, R.Z)(m, _, C[_]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(m, Object.getOwnPropertyDescriptors(C));
        } else {
          ownKeys(Object(C)).forEach(function (_) {
            Object.defineProperty(m, _, Object.getOwnPropertyDescriptor(C, _));
          });
        }
      }
      return m;
    }
  },
  83997: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z: function () {
        return toPropertyKey;
      }
    });
    var R = C(71002);
    function toPropertyKey(m) {
      var _ = function (m, _) {
        if ((0, R.Z)(m) != "object" || !m) {
          return m;
        }
        var C = m[Symbol.toPrimitive];
        if (C !== undefined) {
          var L = C.call(m, _ || "default");
          if ((0, R.Z)(L) != "object") {
            return L;
          }
          throw TypeError("@@toPrimitive must return a primitive value.");
        }
        return (_ === "string" ? String : Number)(m);
      }(m, "string");
      if ((0, R.Z)(_) == "symbol") {
        return _;
      } else {
        return _ + "";
      }
    }
  },
  71002: function (m, _, C) {
    "use strict";

    function _typeof(m) {
      return (_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (m) {
        return typeof m;
      } : function (m) {
        if (m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof m;
        }
      })(m);
    }
    C.d(_, {
      Z: function () {
        return _typeof;
      }
    });
  },
  60811: function (m, _, C) {
    "use strict";

    C.d(_, {
      G: function () {
        return getAsyncContextStrategy;
      }
    });
    var R = C(13533);
    var L = C(16824);
    var B = C(29531);
    var F = C(43927);
    let AsyncContextStack = class AsyncContextStack {
      constructor(m, _) {
        let C;
        let R;
        C = m || new F.s();
        R = _ || new F.s();
        this._stack = [{
          scope: C
        }];
        this._isolationScope = R;
      }
      withScope(m) {
        let _;
        let C = this._pushScope();
        try {
          _ = m(C);
        } catch (m) {
          this._popScope();
          throw m;
        }
        if ((0, L.J8)(_)) {
          return _.then(m => {
            this._popScope();
            return m;
          }, m => {
            this._popScope();
            throw m;
          });
        } else {
          this._popScope();
          return _;
        }
      }
      getClient() {
        return this.getStackTop().client;
      }
      getScope() {
        return this.getStackTop().scope;
      }
      getIsolationScope() {
        return this._isolationScope;
      }
      getStackTop() {
        return this._stack[this._stack.length - 1];
      }
      _pushScope() {
        let m = this.getScope().clone();
        this._stack.push({
          client: this.getClient(),
          scope: m
        });
        return m;
      }
      _popScope() {
        return !(this._stack.length <= 1) && !!this._stack.pop();
      }
    };
    function getAsyncContextStack() {
      let m = (0, R.c)();
      let _ = (0, R.q)(m);
      return _.stack = _.stack || new AsyncContextStack((0, B.Y)("defaultCurrentScope", () => new F.s()), (0, B.Y)("defaultIsolationScope", () => new F.s()));
    }
    function withScope(m) {
      return getAsyncContextStack().withScope(m);
    }
    function withSetScope(m, _) {
      let C = getAsyncContextStack();
      return C.withScope(() => {
        C.getStackTop().scope = m;
        return _(m);
      });
    }
    function withIsolationScope(m) {
      return getAsyncContextStack().withScope(() => m(getAsyncContextStack().getIsolationScope()));
    }
    function getAsyncContextStrategy(m) {
      let _ = (0, R.q)(m);
      if (_.acs) {
        return _.acs;
      } else {
        return {
          withIsolationScope,
          withScope,
          withSetScope,
          withSetIsolationScope: (m, _) => withIsolationScope(_),
          getCurrentScope: () => getAsyncContextStack().getScope(),
          getIsolationScope: () => getAsyncContextStack().getIsolationScope()
        };
      }
    }
  },
  13533: function (m, _, C) {
    "use strict";

    C.d(_, {
      c: function () {
        return getMainCarrier;
      },
      q: function () {
        return getSentryCarrier;
      }
    });
    var R = C(29531);
    var L = C(42990);
    function getMainCarrier() {
      getSentryCarrier(R.GLOBAL_OBJ);
      return R.GLOBAL_OBJ;
    }
    function getSentryCarrier(m) {
      let _ = m.__SENTRY__ = m.__SENTRY__ || {};
      _.version = _.version || L.J;
      return _[L.J] = _[L.J] || {};
    }
  },
  73243: function (m, _, C) {
    "use strict";

    C.d(_, {
      J: function () {
        return R;
      }
    });
    let R = "production";
  },
  73076: function (m, _, C) {
    "use strict";

    C.d(_, {
      $e: function () {
        return withScope;
      },
      aF: function () {
        return getIsolationScope;
      },
      lW: function () {
        return getGlobalScope;
      },
      nZ: function () {
        return getCurrentScope;
      },
      s3: function () {
        return getClient;
      }
    });
    var R = C(29531);
    var L = C(60811);
    var B = C(13533);
    var F = C(43927);
    function getCurrentScope() {
      let m = (0, B.c)();
      let _ = (0, L.G)(m);
      return _.getCurrentScope();
    }
    function getIsolationScope() {
      let m = (0, B.c)();
      let _ = (0, L.G)(m);
      return _.getIsolationScope();
    }
    function getGlobalScope() {
      return (0, R.Y)("globalScope", () => new F.s());
    }
    function withScope(...m) {
      let _ = (0, B.c)();
      let C = (0, L.G)(_);
      if (m.length === 2) {
        let [_, R] = m;
        if (_) {
          return C.withSetScope(_, R);
        } else {
          return C.withScope(R);
        }
      }
      return C.withScope(m[0]);
    }
    function getClient() {
      return getCurrentScope().getClient();
    }
  },
  94223: function (m, _, C) {
    "use strict";

    C.d(_, {
      X: function () {
        return R;
      }
    });
    let R = false;
  },
  11793: function (m, _, C) {
    "use strict";

    C.d(_, {
      Mq: function () {
        return createEventEnvelope;
      },
      Q3: function () {
        return createSessionEnvelope;
      },
      uE: function () {
        return createSpanEnvelope;
      }
    });
    var R = C(39432);
    var L = C(73326);
    var B = C(72123);
    var F = C(81585);
    function createSessionEnvelope(m, _, C, B) {
      let F = (0, R.HY)(C);
      let U = {
        sent_at: new Date().toISOString(),
        ...(F && {
          sdk: F
        }),
        ...(!!B && _ && {
          dsn: (0, L.RA)(_)
        })
      };
      let H = "aggregates" in m ? [{
        type: "sessions"
      }, m] : [{
        type: "session"
      }, m.toJSON()];
      return (0, R.Jd)(U, [H]);
    }
    function createEventEnvelope(m, _, C, L) {
      var B;
      let F = (0, R.HY)(C);
      let U = m.type && m.type !== "replay_event" ? m.type : "event";
      if (B = C && C.sdk) {
        m.sdk = m.sdk || {};
        m.sdk.name = m.sdk.name || B.name;
        m.sdk.version = m.sdk.version || B.version;
        m.sdk.integrations = [...(m.sdk.integrations || []), ...(B.integrations || [])];
        m.sdk.packages = [...(m.sdk.packages || []), ...(B.packages || [])];
      }
      let H = (0, R.Cd)(m, F, L, _);
      delete m.sdkProcessingMetadata;
      let q = [{
        type: U
      }, m];
      return (0, R.Jd)(H, [q]);
    }
    function createSpanEnvelope(m, _) {
      let C = (0, B.jC)(m[0]);
      let U = _ && _.getDsn();
      let H = _ && _.getOptions().tunnel;
      let q = {
        sent_at: new Date().toISOString(),
        ...(!!C.trace_id && !!C.public_key && {
          trace: C
        }),
        ...(!!H && U && {
          dsn: (0, L.RA)(U)
        })
      };
      let V = _ && _.getOptions().beforeSendSpan;
      let X = V ? m => V((0, F.XU)(m)) : m => (0, F.XU)(m);
      let K = [];
      for (let _ of m) {
        let m = X(_);
        if (m) {
          K.push((0, R.KQ)(m));
        }
      }
      return (0, R.Jd)(q, K);
    }
  },
  39424: function (m, _, C) {
    "use strict";

    C.d(_, {
      Qy: function () {
        return addEventProcessor;
      },
      Tb: function () {
        return captureException;
      },
      av: function () {
        return setUser;
      },
      cg: function () {
        return captureSession;
      },
      eN: function () {
        return captureEvent;
      },
      v: function () {
        return setContext;
      },
      yj: function () {
        return startSession;
      },
      yl: function () {
        return flush;
      }
    });
    var R = C(41001);
    var L = C(29531);
    var B = C(73243);
    var F = C(73076);
    var U = C(94223);
    var H = C(10042);
    var q = C(5808);
    function captureException(m, _) {
      return (0, F.nZ)().captureException(m, (0, q.U0)(_));
    }
    function captureEvent(m, _) {
      return (0, F.nZ)().captureEvent(m, _);
    }
    function setContext(m, _) {
      (0, F.aF)().setContext(m, _);
    }
    function setUser(m) {
      (0, F.aF)().setUser(m);
    }
    async function flush(m) {
      let _ = (0, F.s3)();
      if (_) {
        return _.flush(m);
      } else {
        if (U.X) {
          R.kg.warn("Cannot flush events. No client defined.");
        }
        return Promise.resolve(false);
      }
    }
    function addEventProcessor(m) {
      (0, F.aF)().addEventProcessor(m);
    }
    function startSession(m) {
      let _ = (0, F.s3)();
      let C = (0, F.aF)();
      let R = (0, F.nZ)();
      let {
        release: U,
        environment: q = B.J
      } = _ && _.getOptions() || {};
      let {
        userAgent: V
      } = L.GLOBAL_OBJ.navigator || {};
      let X = (0, H.Hv)({
        release: U,
        environment: q,
        user: R.getUser() || C.getUser(),
        ...(V && {
          userAgent: V
        }),
        ...m
      });
      let K = C.getSession();
      if (K && K.status === "ok") {
        (0, H.CT)(K, {
          status: "exited"
        });
      }
      endSession();
      C.setSession(X);
      R.setSession(X);
      return X;
    }
    function endSession() {
      let m = (0, F.aF)();
      let _ = (0, F.nZ)();
      let C = _.getSession() || m.getSession();
      if (C) {
        (0, H.RJ)(C);
      }
      _sendSessionUpdate();
      m.setSession();
      _.setSession();
    }
    function _sendSessionUpdate() {
      let m = (0, F.aF)();
      let _ = (0, F.nZ)();
      let C = (0, F.s3)();
      let R = _.getSession() || m.getSession();
      if (R && C) {
        C.captureSession(R);
      }
    }
    function captureSession(m = false) {
      if (m) {
        endSession();
        return;
      }
      _sendSessionUpdate();
    }
  },
  72751: function (m, _, C) {
    "use strict";

    C.d(_, {
      y: function () {
        return getMetricSummaryJsonForSpan;
      }
    });
    var R = C(27179);
    function getMetricSummaryJsonForSpan(m) {
      let _ = m._sentryMetrics;
      if (!_) {
        return;
      }
      let C = {};
      for (let [, [m, L]] of _) {
        let _ = C[m] ||= [];
        _.push((0, R.Jr)(L));
      }
      return C;
    }
  },
  43927: function (m, _, C) {
    "use strict";

    C.d(_, {
      s: function () {
        return V;
      }
    });
    var R = C(19548);
    var L = C(16824);
    var B = C(26181);
    var F = C(41982);
    var U = C(41001);
    var H = C(10042);
    var q = C(89366);
    let ScopeClass = class ScopeClass {
      constructor() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._attachments = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
        this._propagationContext = (0, R.Q)();
      }
      clone() {
        let m = new ScopeClass();
        m._breadcrumbs = [...this._breadcrumbs];
        m._tags = {
          ...this._tags
        };
        m._extra = {
          ...this._extra
        };
        m._contexts = {
          ...this._contexts
        };
        m._user = this._user;
        m._level = this._level;
        m._session = this._session;
        m._transactionName = this._transactionName;
        m._fingerprint = this._fingerprint;
        m._eventProcessors = [...this._eventProcessors];
        m._requestSession = this._requestSession;
        m._attachments = [...this._attachments];
        m._sdkProcessingMetadata = {
          ...this._sdkProcessingMetadata
        };
        m._propagationContext = {
          ...this._propagationContext
        };
        m._client = this._client;
        m._lastEventId = this._lastEventId;
        (0, q.D)(m, (0, q.Y)(this));
        return m;
      }
      setClient(m) {
        this._client = m;
      }
      setLastEventId(m) {
        this._lastEventId = m;
      }
      getClient() {
        return this._client;
      }
      lastEventId() {
        return this._lastEventId;
      }
      addScopeListener(m) {
        this._scopeListeners.push(m);
      }
      addEventProcessor(m) {
        this._eventProcessors.push(m);
        return this;
      }
      setUser(m) {
        this._user = m || {
          email: undefined,
          id: undefined,
          ip_address: undefined,
          username: undefined
        };
        if (this._session) {
          (0, H.CT)(this._session, {
            user: m
          });
        }
        this._notifyScopeListeners();
        return this;
      }
      getUser() {
        return this._user;
      }
      getRequestSession() {
        return this._requestSession;
      }
      setRequestSession(m) {
        this._requestSession = m;
        return this;
      }
      setTags(m) {
        this._tags = {
          ...this._tags,
          ...m
        };
        this._notifyScopeListeners();
        return this;
      }
      setTag(m, _) {
        this._tags = {
          ...this._tags,
          [m]: _
        };
        this._notifyScopeListeners();
        return this;
      }
      setExtras(m) {
        this._extra = {
          ...this._extra,
          ...m
        };
        this._notifyScopeListeners();
        return this;
      }
      setExtra(m, _) {
        this._extra = {
          ...this._extra,
          [m]: _
        };
        this._notifyScopeListeners();
        return this;
      }
      setFingerprint(m) {
        this._fingerprint = m;
        this._notifyScopeListeners();
        return this;
      }
      setLevel(m) {
        this._level = m;
        this._notifyScopeListeners();
        return this;
      }
      setTransactionName(m) {
        this._transactionName = m;
        this._notifyScopeListeners();
        return this;
      }
      setContext(m, _) {
        if (_ === null) {
          delete this._contexts[m];
        } else {
          this._contexts[m] = _;
        }
        this._notifyScopeListeners();
        return this;
      }
      setSession(m) {
        if (m) {
          this._session = m;
        } else {
          delete this._session;
        }
        this._notifyScopeListeners();
        return this;
      }
      getSession() {
        return this._session;
      }
      update(m) {
        if (!m) {
          return this;
        }
        let _ = typeof m == "function" ? m(this) : m;
        let [C, R] = _ instanceof V ? [_.getScopeData(), _.getRequestSession()] : (0, L.PO)(_) ? [m, m.requestSession] : [];
        let {
          tags: B,
          extra: F,
          user: U,
          contexts: H,
          level: q,
          fingerprint: X = [],
          propagationContext: K
        } = C || {};
        this._tags = {
          ...this._tags,
          ...B
        };
        this._extra = {
          ...this._extra,
          ...F
        };
        this._contexts = {
          ...this._contexts,
          ...H
        };
        if (U && Object.keys(U).length) {
          this._user = U;
        }
        if (q) {
          this._level = q;
        }
        if (X.length) {
          this._fingerprint = X;
        }
        if (K) {
          this._propagationContext = K;
        }
        if (R) {
          this._requestSession = R;
        }
        return this;
      }
      clear() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._session = undefined;
        (0, q.D)(this, undefined);
        this._attachments = [];
        this._propagationContext = (0, R.Q)();
        this._notifyScopeListeners();
        return this;
      }
      addBreadcrumb(m, _) {
        let C = typeof _ == "number" ? _ : 100;
        if (C <= 0) {
          return this;
        }
        let R = {
          timestamp: (0, B.yW)(),
          ...m
        };
        let L = this._breadcrumbs;
        L.push(R);
        this._breadcrumbs = L.length > C ? L.slice(-C) : L;
        this._notifyScopeListeners();
        return this;
      }
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }
      clearBreadcrumbs() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      }
      addAttachment(m) {
        this._attachments.push(m);
        return this;
      }
      clearAttachments() {
        this._attachments = [];
        return this;
      }
      getScopeData() {
        return {
          breadcrumbs: this._breadcrumbs,
          attachments: this._attachments,
          contexts: this._contexts,
          tags: this._tags,
          extra: this._extra,
          user: this._user,
          level: this._level,
          fingerprint: this._fingerprint || [],
          eventProcessors: this._eventProcessors,
          propagationContext: this._propagationContext,
          sdkProcessingMetadata: this._sdkProcessingMetadata,
          transactionName: this._transactionName,
          span: (0, q.Y)(this)
        };
      }
      setSDKProcessingMetadata(m) {
        this._sdkProcessingMetadata = {
          ...this._sdkProcessingMetadata,
          ...m
        };
        return this;
      }
      setPropagationContext(m) {
        this._propagationContext = m;
        return this;
      }
      getPropagationContext() {
        return this._propagationContext;
      }
      captureException(m, _) {
        let C = _ && _.event_id ? _.event_id : (0, F.DM)();
        if (!this._client) {
          U.kg.warn("No client configured on scope - will not capture exception!");
          return C;
        }
        let R = Error("Sentry syntheticException");
        this._client.captureException(m, {
          originalException: m,
          syntheticException: R,
          ..._,
          event_id: C
        }, this);
        return C;
      }
      captureMessage(m, _, C) {
        let R = C && C.event_id ? C.event_id : (0, F.DM)();
        if (!this._client) {
          U.kg.warn("No client configured on scope - will not capture message!");
          return R;
        }
        let L = Error(m);
        this._client.captureMessage(m, _, {
          originalException: m,
          syntheticException: L,
          ...C,
          event_id: R
        }, this);
        return R;
      }
      captureEvent(m, _) {
        let C = _ && _.event_id ? _.event_id : (0, F.DM)();
        if (this._client) {
          this._client.captureEvent(m, {
            ..._,
            event_id: C
          }, this);
        } else {
          U.kg.warn("No client configured on scope - will not capture event!");
        }
        return C;
      }
      _notifyScopeListeners() {
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(m => {
            m(this);
          });
          this._notifyingListeners = false;
        }
      }
    };
    let V = ScopeClass;
  },
  31218: function (m, _, C) {
    "use strict";

    C.d(_, {
      $J: function () {
        return B;
      },
      E1: function () {
        return H;
      },
      JQ: function () {
        return X;
      },
      S3: function () {
        return F;
      },
      TE: function () {
        return L;
      },
      Wb: function () {
        return q;
      },
      Zj: function () {
        return R;
      },
      ju: function () {
        return U;
      },
      p6: function () {
        return V;
      }
    });
    let R = "sentry.source";
    let L = "sentry.sample_rate";
    let B = "sentry.op";
    let F = "sentry.origin";
    let U = "sentry.idle_span_finish_reason";
    let H = "sentry.measurement_unit";
    let q = "sentry.measurement_value";
    let V = "sentry.profile_id";
    let X = "sentry.exclusive_time";
  },
  10042: function (m, _, C) {
    "use strict";

    C.d(_, {
      CT: function () {
        return updateSession;
      },
      Hv: function () {
        return makeSession;
      },
      RJ: function () {
        return closeSession;
      }
    });
    var R = C(26181);
    var L = C(41982);
    var B = C(27179);
    function makeSession(m) {
      let _ = (0, R.ph)();
      let C = {
        sid: (0, L.DM)(),
        init: true,
        timestamp: _,
        started: _,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: false,
        toJSON: () => (0, B.Jr)({
          sid: `${C.sid}`,
          init: C.init,
          started: new Date(C.started * 1000).toISOString(),
          timestamp: new Date(C.timestamp * 1000).toISOString(),
          status: C.status,
          errors: C.errors,
          did: typeof C.did == "number" || typeof C.did == "string" ? `${C.did}` : undefined,
          duration: C.duration,
          abnormal_mechanism: C.abnormal_mechanism,
          attrs: {
            release: C.release,
            environment: C.environment,
            ip_address: C.ipAddress,
            user_agent: C.userAgent
          }
        })
      };
      if (m) {
        updateSession(C, m);
      }
      return C;
    }
    function updateSession(m, _ = {}) {
      if (_.user) {
        if (!m.ipAddress && _.user.ip_address) {
          m.ipAddress = _.user.ip_address;
        }
        if (!m.did && !_.did) {
          m.did = _.user.id || _.user.email || _.user.username;
        }
      }
      m.timestamp = _.timestamp || (0, R.ph)();
      if (_.abnormal_mechanism) {
        m.abnormal_mechanism = _.abnormal_mechanism;
      }
      if (_.ignoreDuration) {
        m.ignoreDuration = _.ignoreDuration;
      }
      if (_.sid) {
        m.sid = _.sid.length === 32 ? _.sid : (0, L.DM)();
      }
      if (_.init !== undefined) {
        m.init = _.init;
      }
      if (!m.did && _.did) {
        m.did = `${_.did}`;
      }
      if (typeof _.started == "number") {
        m.started = _.started;
      }
      if (m.ignoreDuration) {
        m.duration = undefined;
      } else if (typeof _.duration == "number") {
        m.duration = _.duration;
      } else {
        let _ = m.timestamp - m.started;
        m.duration = _ >= 0 ? _ : 0;
      }
      if (_.release) {
        m.release = _.release;
      }
      if (_.environment) {
        m.environment = _.environment;
      }
      if (!m.ipAddress && _.ipAddress) {
        m.ipAddress = _.ipAddress;
      }
      if (!m.userAgent && _.userAgent) {
        m.userAgent = _.userAgent;
      }
      if (typeof _.errors == "number") {
        m.errors = _.errors;
      }
      if (_.status) {
        m.status = _.status;
      }
    }
    function closeSession(m, _) {
      let C = {};
      if (_) {
        C = {
          status: _
        };
      } else if (m.status === "ok") {
        C = {
          status: "exited"
        };
      }
      updateSession(m, C);
    }
  },
  72123: function (m, _, C) {
    "use strict";

    C.d(_, {
      Lh: function () {
        return freezeDscOnSpan;
      },
      _l: function () {
        return getDynamicSamplingContextFromClient;
      },
      jC: function () {
        return getDynamicSamplingContextFromSpan;
      }
    });
    var R = C(27179);
    var L = C(60859);
    var B = C(73243);
    var F = C(73076);
    var U = C(31218);
    var H = C(67973);
    var q = C(81585);
    let V = "_frozenDsc";
    function freezeDscOnSpan(m, _) {
      (0, R.xp)(m, V, _);
    }
    function getDynamicSamplingContextFromClient(m, _) {
      let C = _.getOptions();
      let {
        publicKey: L
      } = _.getDsn() || {};
      let F = (0, R.Jr)({
        environment: C.environment || B.J,
        release: C.release,
        public_key: L,
        trace_id: m
      });
      _.emit("createDsc", F);
      return F;
    }
    function getDynamicSamplingContextFromSpan(m) {
      let _ = (0, F.s3)();
      if (!_) {
        return {};
      }
      let C = getDynamicSamplingContextFromClient((0, q.XU)(m).trace_id || "", _);
      let R = (0, q.Gx)(m);
      let B = R[V];
      if (B) {
        return B;
      }
      let X = R.spanContext().traceState;
      let K = X && X.get("sentry.dsc");
      let Y = K && (0, L.EN)(K);
      if (Y) {
        return Y;
      }
      let Q = (0, q.XU)(R);
      let et = Q.data || {};
      let er = et[U.TE];
      if (er != null) {
        C.sample_rate = `${er}`;
      }
      let en = et[U.Zj];
      let ei = Q.description;
      if (en !== "url" && ei) {
        C.transaction = ei;
      }
      if ((0, H.z)()) {
        C.sampled = String((0, q.Tt)(R));
      }
      _.emit("createDsc", C, R);
      return C;
    }
  },
  72441: function (m, _, C) {
    "use strict";

    C.d(_, {
      l: function () {
        return timedEventsToMeasurements;
      },
      o: function () {
        return setMeasurement;
      }
    });
    var R = C(31218);
    var L = C(81585);
    function setMeasurement(m, _, C, B = (0, L.HN)()) {
      let F = B && (0, L.Gx)(B);
      if (F) {
        F.addEvent(m, {
          [R.Wb]: _,
          [R.E1]: C
        });
      }
    }
    function timedEventsToMeasurements(m) {
      if (!m || m.length === 0) {
        return;
      }
      let _ = {};
      m.forEach(m => {
        let C = m.attributes || {};
        let L = C[R.E1];
        let B = C[R.Wb];
        if (typeof L == "string" && typeof B == "number") {
          _[m.name] = {
            value: B,
            unit: L
          };
        }
      });
      return _;
    }
  },
  58915: function (m, _, C) {
    "use strict";

    C.d(_, {
      b: function () {
        return SentryNonRecordingSpan;
      }
    });
    var R = C(41982);
    var L = C(81585);
    let SentryNonRecordingSpan = class SentryNonRecordingSpan {
      constructor(m = {}) {
        this._traceId = m.traceId || (0, R.DM)();
        this._spanId = m.spanId || (0, R.DM)().substring(16);
      }
      spanContext() {
        return {
          spanId: this._spanId,
          traceId: this._traceId,
          traceFlags: L.ve
        };
      }
      end(m) {}
      setAttribute(m, _) {
        return this;
      }
      setAttributes(m) {
        return this;
      }
      setStatus(m) {
        return this;
      }
      updateName(m) {
        return this;
      }
      isRecording() {
        return false;
      }
      addEvent(m, _, C) {
        return this;
      }
      addLink(m) {
        return this;
      }
      addLinks(m) {
        return this;
      }
      recordException(m, _) {}
    };
  },
  69737: function (m, _, C) {
    "use strict";

    C.d(_, {
      OP: function () {
        return L;
      },
      Q0: function () {
        return setHttpStatus;
      },
      jt: function () {
        return B;
      },
      pq: function () {
        return R;
      }
    });
    let R = 0;
    let L = 1;
    let B = 2;
    function setHttpStatus(m, _) {
      m.setAttribute("http.response.status_code", _);
      let C = function (m) {
        if (m < 400 && m >= 100) {
          return {
            code: L
          };
        }
        if (m >= 400 && m < 500) {
          switch (m) {
            case 401:
              return {
                code: B,
                message: "unauthenticated"
              };
            case 403:
              return {
                code: B,
                message: "permission_denied"
              };
            case 404:
              return {
                code: B,
                message: "not_found"
              };
            case 409:
              return {
                code: B,
                message: "already_exists"
              };
            case 413:
              return {
                code: B,
                message: "failed_precondition"
              };
            case 429:
              return {
                code: B,
                message: "resource_exhausted"
              };
            case 499:
              return {
                code: B,
                message: "cancelled"
              };
            default:
              return {
                code: B,
                message: "invalid_argument"
              };
          }
        }
        if (m >= 500 && m < 600) {
          switch (m) {
            case 501:
              return {
                code: B,
                message: "unimplemented"
              };
            case 503:
              return {
                code: B,
                message: "unavailable"
              };
            case 504:
              return {
                code: B,
                message: "deadline_exceeded"
              };
            default:
              return {
                code: B,
                message: "internal_error"
              };
          }
        }
        return {
          code: B,
          message: "unknown_error"
        };
      }(_);
      if (C.message !== "unknown_error") {
        m.setStatus(C);
      }
    }
  },
  99450: function (m, _, C) {
    "use strict";

    C.d(_, {
      qp: function () {
        return startInactiveSpan;
      },
      GK: function () {
        return startSpan;
      },
      _d: function () {
        return withActiveSpan;
      }
    });
    var R = C(13533);
    var L = C(73076);
    var B = C(60811);
    var F = C(31218);
    var U = C(16824);
    var H = C(67973);
    var q = C(89366);
    var V = C(81585);
    var X = C(72123);
    var K = C(41001);
    var Y = C(94223);
    var Q = C(79769);
    var et = C(58915);
    var er = C(41982);
    var en = C(26181);
    var ei = C(27179);
    var eo = C(11793);
    var ea = C(72751);
    var es = C(72441);
    let ec = "_sentryScope";
    let el = "_sentryIsolationScope";
    function getCapturedScopesOnSpan(m) {
      return {
        scope: m[ec],
        isolationScope: m[el]
      };
    }
    let SentrySpan = class SentrySpan {
      constructor(m = {}) {
        this._traceId = m.traceId || (0, er.DM)();
        this._spanId = m.spanId || (0, er.DM)().substring(16);
        this._startTime = m.startTimestamp || (0, en.ph)();
        this._attributes = {};
        this.setAttributes({
          [F.S3]: "manual",
          [F.$J]: m.op,
          ...m.attributes
        });
        this._name = m.name;
        if (m.parentSpanId) {
          this._parentSpanId = m.parentSpanId;
        }
        if ("sampled" in m) {
          this._sampled = m.sampled;
        }
        if (m.endTimestamp) {
          this._endTime = m.endTimestamp;
        }
        this._events = [];
        this._isStandaloneSpan = m.isStandalone;
        if (this._endTime) {
          this._onSpanEnded();
        }
      }
      addLink(m) {
        return this;
      }
      addLinks(m) {
        return this;
      }
      recordException(m, _) {}
      spanContext() {
        let {
          _spanId: m,
          _traceId: _,
          _sampled: C
        } = this;
        return {
          spanId: m,
          traceId: _,
          traceFlags: C ? V.i0 : V.ve
        };
      }
      setAttribute(m, _) {
        if (_ === undefined) {
          delete this._attributes[m];
        } else {
          this._attributes[m] = _;
        }
        return this;
      }
      setAttributes(m) {
        Object.keys(m).forEach(_ => this.setAttribute(_, m[_]));
        return this;
      }
      updateStartTime(m) {
        this._startTime = (0, V.$k)(m);
      }
      setStatus(m) {
        this._status = m;
        return this;
      }
      updateName(m) {
        this._name = m;
        return this;
      }
      end(m) {
        if (!this._endTime) {
          this._endTime = (0, V.$k)(m);
          (function (m) {
            if (!Y.X) {
              return;
            }
            let {
              description: _ = "< unknown name >",
              op: C = "< unknown op >"
            } = (0, V.XU)(m);
            let {
              spanId: R
            } = m.spanContext();
            let L = (0, V.Gx)(m);
            let B = L === m;
            let F = `[Tracing] Finishing "${C}" ${B ? "root " : ""}span "${_}" with ID ${R}`;
            K.kg.log(F);
          })(this);
          this._onSpanEnded();
        }
      }
      getSpanJSON() {
        return (0, ei.Jr)({
          data: this._attributes,
          description: this._name,
          op: this._attributes[F.$J],
          parent_span_id: this._parentSpanId,
          span_id: this._spanId,
          start_timestamp: this._startTime,
          status: (0, V._4)(this._status),
          timestamp: this._endTime,
          trace_id: this._traceId,
          origin: this._attributes[F.S3],
          _metrics_summary: (0, ea.y)(this),
          profile_id: this._attributes[F.p6],
          exclusive_time: this._attributes[F.JQ],
          measurements: (0, es.l)(this._events),
          is_segment: this._isStandaloneSpan && (0, V.Gx)(this) === this || undefined,
          segment_id: this._isStandaloneSpan ? (0, V.Gx)(this).spanContext().spanId : undefined
        });
      }
      isRecording() {
        return !this._endTime && !!this._sampled;
      }
      addEvent(m, _, C) {
        if (Y.X) {
          K.kg.log("[Tracing] Adding an event to span:", m);
        }
        let R = isSpanTimeInput(_) ? _ : C || (0, en.ph)();
        let L = isSpanTimeInput(_) ? {} : _ || {};
        let B = {
          name: m,
          time: (0, V.$k)(R),
          attributes: L
        };
        this._events.push(B);
        return this;
      }
      isStandaloneSpan() {
        return !!this._isStandaloneSpan;
      }
      _onSpanEnded() {
        let m = (0, L.s3)();
        if (m) {
          m.emit("spanEnd", this);
        }
        let _ = this._isStandaloneSpan || this === (0, V.Gx)(this);
        if (!_) {
          return;
        }
        if (this._isStandaloneSpan) {
          if (this._sampled) {
            (function (m) {
              let _ = (0, L.s3)();
              if (!_) {
                return;
              }
              let C = m[1];
              if (!C || C.length === 0) {
                _.recordDroppedEvent("before_send", "span");
                return;
              }
              let R = _.getTransport();
              if (R) {
                R.send(m).then(null, m => {
                  if (Y.X) {
                    K.kg.error("Error while sending span:", m);
                  }
                });
              }
            })((0, eo.uE)([this], m));
          } else {
            if (Y.X) {
              K.kg.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
            }
            if (m) {
              m.recordDroppedEvent("sample_rate", "span");
            }
          }
          return;
        }
        let C = this._convertSpanToTransaction();
        if (C) {
          let m = getCapturedScopesOnSpan(this).scope || (0, L.nZ)();
          m.captureEvent(C);
        }
      }
      _convertSpanToTransaction() {
        if (!isFullFinishedSpan((0, V.XU)(this))) {
          return;
        }
        if (!this._name) {
          if (Y.X) {
            K.kg.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
          }
          this._name = "<unlabeled transaction>";
        }
        let {
          scope: m,
          isolationScope: _
        } = getCapturedScopesOnSpan(this);
        let C = m || (0, L.nZ)();
        let R = C.getClient() || (0, L.s3)();
        if (this._sampled !== true) {
          if (Y.X) {
            K.kg.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
          }
          if (R) {
            R.recordDroppedEvent("sample_rate", "transaction");
          }
          return;
        }
        let B = (0, V.Dp)(this).filter(m => m !== this && (!(m instanceof SentrySpan) || !m.isStandaloneSpan()));
        let U = B.map(m => (0, V.XU)(m)).filter(isFullFinishedSpan);
        let H = this._attributes[F.Zj];
        let q = {
          contexts: {
            trace: (0, V.HR)(this)
          },
          spans: U.length > 1000 ? U.sort((m, _) => m.start_timestamp - _.start_timestamp).slice(0, 1000) : U,
          start_timestamp: this._startTime,
          timestamp: this._endTime,
          transaction: this._name,
          type: "transaction",
          sdkProcessingMetadata: {
            capturedSpanScope: m,
            capturedSpanIsolationScope: _,
            ...(0, ei.Jr)({
              dynamicSamplingContext: (0, X.jC)(this)
            })
          },
          _metrics_summary: (0, ea.y)(this),
          ...(H && {
            transaction_info: {
              source: H
            }
          })
        };
        let Q = (0, es.l)(this._events);
        let et = Q && Object.keys(Q).length;
        if (et) {
          if (Y.X) {
            K.kg.log("[Measurements] Adding measurements to transaction event", JSON.stringify(Q, undefined, 2));
          }
          q.measurements = Q;
        }
        return q;
      }
    };
    function isSpanTimeInput(m) {
      return m && typeof m == "number" || m instanceof Date || Array.isArray(m);
    }
    function isFullFinishedSpan(m) {
      return !!m.start_timestamp && !!m.timestamp && !!m.span_id && !!m.trace_id;
    }
    var eu = C(69737);
    let ed = "__SENTRY_SUPPRESS_TRACING__";
    function startSpan(m, _) {
      let C = getAcs();
      if (C.startSpan) {
        return C.startSpan(m, _);
      }
      let R = parseSentrySpanArguments(m);
      let {
        forceTransaction: B,
        parentSpan: F
      } = m;
      return (0, L.$e)(m.scope, () => {
        let C = F !== undefined ? m => withActiveSpan(F, m) : m => m();
        return C(() => {
          let C = (0, L.nZ)();
          let F = getParentSpan(C);
          let H = m.onlyIfParent && !F;
          let X = H ? new et.b() : createChildOrRootSpan({
            parentSpan: F,
            spanArguments: R,
            forceTransaction: B,
            scope: C
          });
          (0, q.D)(C, X);
          return function (m, _, C = () => {}) {
            var R;
            let L;
            try {
              L = m();
            } catch (m) {
              _(m);
              C();
              throw m;
            }
            R = L;
            if ((0, U.J8)(R)) {
              return R.then(m => {
                C();
                return m;
              }, m => {
                _(m);
                C();
                throw m;
              });
            } else {
              C();
              return R;
            }
          }(() => _(X), () => {
            let {
              status: m
            } = (0, V.XU)(X);
            if (X.isRecording() && (!m || m === "ok")) {
              X.setStatus({
                code: eu.jt,
                message: "internal_error"
              });
            }
          }, () => X.end());
        });
      });
    }
    function startInactiveSpan(m) {
      let _ = getAcs();
      if (_.startInactiveSpan) {
        return _.startInactiveSpan(m);
      }
      let C = parseSentrySpanArguments(m);
      let {
        forceTransaction: R,
        parentSpan: B
      } = m;
      let F = m.scope ? _ => (0, L.$e)(m.scope, _) : B !== undefined ? m => withActiveSpan(B, m) : m => m();
      return F(() => {
        let _ = (0, L.nZ)();
        let B = getParentSpan(_);
        let F = m.onlyIfParent && !B;
        if (F) {
          return new et.b();
        } else {
          return createChildOrRootSpan({
            parentSpan: B,
            spanArguments: C,
            forceTransaction: R,
            scope: _
          });
        }
      });
    }
    function withActiveSpan(m, _) {
      let C = getAcs();
      if (C.withActiveSpan) {
        return C.withActiveSpan(m, _);
      } else {
        return (0, L.$e)(C => {
          (0, q.D)(C, m || undefined);
          return _(C);
        });
      }
    }
    function createChildOrRootSpan({
      parentSpan: m,
      spanArguments: _,
      forceTransaction: C,
      scope: R
    }) {
      var B;
      let F;
      if (!(0, H.z)()) {
        return new et.b();
      }
      let U = (0, L.aF)();
      if (m && !C) {
        F = function (m, _, C) {
          let {
            spanId: R,
            traceId: B
          } = m.spanContext();
          let F = !_.getScopeData().sdkProcessingMetadata[ed] && (0, V.Tt)(m);
          let U = F ? new SentrySpan({
            ...C,
            parentSpanId: R,
            traceId: B,
            sampled: F
          }) : new et.b({
            traceId: B
          });
          (0, V.j5)(m, U);
          let H = (0, L.s3)();
          if (H) {
            H.emit("spanStart", U);
            if (C.endTimestamp) {
              H.emit("spanEnd", U);
            }
          }
          return U;
        }(m, R, _);
        (0, V.j5)(m, F);
      } else if (m) {
        let C = (0, X.jC)(m);
        let {
          traceId: L,
          spanId: B
        } = m.spanContext();
        let U = (0, V.Tt)(m);
        F = _startRootSpan({
          traceId: L,
          parentSpanId: B,
          ..._
        }, R, U);
        (0, X.Lh)(F, C);
      } else {
        let {
          traceId: m,
          dsc: C,
          parentSpanId: L,
          sampled: B
        } = {
          ...U.getPropagationContext(),
          ...R.getPropagationContext()
        };
        F = _startRootSpan({
          traceId: m,
          parentSpanId: L,
          ..._
        }, R, B);
        if (C) {
          (0, X.Lh)(F, C);
        }
      }
      (function (m) {
        if (!Y.X) {
          return;
        }
        let {
          description: _ = "< unknown name >",
          op: C = "< unknown op >",
          parent_span_id: R
        } = (0, V.XU)(m);
        let {
          spanId: L
        } = m.spanContext();
        let B = (0, V.Tt)(m);
        let F = (0, V.Gx)(m);
        let U = F === m;
        let H = `[Tracing] Starting ${B ? "sampled" : "unsampled"} ${U ? "root " : ""}span`;
        let q = [`op: ${C}`, `name: ${_}`, `ID: ${L}`];
        if (R) {
          q.push(`parent ID: ${R}`);
        }
        if (!U) {
          let {
            op: m,
            description: _
          } = (0, V.XU)(F);
          q.push(`root ID: ${F.spanContext().spanId}`);
          if (m) {
            q.push(`root op: ${m}`);
          }
          if (_) {
            q.push(`root description: ${_}`);
          }
        }
        K.kg.log(`${H}
  ${q.join("\n  ")}`);
      })(F);
      if (B = F) {
        (0, ei.xp)(B, el, U);
        (0, ei.xp)(B, ec, R);
      }
      return F;
    }
    function parseSentrySpanArguments(m) {
      let _ = m.experimental || {};
      let C = {
        isStandalone: _.standalone,
        ...m
      };
      if (m.startTime) {
        let _ = {
          ...C
        };
        _.startTimestamp = (0, V.$k)(m.startTime);
        delete _.startTime;
        return _;
      }
      return C;
    }
    function getAcs() {
      let m = (0, R.c)();
      return (0, B.G)(m);
    }
    function _startRootSpan(m, _, C) {
      let R = (0, L.s3)();
      let B = R && R.getOptions() || {};
      let {
        name: U = "",
        attributes: q
      } = m;
      let [V, X] = _.getScopeData().sdkProcessingMetadata[ed] ? [false] : function (m, _) {
        let C;
        if (!(0, H.z)(m)) {
          return [false];
        }
        C = typeof m.tracesSampler == "function" ? m.tracesSampler(_) : _.parentSampled !== undefined ? _.parentSampled : m.tracesSampleRate !== undefined ? m.tracesSampleRate : 1;
        let R = (0, Q.o)(C);
        if (R === undefined) {
          if (Y.X) {
            K.kg.warn("[Tracing] Discarding transaction because of invalid sample rate.");
          }
          return [false];
        } else if (R) {
          if (Math.random() < R) {
            return [true, R];
          } else {
            if (Y.X) {
              K.kg.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(C)})`);
            }
            return [false, R];
          }
        } else {
          if (Y.X) {
            K.kg.log(`[Tracing] Discarding transaction because ${typeof m.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`);
          }
          return [false, R];
        }
      }(B, {
        name: U,
        parentSampled: C,
        attributes: q,
        transactionContext: {
          name: U,
          parentSampled: C
        }
      });
      let et = new SentrySpan({
        ...m,
        attributes: {
          [F.Zj]: "custom",
          ...m.attributes
        },
        sampled: V
      });
      if (X !== undefined) {
        et.setAttribute(F.TE, X);
      }
      if (R) {
        R.emit("spanStart", et);
      }
      return et;
    }
    function getParentSpan(m) {
      let _ = (0, q.Y)(m);
      if (!_) {
        return;
      }
      let C = (0, L.s3)();
      let R = C ? C.getOptions() : {};
      if (R.parentSpanIsAlwaysRootSpan) {
        return (0, V.Gx)(_);
      } else {
        return _;
      }
    }
  },
  67973: function (m, _, C) {
    "use strict";

    C.d(_, {
      z: function () {
        return hasTracingEnabled;
      }
    });
    var R = C(73076);
    function hasTracingEnabled(m) {
      if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) {
        return false;
      }
      let _ = (0, R.s3)();
      let C = m || _ && _.getOptions();
      return !!C && (C.enableTracing || "tracesSampleRate" in C || "tracesSampler" in C);
    }
  },
  79769: function (m, _, C) {
    "use strict";

    C.d(_, {
      o: function () {
        return parseSampleRate;
      }
    });
    var R = C(41001);
    var L = C(94223);
    function parseSampleRate(m) {
      if (typeof m == "boolean") {
        return Number(m);
      }
      let _ = typeof m == "string" ? parseFloat(m) : m;
      if (typeof _ != "number" || isNaN(_) || _ < 0 || _ > 1) {
        if (L.X) {
          R.kg.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(m)} of type ${JSON.stringify(typeof m)}.`);
        }
        return;
      }
      return _;
    }
  },
  5808: function (m, _, C) {
    "use strict";

    C.d(_, {
      U0: function () {
        return parseEventHintOrCaptureContext;
      },
      R: function () {
        return prepareEvent;
      }
    });
    var R = C(41982);
    var L = C(26181);
    var B = C(89163);
    var F = C(29531);
    var U = C(83408);
    var H = C(73243);
    var q = C(73076);
    var V = C(80128);
    var X = C(41001);
    var K = C(16824);
    var Y = C(94223);
    var Q = C(43927);
    var et = C(27179);
    var er = C(72123);
    var en = C(81585);
    function mergeScopeData(m, _) {
      let {
        extra: C,
        tags: R,
        user: L,
        contexts: B,
        level: F,
        sdkProcessingMetadata: U,
        breadcrumbs: H,
        fingerprint: q,
        eventProcessors: V,
        attachments: X,
        propagationContext: K,
        transactionName: Y,
        span: Q
      } = _;
      mergeAndOverwriteScopeData(m, "extra", C);
      mergeAndOverwriteScopeData(m, "tags", R);
      mergeAndOverwriteScopeData(m, "user", L);
      mergeAndOverwriteScopeData(m, "contexts", B);
      mergeAndOverwriteScopeData(m, "sdkProcessingMetadata", U);
      if (F) {
        m.level = F;
      }
      if (Y) {
        m.transactionName = Y;
      }
      if (Q) {
        m.span = Q;
      }
      if (H.length) {
        m.breadcrumbs = [...m.breadcrumbs, ...H];
      }
      if (q.length) {
        m.fingerprint = [...m.fingerprint, ...q];
      }
      if (V.length) {
        m.eventProcessors = [...m.eventProcessors, ...V];
      }
      if (X.length) {
        m.attachments = [...m.attachments, ...X];
      }
      m.propagationContext = {
        ...m.propagationContext,
        ...K
      };
    }
    function mergeAndOverwriteScopeData(m, _, C) {
      if (C && Object.keys(C).length) {
        m[_] = {
          ...m[_]
        };
        for (let R in C) {
          if (Object.prototype.hasOwnProperty.call(C, R)) {
            m[_][R] = C[R];
          }
        }
      }
    }
    function prepareEvent(m, _, C, eo, ea, es) {
      let {
        normalizeDepth: ec = 3,
        normalizeMaxBreadth: el = 1000
      } = m;
      let eu = {
        ..._,
        event_id: _.event_id || C.event_id || (0, R.DM)(),
        timestamp: _.timestamp || (0, L.yW)()
      };
      let ed = C.integrations || m.integrations.map(m => m.name);
      (function (m, _) {
        let {
          environment: C,
          release: R,
          dist: L,
          maxValueLength: F = 250
        } = _;
        if (!("environment" in m)) {
          m.environment = "environment" in _ ? C : H.J;
        }
        if (m.release === undefined && R !== undefined) {
          m.release = R;
        }
        if (m.dist === undefined && L !== undefined) {
          m.dist = L;
        }
        m.message &&= (0, B.$G)(m.message, F);
        let U = m.exception && m.exception.values && m.exception.values[0];
        if (U && U.value) {
          U.value = (0, B.$G)(U.value, F);
        }
        let q = m.request;
        if (q && q.url) {
          q.url = (0, B.$G)(q.url, F);
        }
      })(eu, m);
      if (ed.length > 0) {
        eu.sdk = eu.sdk || {};
        eu.sdk.integrations = [...(eu.sdk.integrations || []), ...ed];
      }
      if (ea) {
        ea.emit("applyFrameMetadata", _);
      }
      if (_.type === undefined) {
        (function (m, _) {
          let C;
          let R = F.GLOBAL_OBJ._sentryDebugIds;
          if (!R) {
            return;
          }
          let L = ei.get(_);
          if (L) {
            C = L;
          } else {
            C = new Map();
            ei.set(_, C);
          }
          let B = Object.entries(R).reduce((m, [R, L]) => {
            let B;
            let F = C.get(R);
            if (F) {
              B = F;
            } else {
              B = _(R);
              C.set(R, B);
            }
            for (let _ = B.length - 1; _ >= 0; _--) {
              let C = B[_];
              if (C.filename) {
                m[C.filename] = L;
                break;
              }
            }
            return m;
          }, {});
          try {
            m.exception.values.forEach(m => {
              m.stacktrace.frames.forEach(m => {
                if (m.filename) {
                  m.debug_id = B[m.filename];
                }
              });
            });
          } catch (m) {}
        })(eu, m.stackParser);
      }
      let ep = function (m, _) {
        if (!_) {
          return m;
        }
        let C = m ? m.clone() : new Q.s();
        C.update(_);
        return C;
      }(eo, C.captureContext);
      if (C.mechanism) {
        (0, R.EG)(eu, C.mechanism);
      }
      let eh = ea ? ea.getEventProcessors() : [];
      let ef = (0, q.lW)().getScopeData();
      if (es) {
        let m = es.getScopeData();
        mergeScopeData(ef, m);
      }
      if (ep) {
        let m = ep.getScopeData();
        mergeScopeData(ef, m);
      }
      let em = [...(C.attachments || []), ...ef.attachments];
      if (em.length) {
        C.attachments = em;
      }
      (function (m, _) {
        let {
          fingerprint: C,
          span: L,
          breadcrumbs: B,
          sdkProcessingMetadata: F
        } = _;
        (function (m, _) {
          let {
            extra: C,
            tags: R,
            user: L,
            contexts: B,
            level: F,
            transactionName: U
          } = _;
          let H = (0, et.Jr)(C);
          if (H && Object.keys(H).length) {
            m.extra = {
              ...H,
              ...m.extra
            };
          }
          let q = (0, et.Jr)(R);
          if (q && Object.keys(q).length) {
            m.tags = {
              ...q,
              ...m.tags
            };
          }
          let V = (0, et.Jr)(L);
          if (V && Object.keys(V).length) {
            m.user = {
              ...V,
              ...m.user
            };
          }
          let X = (0, et.Jr)(B);
          if (X && Object.keys(X).length) {
            m.contexts = {
              ...X,
              ...m.contexts
            };
          }
          if (F) {
            m.level = F;
          }
          if (U && m.type !== "transaction") {
            m.transaction = U;
          }
        })(m, _);
        if (L) {
          (function (m, _) {
            m.contexts = {
              trace: (0, en.wy)(_),
              ...m.contexts
            };
            m.sdkProcessingMetadata = {
              dynamicSamplingContext: (0, er.jC)(_),
              ...m.sdkProcessingMetadata
            };
            let C = (0, en.Gx)(_);
            let R = (0, en.XU)(C).description;
            if (R && !m.transaction && m.type === "transaction") {
              m.transaction = R;
            }
          })(m, L);
        }
        m.fingerprint = m.fingerprint ? (0, R.lE)(m.fingerprint) : [];
        if (C) {
          m.fingerprint = m.fingerprint.concat(C);
        }
        if (m.fingerprint && !m.fingerprint.length) {
          delete m.fingerprint;
        }
        (function (m, _) {
          let C = [...(m.breadcrumbs || []), ..._];
          m.breadcrumbs = C.length ? C : undefined;
        })(m, B);
        m.sdkProcessingMetadata = {
          ...m.sdkProcessingMetadata,
          ...F
        };
      })(eu, ef);
      let eg = [...eh, ...ef.eventProcessors];
      let ey = function notifyEventProcessors(m, _, C, R = 0) {
        return new V.cW((L, B) => {
          let F = m[R];
          if (_ === null || typeof F != "function") {
            L(_);
          } else {
            let U = F({
              ..._
            }, C);
            if (Y.X && F.id && U === null) {
              X.kg.log(`Event processor "${F.id}" dropped event`);
            }
            if ((0, K.J8)(U)) {
              U.then(_ => notifyEventProcessors(m, _, C, R + 1).then(L)).then(null, B);
            } else {
              notifyEventProcessors(m, U, C, R + 1).then(L).then(null, B);
            }
          }
        });
      }(eg, eu, C);
      return ey.then(m => (m && function (m) {
        let _ = {};
        try {
          m.exception.values.forEach(m => {
            m.stacktrace.frames.forEach(m => {
              if (m.debug_id) {
                if (m.abs_path) {
                  _[m.abs_path] = m.debug_id;
                } else if (m.filename) {
                  _[m.filename] = m.debug_id;
                }
                delete m.debug_id;
              }
            });
          });
        } catch (m) {}
        if (Object.keys(_).length === 0) {
          return;
        }
        m.debug_meta = m.debug_meta || {};
        m.debug_meta.images = m.debug_meta.images || [];
        let C = m.debug_meta.images;
        Object.entries(_).forEach(([m, _]) => {
          C.push({
            type: "sourcemap",
            code_file: m,
            debug_id: _
          });
        });
      }(m), typeof ec == "number" && ec > 0) ? function (m, _, C) {
        if (!m) {
          return null;
        }
        let R = {
          ...m,
          ...(m.breadcrumbs && {
            breadcrumbs: m.breadcrumbs.map(m => ({
              ...m,
              ...(m.data && {
                data: (0, U.Fv)(m.data, _, C)
              })
            }))
          }),
          ...(m.user && {
            user: (0, U.Fv)(m.user, _, C)
          }),
          ...(m.contexts && {
            contexts: (0, U.Fv)(m.contexts, _, C)
          }),
          ...(m.extra && {
            extra: (0, U.Fv)(m.extra, _, C)
          })
        };
        if (m.contexts && m.contexts.trace && R.contexts) {
          R.contexts.trace = m.contexts.trace;
          if (m.contexts.trace.data) {
            R.contexts.trace.data = (0, U.Fv)(m.contexts.trace.data, _, C);
          }
        }
        if (m.spans) {
          R.spans = m.spans.map(m => ({
            ...m,
            ...(m.data && {
              data: (0, U.Fv)(m.data, _, C)
            })
          }));
        }
        return R;
      }(m, ec, el) : m);
    }
    let ei = new WeakMap();
    function parseEventHintOrCaptureContext(m) {
      if (m) {
        if (m instanceof Q.s || typeof m == "function" || Object.keys(m).some(m => eo.includes(m))) {
          return {
            captureContext: m
          };
        } else {
          return m;
        }
      } else {
        return undefined;
      }
    }
    let eo = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
  },
  89366: function (m, _, C) {
    "use strict";

    C.d(_, {
      D: function () {
        return _setSpanForScope;
      },
      Y: function () {
        return _getSpanForScope;
      }
    });
    var R = C(27179);
    let L = "_sentrySpan";
    function _setSpanForScope(m, _) {
      if (_) {
        (0, R.xp)(m, L, _);
      } else {
        delete m[L];
      }
    }
    function _getSpanForScope(m) {
      return m[L];
    }
  },
  81585: function (m, _, C) {
    "use strict";

    C.d(_, {
      $k: function () {
        return spanTimeInputToSeconds;
      },
      Dp: function () {
        return getSpanDescendants;
      },
      Gx: function () {
        return getRootSpan;
      },
      HN: function () {
        return getActiveSpan;
      },
      HR: function () {
        return spanToTransactionTraceContext;
      },
      Hb: function () {
        return spanToTraceHeader;
      },
      Tt: function () {
        return spanIsSampled;
      },
      XU: function () {
        return spanToJSON;
      },
      _4: function () {
        return getStatusMessage;
      },
      ed: function () {
        return removeChildSpanFromSpan;
      },
      i0: function () {
        return Q;
      },
      j5: function () {
        return addChildSpanToSpan;
      },
      ve: function () {
        return Y;
      },
      wy: function () {
        return spanToTraceContext;
      }
    });
    var R = C(27179);
    var L = C(85712);
    var B = C(26181);
    var F = C(60811);
    var U = C(13533);
    var H = C(73076);
    var q = C(72751);
    var V = C(31218);
    var X = C(69737);
    var K = C(89366);
    let Y = 0;
    let Q = 1;
    function spanToTransactionTraceContext(m) {
      let {
        spanId: _,
        traceId: C
      } = m.spanContext();
      let {
        data: L,
        op: B,
        parent_span_id: F,
        status: U,
        origin: H
      } = spanToJSON(m);
      return (0, R.Jr)({
        parent_span_id: F,
        span_id: _,
        trace_id: C,
        data: L,
        op: B,
        status: U,
        origin: H
      });
    }
    function spanToTraceContext(m) {
      let {
        spanId: _,
        traceId: C
      } = m.spanContext();
      let {
        parent_span_id: L
      } = spanToJSON(m);
      return (0, R.Jr)({
        parent_span_id: L,
        span_id: _,
        trace_id: C
      });
    }
    function spanToTraceHeader(m) {
      let {
        traceId: _,
        spanId: C
      } = m.spanContext();
      let R = spanIsSampled(m);
      return (0, L.$p)(_, C, R);
    }
    function spanTimeInputToSeconds(m) {
      if (typeof m == "number") {
        return ensureTimestampInSeconds(m);
      } else if (Array.isArray(m)) {
        return m[0] + m[1] / 1000000000;
      } else if (m instanceof Date) {
        return ensureTimestampInSeconds(m.getTime());
      } else {
        return (0, B.ph)();
      }
    }
    function ensureTimestampInSeconds(m) {
      if (m > 9999999999) {
        return m / 1000;
      } else {
        return m;
      }
    }
    function spanToJSON(m) {
      if (typeof m.getSpanJSON == "function") {
        return m.getSpanJSON();
      }
      try {
        let {
          spanId: _,
          traceId: C
        } = m.spanContext();
        if (m.attributes && m.startTime && m.name && m.endTime && m.status) {
          let {
            attributes: L,
            startTime: B,
            name: F,
            endTime: U,
            parentSpanId: H,
            status: X
          } = m;
          return (0, R.Jr)({
            span_id: _,
            trace_id: C,
            data: L,
            description: F,
            parent_span_id: H,
            start_timestamp: spanTimeInputToSeconds(B),
            timestamp: spanTimeInputToSeconds(U) || undefined,
            status: getStatusMessage(X),
            op: L[V.$J],
            origin: L[V.S3],
            _metrics_summary: (0, q.y)(m)
          });
        }
        return {
          span_id: _,
          trace_id: C
        };
      } catch (m) {
        return {};
      }
    }
    function spanIsSampled(m) {
      let {
        traceFlags: _
      } = m.spanContext();
      return _ === Q;
    }
    function getStatusMessage(m) {
      if (m && m.code !== X.pq) {
        if (m.code === X.OP) {
          return "ok";
        } else {
          return m.message || "unknown_error";
        }
      } else {
        return undefined;
      }
    }
    let et = "_sentryChildSpans";
    let er = "_sentryRootSpan";
    function addChildSpanToSpan(m, _) {
      let C = m[er] || m;
      (0, R.xp)(_, er, C);
      if (m[et]) {
        m[et].add(_);
      } else {
        (0, R.xp)(m, et, new Set([_]));
      }
    }
    function removeChildSpanFromSpan(m, _) {
      if (m[et]) {
        m[et].delete(_);
      }
    }
    function getSpanDescendants(m) {
      let _ = new Set();
      (function addSpanChildren(m) {
        if (!_.has(m) && spanIsSampled(m)) {
          _.add(m);
          let C = m[et] ? Array.from(m[et]) : [];
          for (let m of C) {
            addSpanChildren(m);
          }
        }
      })(m);
      return Array.from(_);
    }
    function getRootSpan(m) {
      return m[er] || m;
    }
    function getActiveSpan() {
      let m = (0, U.c)();
      let _ = (0, F.G)(m);
      if (_.getActiveSpan) {
        return _.getActiveSpan();
      } else {
        return (0, K.Y)((0, H.nZ)());
      }
    }
  },
  36096: function (m, _, C) {
    "use strict";

    C.d(_, {
      X: function () {
        return R;
      }
    });
    let R = false;
  },
  60859: function (m, _, C) {
    "use strict";

    C.d(_, {
      EN: function () {
        return baggageHeaderToDynamicSamplingContext;
      },
      IQ: function () {
        return dynamicSamplingContextToSentryBaggageHeader;
      },
      bU: function () {
        return F;
      }
    });
    var R = C(1525);
    var L = C(16824);
    var B = C(41001);
    let F = "baggage";
    let U = "sentry-";
    let H = /^sentry-/;
    function baggageHeaderToDynamicSamplingContext(m) {
      let _ = m && ((0, L.HD)(m) || Array.isArray(m)) ? Array.isArray(m) ? m.reduce((m, _) => {
        let C = baggageHeaderToObject(_);
        Object.entries(C).forEach(([_, C]) => {
          m[_] = C;
        });
        return m;
      }, {}) : baggageHeaderToObject(m) : undefined;
      if (!_) {
        return;
      }
      let C = Object.entries(_).reduce((m, [_, C]) => {
        if (_.match(H)) {
          let R = _.slice(U.length);
          m[R] = C;
        }
        return m;
      }, {});
      if (Object.keys(C).length > 0) {
        return C;
      } else {
        return undefined;
      }
    }
    function dynamicSamplingContextToSentryBaggageHeader(m) {
      if (!m) {
        return;
      }
      let _ = Object.entries(m).reduce((m, [_, C]) => {
        if (C) {
          m[`${U}${_}`] = C;
        }
        return m;
      }, {});
      return function (m) {
        if (Object.keys(m).length !== 0) {
          return Object.entries(m).reduce((m, [_, C], L) => {
            let F = `${encodeURIComponent(_)}=${encodeURIComponent(C)}`;
            let U = L === 0 ? F : `${m},${F}`;
            if (U.length > 8192) {
              if (R.X) {
                B.kg.warn(`Not adding key: ${_} with val: ${C} to baggage header due to exceeding baggage size limits.`);
              }
              return m;
            } else {
              return U;
            }
          }, "");
        }
      }(_);
    }
    function baggageHeaderToObject(m) {
      return m.split(",").map(m => m.split("=").map(m => decodeURIComponent(m.trim()))).reduce((m, [_, C]) => {
        if (_ && C) {
          m[_] = C;
        }
        return m;
      }, {});
    }
  },
  1869: function (m, _, C) {
    "use strict";

    C.d(_, {
      Rt: function () {
        return htmlTreeAsString;
      },
      iY: function () {
        return getComponentName;
      },
      l4: function () {
        return getLocationHref;
      },
      qT: function () {
        return getDomElement;
      }
    });
    var R = C(16824);
    var L = C(29531);
    let B = L.GLOBAL_OBJ;
    function htmlTreeAsString(m, _ = {}) {
      if (!m) {
        return "<unknown>";
      }
      try {
        let C;
        let L = m;
        let F = [];
        let U = 0;
        let H = 0;
        let q = Array.isArray(_) ? _ : _.keyAttrs;
        let V = !Array.isArray(_) && _.maxStringLength || 80;
        while (L && U++ < 5 && (C = function (m, _) {
          let C = [];
          if (!m || !m.tagName) {
            return "";
          }
          if (B.HTMLElement && m instanceof HTMLElement && m.dataset) {
            if (m.dataset.sentryComponent) {
              return m.dataset.sentryComponent;
            }
            if (m.dataset.sentryElement) {
              return m.dataset.sentryElement;
            }
          }
          C.push(m.tagName.toLowerCase());
          let L = _ && _.length ? _.filter(_ => m.getAttribute(_)).map(_ => [_, m.getAttribute(_)]) : null;
          if (L && L.length) {
            L.forEach(m => {
              C.push(`[${m[0]}="${m[1]}"]`);
            });
          } else {
            if (m.id) {
              C.push(`#${m.id}`);
            }
            let _ = m.className;
            if (_ && (0, R.HD)(_)) {
              let m = _.split(/\s+/);
              for (let _ of m) {
                C.push(`.${_}`);
              }
            }
          }
          for (let _ of ["aria-label", "type", "name", "title", "alt"]) {
            let R = m.getAttribute(_);
            if (R) {
              C.push(`[${_}="${R}"]`);
            }
          }
          return C.join("");
        }(L, q), C !== "html" && (!(U > 1) || !(H + F.length * 3 + C.length >= V)))) {
          F.push(C);
          H += C.length;
          L = L.parentNode;
        }
        return F.reverse().join(" > ");
      } catch (m) {
        return "<unknown>";
      }
    }
    function getLocationHref() {
      try {
        return B.document.location.href;
      } catch (m) {
        return "";
      }
    }
    function getDomElement(m) {
      if (B.document && B.document.querySelector) {
        return B.document.querySelector(m);
      } else {
        return null;
      }
    }
    function getComponentName(m) {
      if (!B.HTMLElement) {
        return null;
      }
      let _ = m;
      for (let m = 0; m < 5 && _; m++) {
        if (_ instanceof HTMLElement) {
          if (_.dataset.sentryComponent) {
            return _.dataset.sentryComponent;
          }
          if (_.dataset.sentryElement) {
            return _.dataset.sentryElement;
          }
        }
        _ = _.parentNode;
      }
      return null;
    }
  },
  1525: function (m, _, C) {
    "use strict";

    C.d(_, {
      X: function () {
        return R;
      }
    });
    let R = false;
  },
  73326: function (m, _, C) {
    "use strict";

    C.d(_, {
      RA: function () {
        return dsnToString;
      },
      U4: function () {
        return dsnFromString;
      },
      vK: function () {
        return makeDsn;
      }
    });
    var R = C(1525);
    var L = C(41001);
    let B = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function dsnToString(m, _ = false) {
      let {
        host: C,
        path: R,
        pass: L,
        port: B,
        projectId: F,
        protocol: U,
        publicKey: H
      } = m;
      return `${U}://${H}${_ && L ? `:${L}` : ""}@${C}${B ? `:${B}` : ""}/${R ? `${R}/` : R}${F}`;
    }
    function dsnFromString(m) {
      let _ = B.exec(m);
      if (!_) {
        (0, L.Cf)(() => {
          console.error(`Invalid Sentry Dsn: ${m}`);
        });
        return;
      }
      let [C, R, F = "", U = "", H = "", q = ""] = _.slice(1);
      let V = "";
      let X = q;
      let K = X.split("/");
      if (K.length > 1) {
        V = K.slice(0, -1).join("/");
        X = K.pop();
      }
      if (X) {
        let m = X.match(/^\d+/);
        if (m) {
          X = m[0];
        }
      }
      return dsnFromComponents({
        host: U,
        pass: F,
        path: V,
        projectId: X,
        port: H,
        protocol: C,
        publicKey: R
      });
    }
    function dsnFromComponents(m) {
      return {
        protocol: m.protocol,
        publicKey: m.publicKey || "",
        pass: m.pass || "",
        host: m.host,
        port: m.port || "",
        path: m.path || "",
        projectId: m.projectId
      };
    }
    function makeDsn(m) {
      let _ = typeof m == "string" ? dsnFromString(m) : dsnFromComponents(m);
      if (_ && function (m) {
        if (!R.X) {
          return true;
        }
        let {
          port: _,
          projectId: C,
          protocol: B
        } = m;
        let F = ["protocol", "publicKey", "host", "projectId"].find(_ => !m[_] && (L.kg.error(`Invalid Sentry Dsn: ${_} missing`), true));
        return !F && (C.match(/^\d+$/) ? B === "http" || B === "https" ? !_ || !isNaN(parseInt(_, 10)) || (L.kg.error(`Invalid Sentry Dsn: Invalid port ${_}`), false) : (L.kg.error(`Invalid Sentry Dsn: Invalid protocol ${B}`), false) : (L.kg.error(`Invalid Sentry Dsn: Invalid projectId ${C}`), false));
      }(_)) {
        return _;
      }
    }
  },
  39432: function (m, _, C) {
    "use strict";

    C.d(_, {
      BO: function () {
        return addItemToEnvelope;
      },
      Cd: function () {
        return createEventEnvelopeHeaders;
      },
      HY: function () {
        return getSdkMetadataForEnvelopeHeader;
      },
      Jd: function () {
        return createEnvelope;
      },
      KQ: function () {
        return createSpanEnvelopeItem;
      },
      V$: function () {
        return serializeEnvelope;
      },
      gv: function () {
        return forEachEnvelopeItem;
      },
      mL: function () {
        return envelopeItemTypeToDataCategory;
      },
      zQ: function () {
        return createAttachmentEnvelopeItem;
      }
    });
    var R = C(73326);
    var L = C(83408);
    var B = C(27179);
    var F = C(29531);
    function createEnvelope(m, _ = []) {
      return [m, _];
    }
    function addItemToEnvelope(m, _) {
      let [C, R] = m;
      return [C, [...R, _]];
    }
    function forEachEnvelopeItem(m, _) {
      let C = m[1];
      for (let m of C) {
        let C = m[0].type;
        let R = _(m, C);
        if (R) {
          return true;
        }
      }
      return false;
    }
    function encodeUTF8(m) {
      if (F.GLOBAL_OBJ.__SENTRY__ && F.GLOBAL_OBJ.__SENTRY__.encodePolyfill) {
        return F.GLOBAL_OBJ.__SENTRY__.encodePolyfill(m);
      } else {
        return new TextEncoder().encode(m);
      }
    }
    function serializeEnvelope(m) {
      let [_, C] = m;
      let R = JSON.stringify(_);
      function append(m) {
        if (typeof R == "string") {
          R = typeof m == "string" ? R + m : [encodeUTF8(R), m];
        } else {
          R.push(typeof m == "string" ? encodeUTF8(m) : m);
        }
      }
      for (let m of C) {
        let [_, C] = m;
        append(`
${JSON.stringify(_)}
`);
        if (typeof C == "string" || C instanceof Uint8Array) {
          append(C);
        } else {
          let m;
          try {
            m = JSON.stringify(C);
          } catch (_) {
            m = JSON.stringify((0, L.Fv)(C));
          }
          append(m);
        }
      }
      if (typeof R == "string") {
        return R;
      } else {
        return function (m) {
          let _ = m.reduce((m, _) => m + _.length, 0);
          let C = new Uint8Array(_);
          let R = 0;
          for (let _ of m) {
            C.set(_, R);
            R += _.length;
          }
          return C;
        }(R);
      }
    }
    function createSpanEnvelopeItem(m) {
      return [{
        type: "span"
      }, m];
    }
    function createAttachmentEnvelopeItem(m) {
      let _ = typeof m.data == "string" ? encodeUTF8(m.data) : m.data;
      return [(0, B.Jr)({
        type: "attachment",
        length: _.length,
        filename: m.filename,
        content_type: m.contentType,
        attachment_type: m.attachmentType
      }), _];
    }
    let U = {
      session: "session",
      sessions: "session",
      attachment: "attachment",
      transaction: "transaction",
      event: "error",
      client_report: "internal",
      user_report: "default",
      profile: "profile",
      profile_chunk: "profile",
      replay_event: "replay",
      replay_recording: "replay",
      check_in: "monitor",
      feedback: "feedback",
      span: "span",
      statsd: "metric_bucket"
    };
    function envelopeItemTypeToDataCategory(m) {
      return U[m];
    }
    function getSdkMetadataForEnvelopeHeader(m) {
      if (!m || !m.sdk) {
        return;
      }
      let {
        name: _,
        version: C
      } = m.sdk;
      return {
        name: _,
        version: C
      };
    }
    function createEventEnvelopeHeaders(m, _, C, L) {
      let F = m.sdkProcessingMetadata && m.sdkProcessingMetadata.dynamicSamplingContext;
      return {
        event_id: m.event_id,
        sent_at: new Date().toISOString(),
        ...(_ && {
          sdk: _
        }),
        ...(!!C && L && {
          dsn: (0, R.RA)(L)
        }),
        ...(F && {
          trace: (0, B.Jr)({
            ...F
          })
        })
      };
    }
  },
  16824: function (m, _, C) {
    "use strict";

    C.d(_, {
      Cy: function () {
        return isSyntheticEvent;
      },
      HD: function () {
        return isString;
      },
      J8: function () {
        return isThenable;
      },
      Kj: function () {
        return isRegExp;
      },
      Le: function () {
        return isParameterizedString;
      },
      PO: function () {
        return isPlainObject;
      },
      TX: function () {
        return isDOMError;
      },
      V9: function () {
        return isInstanceOf;
      },
      VW: function () {
        return isErrorEvent;
      },
      VZ: function () {
        return isError;
      },
      cO: function () {
        return isEvent;
      },
      fm: function () {
        return isDOMException;
      },
      kK: function () {
        return isElement;
      },
      pt: function () {
        return isPrimitive;
      },
      y1: function () {
        return isVueViewModel;
      }
    });
    let R = Object.prototype.toString;
    function isError(m) {
      switch (R.call(m)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
        case "[object WebAssembly.Exception]":
          return true;
        default:
          return isInstanceOf(m, Error);
      }
    }
    function isBuiltin(m, _) {
      return R.call(m) === `[object ${_}]`;
    }
    function isErrorEvent(m) {
      return isBuiltin(m, "ErrorEvent");
    }
    function isDOMError(m) {
      return isBuiltin(m, "DOMError");
    }
    function isDOMException(m) {
      return isBuiltin(m, "DOMException");
    }
    function isString(m) {
      return isBuiltin(m, "String");
    }
    function isParameterizedString(m) {
      return typeof m == "object" && m !== null && "__sentry_template_string__" in m && "__sentry_template_values__" in m;
    }
    function isPrimitive(m) {
      return m === null || isParameterizedString(m) || typeof m != "object" && typeof m != "function";
    }
    function isPlainObject(m) {
      return isBuiltin(m, "Object");
    }
    function isEvent(m) {
      return typeof Event != "undefined" && isInstanceOf(m, Event);
    }
    function isElement(m) {
      return typeof Element != "undefined" && isInstanceOf(m, Element);
    }
    function isRegExp(m) {
      return isBuiltin(m, "RegExp");
    }
    function isThenable(m) {
      return !!m && !!m.then && typeof m.then == "function";
    }
    function isSyntheticEvent(m) {
      return isPlainObject(m) && "nativeEvent" in m && "preventDefault" in m && "stopPropagation" in m;
    }
    function isInstanceOf(m, _) {
      try {
        return m instanceof _;
      } catch (m) {
        return false;
      }
    }
    function isVueViewModel(m) {
      return typeof m == "object" && m !== null && (!!m.__isVue || !!m._isVue);
    }
  },
  41001: function (m, _, C) {
    "use strict";

    C.d(_, {
      Cf: function () {
        return consoleSandbox;
      },
      LD: function () {
        return F;
      },
      RU: function () {
        return B;
      },
      kg: function () {
        return U;
      }
    });
    var R = C(1525);
    var L = C(29531);
    let B = ["debug", "info", "warn", "error", "log", "assert", "trace"];
    let F = {};
    function consoleSandbox(m) {
      if (!("console" in L.GLOBAL_OBJ)) {
        return m();
      }
      let _ = L.GLOBAL_OBJ.console;
      let C = {};
      let R = Object.keys(F);
      R.forEach(m => {
        let R = F[m];
        C[m] = _[m];
        _[m] = R;
      });
      try {
        return m();
      } finally {
        R.forEach(m => {
          _[m] = C[m];
        });
      }
    }
    let U = (0, L.Y)("logger", function () {
      let m = false;
      let _ = {
        enable: () => {
          m = true;
        },
        disable: () => {
          m = false;
        },
        isEnabled: () => m
      };
      if (R.X) {
        B.forEach(C => {
          _[C] = (..._) => {
            if (m) {
              consoleSandbox(() => {
                L.GLOBAL_OBJ.console[C](`Sentry Logger [${C}]:`, ..._);
              });
            }
          };
        });
      } else {
        B.forEach(m => {
          _[m] = () => undefined;
        });
      }
      return _;
    });
  },
  41982: function (m, _, C) {
    "use strict";

    C.d(_, {
      DM: function () {
        return uuid4;
      },
      Db: function () {
        return addExceptionTypeValue;
      },
      EG: function () {
        return addExceptionMechanism;
      },
      YO: function () {
        return checkOrSetAlreadyCaught;
      },
      jH: function () {
        return getEventDescription;
      },
      lE: function () {
        return arrayify;
      }
    });
    var R = C(27179);
    var L = C(29531);
    function uuid4() {
      let m = L.GLOBAL_OBJ;
      let _ = m.crypto || m.msCrypto;
      let getRandomByte = () => Math.random() * 16;
      try {
        if (_ && _.randomUUID) {
          return _.randomUUID().replace(/-/g, "");
        }
        if (_ && _.getRandomValues) {
          getRandomByte = () => {
            let m = new Uint8Array(1);
            _.getRandomValues(m);
            return m[0];
          };
        }
      } catch (m) {}
      return "10000000100040008000100000000000".replace(/[018]/g, m => (m ^ (getRandomByte() & 15) >> m / 4).toString(16));
    }
    function getFirstException(m) {
      if (m.exception && m.exception.values) {
        return m.exception.values[0];
      } else {
        return undefined;
      }
    }
    function getEventDescription(m) {
      let {
        message: _,
        event_id: C
      } = m;
      if (_) {
        return _;
      }
      let R = getFirstException(m);
      if (R) {
        if (R.type && R.value) {
          return `${R.type}: ${R.value}`;
        } else {
          return R.type || R.value || C || "<unknown>";
        }
      } else {
        return C || "<unknown>";
      }
    }
    function addExceptionTypeValue(m, _, C) {
      let R = m.exception = m.exception || {};
      let L = R.values = R.values || [];
      let B = L[0] = L[0] || {};
      B.value ||= _ || "";
      B.type ||= C || "Error";
    }
    function addExceptionMechanism(m, _) {
      let C = getFirstException(m);
      if (!C) {
        return;
      }
      let R = C.mechanism;
      C.mechanism = {
        type: "generic",
        handled: true,
        ...R,
        ..._
      };
      if (_ && "data" in _) {
        let m = {
          ...(R && R.data),
          ..._.data
        };
        C.mechanism.data = m;
      }
    }
    function checkOrSetAlreadyCaught(m) {
      if (m && m.__sentry_captured__) {
        return true;
      }
      try {
        (0, R.xp)(m, "__sentry_captured__", true);
      } catch (m) {}
      return false;
    }
    function arrayify(m) {
      if (Array.isArray(m)) {
        return m;
      } else {
        return [m];
      }
    }
  },
  83408: function (m, _, C) {
    "use strict";

    C.d(_, {
      Fv: function () {
        return normalize;
      },
      Qy: function () {
        return function normalizeToSize(m, _ = 3, C = 102400) {
          let R = normalize(m, _);
          if (~-encodeURI(JSON.stringify(R)).split(/%..|./).length > C) {
            return normalizeToSize(m, _ - 1, C);
          } else {
            return R;
          }
        };
      }
    });
    var R = C(16824);
    var L = C(27179);
    var B = C(42283);
    function normalize(m, _ = 100, C = Infinity) {
      try {
        return function visit(m, _, C = Infinity, F = Infinity, U = function () {
          let m = typeof WeakSet == "function";
          let _ = m ? new WeakSet() : [];
          return [function (C) {
            if (m) {
              return !!_.has(C) || (_.add(C), false);
            }
            for (let m = 0; m < _.length; m++) {
              let R = _[m];
              if (R === C) {
                return true;
              }
            }
            _.push(C);
            return false;
          }, function (C) {
            if (m) {
              _.delete(C);
            } else {
              for (let m = 0; m < _.length; m++) {
                if (_[m] === C) {
                  _.splice(m, 1);
                  break;
                }
              }
            }
          }];
        }()) {
          let [H, q] = U;
          if (_ == null || ["boolean", "string"].includes(typeof _) || typeof _ == "number" && Number.isFinite(_)) {
            return _;
          }
          let V = function (m, _) {
            try {
              if (m === "domain" && _ && typeof _ == "object" && _._events) {
                return "[Domain]";
              }
              if (m === "domainEmitter") {
                return "[DomainEmitter]";
              }
              if (typeof global != "undefined" && _ === global) {
                return "[Global]";
              }
              if (typeof window != "undefined" && _ === window) {
                return "[Window]";
              }
              if (typeof document != "undefined" && _ === document) {
                return "[Document]";
              }
              if ((0, R.y1)(_)) {
                return "[VueViewModel]";
              }
              if ((0, R.Cy)(_)) {
                return "[SyntheticEvent]";
              }
              if (typeof _ == "number" && !Number.isFinite(_)) {
                return `[${_}]`;
              }
              if (typeof _ == "function") {
                return `[Function: ${(0, B.$P)(_)}]`;
              }
              if (typeof _ == "symbol") {
                return `[${String(_)}]`;
              }
              if (typeof _ == "bigint") {
                return `[BigInt: ${String(_)}]`;
              }
              let C = function (m) {
                let _ = Object.getPrototypeOf(m);
                if (_) {
                  return _.constructor.name;
                } else {
                  return "null prototype";
                }
              }(_);
              if (/^HTML(\w*)Element$/.test(C)) {
                return `[HTMLElement: ${C}]`;
              }
              return `[object ${C}]`;
            } catch (m) {
              return `**non-serializable** (${m})`;
            }
          }(m, _);
          if (!V.startsWith("[object ")) {
            return V;
          }
          if (_.__sentry_skip_normalization__) {
            return _;
          }
          let X = typeof _.__sentry_override_normalization_depth__ == "number" ? _.__sentry_override_normalization_depth__ : C;
          if (X === 0) {
            return V.replace("object ", "");
          }
          if (H(_)) {
            return "[Circular ~]";
          }
          if (_ && typeof _.toJSON == "function") {
            try {
              let m = _.toJSON();
              return visit("", m, X - 1, F, U);
            } catch (m) {}
          }
          let K = Array.isArray(_) ? [] : {};
          let Y = 0;
          let Q = (0, L.Sh)(_);
          for (let m in Q) {
            if (!Object.prototype.hasOwnProperty.call(Q, m)) {
              continue;
            }
            if (Y >= F) {
              K[m] = "[MaxProperties ~]";
              break;
            }
            let _ = Q[m];
            K[m] = visit(m, _, X - 1, F, U);
            Y++;
          }
          q(_);
          return K;
        }("", m, _, C);
      } catch (m) {
        return {
          ERROR: `**non-serializable** (${m})`
        };
      }
    }
  },
  27179: function (m, _, C) {
    "use strict";

    C.d(_, {
      $Q: function () {
        return markFunctionWrapped;
      },
      HK: function () {
        return getOriginalFunction;
      },
      Jr: function () {
        return dropUndefinedKeys;
      },
      Sh: function () {
        return convertToPlainObject;
      },
      _j: function () {
        return urlEncode;
      },
      hl: function () {
        return fill;
      },
      xp: function () {
        return addNonEnumerableProperty;
      },
      zf: function () {
        return extractExceptionKeysForMessage;
      }
    });
    var R = C(1869);
    var L = C(1525);
    var B = C(16824);
    var F = C(41001);
    var U = C(89163);
    function fill(m, _, C) {
      if (!(_ in m)) {
        return;
      }
      let R = m[_];
      let L = C(R);
      if (typeof L == "function") {
        markFunctionWrapped(L, R);
      }
      m[_] = L;
    }
    function addNonEnumerableProperty(m, _, C) {
      try {
        Object.defineProperty(m, _, {
          value: C,
          writable: true,
          configurable: true
        });
      } catch (C) {
        if (L.X) {
          F.kg.log(`Failed to add non-enumerable property "${_}" to object`, m);
        }
      }
    }
    function markFunctionWrapped(m, _) {
      try {
        let C = _.prototype || {};
        m.prototype = _.prototype = C;
        addNonEnumerableProperty(m, "__sentry_original__", _);
      } catch (m) {}
    }
    function getOriginalFunction(m) {
      return m.__sentry_original__;
    }
    function urlEncode(m) {
      return Object.keys(m).map(_ => `${encodeURIComponent(_)}=${encodeURIComponent(m[_])}`).join("&");
    }
    function convertToPlainObject(m) {
      if ((0, B.VZ)(m)) {
        return {
          message: m.message,
          name: m.name,
          stack: m.stack,
          ...getOwnProperties(m)
        };
      }
      if (!(0, B.cO)(m)) {
        return m;
      }
      {
        let _ = {
          type: m.type,
          target: serializeEventTarget(m.target),
          currentTarget: serializeEventTarget(m.currentTarget),
          ...getOwnProperties(m)
        };
        if (typeof CustomEvent != "undefined" && (0, B.V9)(m, CustomEvent)) {
          _.detail = m.detail;
        }
        return _;
      }
    }
    function serializeEventTarget(m) {
      try {
        if ((0, B.kK)(m)) {
          return (0, R.Rt)(m);
        } else {
          return Object.prototype.toString.call(m);
        }
      } catch (m) {
        return "<unknown>";
      }
    }
    function getOwnProperties(m) {
      if (typeof m != "object" || m === null) {
        return {};
      }
      {
        let _ = {};
        for (let C in m) {
          if (Object.prototype.hasOwnProperty.call(m, C)) {
            _[C] = m[C];
          }
        }
        return _;
      }
    }
    function extractExceptionKeysForMessage(m, _ = 40) {
      let C = Object.keys(convertToPlainObject(m));
      C.sort();
      let R = C[0];
      if (!R) {
        return "[object has no keys]";
      }
      if (R.length >= _) {
        return (0, U.$G)(R, _);
      }
      for (let m = C.length; m > 0; m--) {
        let R = C.slice(0, m).join(", ");
        if (!(R.length > _)) {
          if (m === C.length) {
            return R;
          }
          return (0, U.$G)(R, _);
        }
      }
      return "";
    }
    function dropUndefinedKeys(m) {
      let _ = new Map();
      return function _dropUndefinedKeys(m, _) {
        if (function (m) {
          if (!(0, B.PO)(m)) {
            return false;
          }
          try {
            let _ = Object.getPrototypeOf(m).constructor.name;
            return !_ || _ === "Object";
          } catch (m) {
            return true;
          }
        }(m)) {
          let C = _.get(m);
          if (C !== undefined) {
            return C;
          }
          let R = {};
          _.set(m, R);
          for (let C of Object.getOwnPropertyNames(m)) {
            if (m[C] !== undefined) {
              R[C] = _dropUndefinedKeys(m[C], _);
            }
          }
          return R;
        }
        if (Array.isArray(m)) {
          let C = _.get(m);
          if (C !== undefined) {
            return C;
          }
          let R = [];
          _.set(m, R);
          m.forEach(m => {
            R.push(_dropUndefinedKeys(m, _));
          });
          return R;
        }
        return m;
      }(m, _);
    }
  },
  19548: function (m, _, C) {
    "use strict";

    C.d(_, {
      Q: function () {
        return generatePropagationContext;
      }
    });
    var R = C(41982);
    function generatePropagationContext() {
      return {
        traceId: (0, R.DM)(),
        spanId: (0, R.DM)().substring(16)
      };
    }
  },
  42283: function (m, _, C) {
    "use strict";

    C.d(_, {
      $P: function () {
        return getFunctionName;
      },
      Fi: function () {
        return R;
      },
      Fr: function () {
        return getFramesFromEvent;
      },
      Sq: function () {
        return stackParserFromStackParserOptions;
      },
      pE: function () {
        return createStackParser;
      }
    });
    let R = "?";
    let L = /\(error: (.*)\)/;
    let B = /captureMessage|captureException/;
    function createStackParser(...m) {
      let _ = m.sort((m, _) => m[0] - _[0]).map(m => m[1]);
      return (m, C = 0, F = 0) => {
        let U = [];
        let H = m.split("\n");
        for (let m = C; m < H.length; m++) {
          let C = H[m];
          if (C.length > 1024) {
            continue;
          }
          let R = L.test(C) ? C.replace(L, "$1") : C;
          if (!R.match(/\S*Error: /)) {
            for (let m of _) {
              let _ = m(R);
              if (_) {
                U.push(_);
                break;
              }
            }
            if (U.length >= 50 + F) {
              break;
            }
          }
        }
        return function (m) {
          if (!m.length) {
            return [];
          }
          let _ = Array.from(m);
          if (/sentryWrapped/.test(getLastStackFrame(_).function || "")) {
            _.pop();
          }
          _.reverse();
          if (B.test(getLastStackFrame(_).function || "")) {
            _.pop();
            if (B.test(getLastStackFrame(_).function || "")) {
              _.pop();
            }
          }
          return _.slice(0, 50).map(m => ({
            ...m,
            filename: m.filename || getLastStackFrame(_).filename,
            function: m.function || R
          }));
        }(U.slice(F));
      };
    }
    function stackParserFromStackParserOptions(m) {
      if (Array.isArray(m)) {
        return createStackParser(...m);
      } else {
        return m;
      }
    }
    function getLastStackFrame(m) {
      return m[m.length - 1] || {};
    }
    let F = "<anonymous>";
    function getFunctionName(m) {
      try {
        if (!m || typeof m != "function") {
          return F;
        }
        return m.name || F;
      } catch (m) {
        return F;
      }
    }
    function getFramesFromEvent(m) {
      let _ = m.exception;
      if (_) {
        let m = [];
        try {
          _.values.forEach(_ => {
            if (_.stacktrace.frames) {
              m.push(..._.stacktrace.frames);
            }
          });
          return m;
        } catch (m) {}
      }
    }
  },
  89163: function (m, _, C) {
    "use strict";

    C.d(_, {
      $G: function () {
        return truncate;
      },
      U0: function () {
        return stringMatchesSomePattern;
      },
      nK: function () {
        return safeJoin;
      }
    });
    var R = C(16824);
    function truncate(m, _ = 0) {
      if (typeof m != "string" || _ === 0) {
        return m;
      } else if (m.length <= _) {
        return m;
      } else {
        return `${m.slice(0, _)}...`;
      }
    }
    function safeJoin(m, _) {
      if (!Array.isArray(m)) {
        return "";
      }
      let C = [];
      for (let _ = 0; _ < m.length; _++) {
        let L = m[_];
        try {
          if ((0, R.y1)(L)) {
            C.push("[VueViewModel]");
          } else {
            C.push(String(L));
          }
        } catch (m) {
          C.push("[value cannot be serialized]");
        }
      }
      return C.join(_);
    }
    function stringMatchesSomePattern(m, _ = [], C = false) {
      return _.some(_ => function (m, _, C = false) {
        return !!(0, R.HD)(m) && ((0, R.Kj)(_) ? _.test(m) : !!(0, R.HD)(_) && (C ? m === _ : m.includes(_)));
      }(m, _, C));
    }
  },
  80128: function (m, _, C) {
    "use strict";

    C.d(_, {
      $2: function () {
        return rejectedSyncPromise;
      },
      WD: function () {
        return resolvedSyncPromise;
      },
      cW: function () {
        return SyncPromise;
      }
    });
    var R;
    var L;
    var B = C(16824);
    function resolvedSyncPromise(m) {
      return new SyncPromise(_ => {
        _(m);
      });
    }
    function rejectedSyncPromise(m) {
      return new SyncPromise((_, C) => {
        C(m);
      });
    }
    (R = L ||= {})[R.PENDING = 0] = "PENDING";
    R[R.RESOLVED = 1] = "RESOLVED";
    R[R.REJECTED = 2] = "REJECTED";
    let SyncPromise = class SyncPromise {
      constructor(m) {
        SyncPromise.prototype.__init.call(this);
        SyncPromise.prototype.__init2.call(this);
        SyncPromise.prototype.__init3.call(this);
        SyncPromise.prototype.__init4.call(this);
        this._state = L.PENDING;
        this._handlers = [];
        try {
          m(this._resolve, this._reject);
        } catch (m) {
          this._reject(m);
        }
      }
      then(m, _) {
        return new SyncPromise((C, R) => {
          this._handlers.push([false, _ => {
            if (m) {
              try {
                C(m(_));
              } catch (m) {
                R(m);
              }
            } else {
              C(_);
            }
          }, m => {
            if (_) {
              try {
                C(_(m));
              } catch (m) {
                R(m);
              }
            } else {
              R(m);
            }
          }]);
          this._executeHandlers();
        });
      }
      catch(m) {
        return this.then(m => m, m);
      }
      finally(m) {
        return new SyncPromise((_, C) => {
          let R;
          let L;
          return this.then(_ => {
            L = false;
            R = _;
            if (m) {
              m();
            }
          }, _ => {
            L = true;
            R = _;
            if (m) {
              m();
            }
          }).then(() => {
            if (L) {
              C(R);
              return;
            }
            _(R);
          });
        });
      }
      __init() {
        this._resolve = m => {
          this._setResult(L.RESOLVED, m);
        };
      }
      __init2() {
        this._reject = m => {
          this._setResult(L.REJECTED, m);
        };
      }
      __init3() {
        this._setResult = (m, _) => {
          if (this._state === L.PENDING) {
            if ((0, B.J8)(_)) {
              _.then(this._resolve, this._reject);
              return;
            }
            this._state = m;
            this._value = _;
            this._executeHandlers();
          }
        };
      }
      __init4() {
        this._executeHandlers = () => {
          if (this._state === L.PENDING) {
            return;
          }
          let m = this._handlers.slice();
          this._handlers = [];
          m.forEach(m => {
            if (!m[0]) {
              if (this._state === L.RESOLVED) {
                m[1](this._value);
              }
              if (this._state === L.REJECTED) {
                m[2](this._value);
              }
              m[0] = true;
            }
          });
        };
      }
    };
  },
  26181: function (m, _, C) {
    "use strict";

    C.d(_, {
      Z1: function () {
        return B;
      },
      ph: function () {
        return L;
      },
      yW: function () {
        return dateTimestampInSeconds;
      }
    });
    var R = C(29531);
    function dateTimestampInSeconds() {
      return Date.now() / 1000;
    }
    let L = function () {
      let {
        performance: m
      } = R.GLOBAL_OBJ;
      if (!m || !m.now) {
        return dateTimestampInSeconds;
      }
      let _ = Date.now() - m.now();
      let C = m.timeOrigin == undefined ? _ : m.timeOrigin;
      return () => (C + m.now()) / 1000;
    }();
    let B = (() => {
      let {
        performance: m
      } = R.GLOBAL_OBJ;
      if (!m || !m.now) {
        return;
      }
      let _ = m.now();
      let C = Date.now();
      let L = m.timeOrigin ? Math.abs(m.timeOrigin + _ - C) : 3600000;
      let B = m.timing && m.timing.navigationStart;
      let F = typeof B == "number" ? Math.abs(B + _ - C) : 3600000;
      if (L < 3600000 || F < 3600000) {
        if (L <= F) {
          return m.timeOrigin;
        } else {
          return B;
        }
      } else {
        return C;
      }
    })();
  },
  85712: function (m, _, C) {
    "use strict";

    C.d(_, {
      $p: function () {
        return generateSentryTraceHeader;
      },
      pT: function () {
        return propagationContextFromHeaders;
      }
    });
    var R = C(60859);
    var L = C(41982);
    let B = RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
    function propagationContextFromHeaders(m, _) {
      let C = function (m) {
        let _;
        if (!m) {
          return;
        }
        let C = m.match(B);
        if (C) {
          if (C[3] === "1") {
            _ = true;
          } else if (C[3] === "0") {
            _ = false;
          }
          return {
            traceId: C[1],
            parentSampled: _,
            parentSpanId: C[2]
          };
        }
      }(m);
      let F = (0, R.EN)(_);
      let {
        traceId: U,
        parentSpanId: H,
        parentSampled: q
      } = C || {};
      if (C) {
        return {
          traceId: U || (0, L.DM)(),
          parentSpanId: H || (0, L.DM)().substring(16),
          spanId: (0, L.DM)().substring(16),
          sampled: q,
          dsc: F || {}
        };
      } else {
        return {
          traceId: U || (0, L.DM)(),
          spanId: (0, L.DM)().substring(16)
        };
      }
    }
    function generateSentryTraceHeader(m = (0, L.DM)(), _ = (0, L.DM)().substring(16), C) {
      let R = "";
      if (C !== undefined) {
        R = C ? "-1" : "-0";
      }
      return `${m}-${_}${R}`;
    }
  },
  42990: function (m, _, C) {
    "use strict";

    C.d(_, {
      J: function () {
        return R;
      }
    });
    let R = "8.34.0";
  },
  29531: function (m, _, C) {
    "use strict";

    C.d(_, {
      GLOBAL_OBJ: function () {
        return L;
      },
      Y: function () {
        return getGlobalSingleton;
      }
    });
    var R = C(42990);
    let L = globalThis;
    function getGlobalSingleton(m, _, C) {
      let B = C || L;
      let F = B.__SENTRY__ = B.__SENTRY__ || {};
      let U = F[R.J] = F[R.J] || {};
      return U[m] ||= _();
    }
  },
  86501: function (m, _, C) {
    "use strict";

    let R;
    let L;
    C.d(_, {
      x7: function () {
        return Ie;
      },
      ZP: function () {
        return ek;
      },
      Am: function () {
        return dist_n;
      }
    });
    var B;
    var F = C(67294);
    let U = {
      data: ""
    };
    let t = m => typeof window == "object" ? ((m ? m.querySelector("#_goober") : window._goober) || Object.assign((m || document.head).appendChild(document.createElement("style")), {
      innerHTML: " ",
      id: "_goober"
    })).firstChild : m || U;
    let H = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g;
    let q = /\/\*[^]*?\*\/|  +/g;
    let V = /\n+/g;
    let o = (m, _) => {
      let C = "";
      let R = "";
      let L = "";
      for (let B in m) {
        let F = m[B];
        if (B[0] == "@") {
          if (B[1] == "i") {
            C = B + " " + F + ";";
          } else {
            R += B[1] == "f" ? o(F, B) : B + "{" + o(F, B[1] == "k" ? "" : _) + "}";
          }
        } else if (typeof F == "object") {
          R += o(F, _ ? _.replace(/([^,])+/g, m => B.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, _ => /&/.test(_) ? _.replace(/&/g, m) : m ? m + " " + _ : _)) : B);
        } else if (F != null) {
          B = /^--/.test(B) ? B : B.replace(/[A-Z]/g, "-$&").toLowerCase();
          L += o.p ? o.p(B, F) : B + ":" + F + ";";
        }
      }
      return C + (_ && L ? _ + "{" + L + "}" : L) + R;
    };
    let X = {};
    let s = m => {
      if (typeof m == "object") {
        let _ = "";
        for (let C in m) {
          _ += C + s(m[C]);
        }
        return _;
      }
      return m;
    };
    let i = (m, _, C, R, L) => {
      var B;
      let F = s(m);
      let U = X[F] ||= (m => {
        let _ = 0;
        let C = 11;
        while (_ < m.length) {
          C = C * 101 + m.charCodeAt(_++) >>> 0;
        }
        return "go" + C;
      })(F);
      if (!X[U]) {
        let _ = F !== m ? m : (m => {
          let _;
          let C;
          let R = [{}];
          while (_ = H.exec(m.replace(q, ""))) {
            if (_[4]) {
              R.shift();
            } else if (_[3]) {
              C = _[3].replace(V, " ").trim();
              R.unshift(R[0][C] = R[0][C] || {});
            } else {
              R[0][_[1]] = _[2].replace(V, " ").trim();
            }
          }
          return R[0];
        })(m);
        X[U] = o(L ? {
          ["@keyframes " + U]: _
        } : _, C ? "" : "." + U);
      }
      let K = C && X.g ? X.g : null;
      if (C) {
        X.g = X[U];
      }
      B = X[U];
      if (K) {
        _.data = _.data.replace(K, B);
      } else if (_.data.indexOf(B) === -1) {
        _.data = R ? B + _.data : _.data + B;
      }
      return U;
    };
    let p = (m, _, C) => m.reduce((m, R, L) => {
      let B = _[L];
      if (B && B.call) {
        let m = B(C);
        let _ = m && m.props && m.props.className || /^go/.test(m) && m;
        B = _ ? "." + _ : m && typeof m == "object" ? m.props ? "" : o(m, "") : m === false ? "" : m;
      }
      return m + R + (B == null ? "" : B);
    }, "");
    function u(m) {
      let _ = this || {};
      let C = m.call ? m(_.p) : m;
      return i(C.unshift ? C.raw ? p(C, [].slice.call(arguments, 1), _.p) : C.reduce((m, C) => Object.assign(m, C && C.call ? C(_.p) : C), {}) : C, t(_.target), _.g, _.o, _.k);
    }
    u.bind({
      g: 1
    });
    let K;
    let Y;
    let Q;
    let et = u.bind({
      k: 1
    });
    function j(m, _) {
      let C = this || {};
      return function () {
        let R = arguments;
        function a(L, B) {
          let F = Object.assign({}, L);
          let U = F.className || a.className;
          C.p = Object.assign({
            theme: Y && Y()
          }, F);
          C.o = / *go\d+/.test(U);
          F.className = u.apply(C, R) + (U ? " " + U : "");
          if (_) {
            F.ref = B;
          }
          let H = m;
          if (m[0]) {
            H = F.as || m;
            delete F.as;
          }
          if (Q && H[0]) {
            Q(F);
          }
          return K(H, F);
        }
        if (_) {
          return _(a);
        } else {
          return a;
        }
      };
    }
    var W = m => typeof m == "function";
    var T = (m, _) => W(m) ? m(_) : m;
    R = 0;
    var er = () => (++R).toString();
    var dist_b = () => {
      if (L === undefined && typeof window !== "undefined") {
        let m = matchMedia("(prefers-reduced-motion: reduce)");
        L = !m || m.matches;
      }
      return L;
    };
    var en = new Map();
    var $ = m => {
      if (en.has(m)) {
        return;
      }
      let _ = setTimeout(() => {
        en.delete(m);
        dist_u({
          type: 4,
          toastId: m
        });
      }, 1000);
      en.set(m, _);
    };
    var J = m => {
      let _ = en.get(m);
      if (_) {
        clearTimeout(_);
      }
    };
    var v = (m, _) => {
      switch (_.type) {
        case 0:
          return {
            ...m,
            toasts: [_.toast, ...m.toasts].slice(0, 20)
          };
        case 1:
          if (_.toast.id) {
            J(_.toast.id);
          }
          return {
            ...m,
            toasts: m.toasts.map(m => m.id === _.toast.id ? {
              ...m,
              ..._.toast
            } : m)
          };
        case 2:
          let {
            toast: C
          } = _;
          if (m.toasts.find(m => m.id === C.id)) {
            return v(m, {
              type: 1,
              toast: C
            });
          } else {
            return v(m, {
              type: 0,
              toast: C
            });
          }
        case 3:
          let {
            toastId: R
          } = _;
          if (R) {
            $(R);
          } else {
            m.toasts.forEach(m => {
              $(m.id);
            });
          }
          return {
            ...m,
            toasts: m.toasts.map(m => m.id === R || R === undefined ? {
              ...m,
              visible: false
            } : m)
          };
        case 4:
          if (_.toastId === undefined) {
            return {
              ...m,
              toasts: []
            };
          } else {
            return {
              ...m,
              toasts: m.toasts.filter(m => m.id !== _.toastId)
            };
          }
        case 5:
          return {
            ...m,
            pausedAt: _.time
          };
        case 6:
          let L = _.time - (m.pausedAt || 0);
          return {
            ...m,
            pausedAt: undefined,
            toasts: m.toasts.map(m => ({
              ...m,
              pauseDuration: m.pauseDuration + L
            }))
          };
      }
    };
    var ei = [];
    var eo = {
      toasts: [],
      pausedAt: undefined
    };
    var dist_u = m => {
      eo = v(eo, m);
      ei.forEach(m => {
        m(eo);
      });
    };
    var ea = {
      blank: 4000,
      error: 4000,
      success: 2000,
      loading: Infinity,
      custom: 4000
    };
    var I = (m = {}) => {
      let [_, C] = (0, F.useState)(eo);
      (0, F.useEffect)(() => {
        ei.push(C);
        return () => {
          let m = ei.indexOf(C);
          if (m > -1) {
            ei.splice(m, 1);
          }
        };
      }, [_]);
      let R = _.toasts.map(_ => {
        var C;
        var R;
        return {
          ...m,
          ...m[_.type],
          ..._,
          duration: _.duration || ((C = m[_.type]) == null ? undefined : C.duration) || (m == null ? undefined : m.duration) || ea[_.type],
          style: {
            ...m.style,
            ...((R = m[_.type]) == null ? undefined : R.style),
            ..._.style
          }
        };
      });
      return {
        ..._,
        toasts: R
      };
    };
    var G = (m, _ = "blank", C) => ({
      createdAt: Date.now(),
      visible: true,
      type: _,
      ariaProps: {
        role: "status",
        "aria-live": "polite"
      },
      message: m,
      pauseDuration: 0,
      ...C,
      id: (C == null ? undefined : C.id) || er()
    });
    var dist_h = m => (_, C) => {
      let R = G(_, m, C);
      dist_u({
        type: 2,
        toast: R
      });
      return R.id;
    };
    var dist_n = (m, _) => dist_h("blank")(m, _);
    dist_n.error = dist_h("error");
    dist_n.success = dist_h("success");
    dist_n.loading = dist_h("loading");
    dist_n.custom = dist_h("custom");
    dist_n.dismiss = m => {
      dist_u({
        type: 3,
        toastId: m
      });
    };
    dist_n.remove = m => dist_u({
      type: 4,
      toastId: m
    });
    dist_n.promise = (m, _, C) => {
      let R = dist_n.loading(_.loading, {
        ...C,
        ...(C == null ? undefined : C.loading)
      });
      m.then(m => {
        dist_n.success(T(_.success, m), {
          id: R,
          ...C,
          ...(C == null ? undefined : C.success)
        });
        return m;
      }).catch(m => {
        dist_n.error(T(_.error, m), {
          id: R,
          ...C,
          ...(C == null ? undefined : C.error)
        });
      });
      return m;
    };
    var Z = (m, _) => {
      dist_u({
        type: 1,
        toast: {
          id: m,
          height: _
        }
      });
    };
    var ee = () => {
      dist_u({
        type: 5,
        time: Date.now()
      });
    };
    var D = m => {
      let {
        toasts: _,
        pausedAt: C
      } = I(m);
      (0, F.useEffect)(() => {
        if (C) {
          return;
        }
        let m = Date.now();
        let R = _.map(_ => {
          if (_.duration === Infinity) {
            return;
          }
          let C = (_.duration || 0) + _.pauseDuration - (m - _.createdAt);
          if (C < 0) {
            if (_.visible) {
              dist_n.dismiss(_.id);
            }
            return;
          }
          return setTimeout(() => dist_n.dismiss(_.id), C);
        });
        return () => {
          R.forEach(m => m && clearTimeout(m));
        };
      }, [_, C]);
      let R = (0, F.useCallback)(() => {
        if (C) {
          dist_u({
            type: 6,
            time: Date.now()
          });
        }
      }, [C]);
      let L = (0, F.useCallback)((m, C) => {
        let {
          reverseOrder: R = false,
          gutter: L = 8,
          defaultPosition: B
        } = C || {};
        let F = _.filter(_ => (_.position || B) === (m.position || B) && _.height);
        let U = F.findIndex(_ => _.id === m.id);
        let H = F.filter((m, _) => _ < U && m.visible).length;
        return F.filter(m => m.visible).slice(...(R ? [H + 1] : [0, H])).reduce((m, _) => m + (_.height || 0) + L, 0);
      }, [_]);
      return {
        toasts: _,
        handlers: {
          updateHeight: Z,
          startPause: ee,
          endPause: R,
          calculateOffset: L
        }
      };
    };
    var es = et`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`;
    var ec = et`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`;
    var el = et`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`;
    var eu = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${m => m.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${es} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${ec} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${m => m.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${el} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
    var ed = et`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
    var ep = j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${m => m.secondary || "#e0e0e0"};
  border-right-color: ${m => m.primary || "#616161"};
  animation: ${ed} 1s linear infinite;
`;
    var eh = et`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`;
    var ef = et`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`;
    var em = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${m => m.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${eh} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ef} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${m => m.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
    var eg = j("div")`
  position: absolute;
`;
    var ey = j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`;
    var e_ = et`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`;
    var ev = j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${e_} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`;
    var M = ({
      toast: m
    }) => {
      let {
        icon: _,
        type: C,
        iconTheme: R
      } = m;
      if (_ !== undefined) {
        if (typeof _ == "string") {
          return F.createElement(ev, null, _);
        } else {
          return _;
        }
      } else if (C === "blank") {
        return null;
      } else {
        return F.createElement(ey, null, F.createElement(ep, {
          ...R
        }), C !== "loading" && F.createElement(eg, null, C === "error" ? F.createElement(eu, {
          ...R
        }) : F.createElement(em, {
          ...R
        })));
      }
    };
    var ye = m => `
0% {transform: translate3d(0,${m * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`;
    var ge = m => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${m * -150}%,-1px) scale(.6); opacity:0;}
`;
    var eb = j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`;
    var eS = j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`;
    var Ae = (m, _) => {
      let C = m.includes("top") ? 1 : -1;
      let [R, L] = dist_b() ? ["0%{opacity:0;} 100%{opacity:1;}", "0%{opacity:1;} 100%{opacity:0;}"] : [ye(C), ge(C)];
      return {
        animation: _ ? `${et(R)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${et(L)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
      };
    };
    var ew = F.memo(({
      toast: m,
      position: _,
      style: C,
      children: R
    }) => {
      let L = m.height ? Ae(m.position || _ || "top-center", m.visible) : {
        opacity: 0
      };
      let B = F.createElement(M, {
        toast: m
      });
      let U = F.createElement(eS, {
        ...m.ariaProps
      }, T(m.message, m));
      return F.createElement(eb, {
        className: m.className,
        style: {
          ...L,
          ...C,
          ...m.style
        }
      }, typeof R == "function" ? R({
        icon: B,
        message: U
      }) : F.createElement(F.Fragment, null, B, U));
    });
    B = F.createElement;
    o.p = undefined;
    K = B;
    Y = undefined;
    Q = undefined;
    var Ee = ({
      id: m,
      className: _,
      style: C,
      onHeightUpdate: R,
      children: L
    }) => {
      let B = F.useCallback(_ => {
        if (_) {
          let i = () => {
            R(m, _.getBoundingClientRect().height);
          };
          i();
          new MutationObserver(i).observe(_, {
            subtree: true,
            childList: true,
            characterData: true
          });
        }
      }, [m, R]);
      return F.createElement("div", {
        ref: B,
        className: _,
        style: C
      }, L);
    };
    var Re = (m, _) => {
      let C = m.includes("top");
      let R = m.includes("center") ? {
        justifyContent: "center"
      } : m.includes("right") ? {
        justifyContent: "flex-end"
      } : {};
      return {
        left: 0,
        right: 0,
        display: "flex",
        position: "absolute",
        transition: dist_b() ? undefined : "all 230ms cubic-bezier(.21,1.02,.73,1)",
        transform: `translateY(${_ * (C ? 1 : -1)}px)`,
        ...(C ? {
          top: 0
        } : {
          bottom: 0
        }),
        ...R
      };
    };
    var eE = u`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
    var Ie = ({
      reverseOrder: m,
      position: _ = "top-center",
      toastOptions: C,
      gutter: R,
      children: L,
      containerStyle: B,
      containerClassName: U
    }) => {
      let {
        toasts: H,
        handlers: q
      } = D(C);
      return F.createElement("div", {
        style: {
          position: "fixed",
          zIndex: 9999,
          top: 16,
          left: 16,
          right: 16,
          bottom: 16,
          pointerEvents: "none",
          ...B
        },
        className: U,
        onMouseEnter: q.startPause,
        onMouseLeave: q.endPause
      }, H.map(C => {
        let B = C.position || _;
        let U = Re(B, q.calculateOffset(C, {
          reverseOrder: m,
          gutter: R,
          defaultPosition: _
        }));
        return F.createElement(Ee, {
          id: C.id,
          key: C.id,
          onHeightUpdate: q.updateHeight,
          className: C.visible ? eE : "",
          style: U
        }, C.type === "custom" ? T(C.message, C) : L ? L(C) : F.createElement(ew, {
          toast: C,
          position: B
        }));
      }));
    };
    var ek = dist_n;
  }
}, function (m) {
  function __webpack_exec__(_) {
    return m(m.s = _);
  }
  m.O(0, [9774, 179], function () {
    __webpack_exec__(53215);
    __webpack_exec__(6840);
    __webpack_exec__(69420) // hehe
    return __webpack_exec__(32059);
  });
  _N_E = m.O();
}]);